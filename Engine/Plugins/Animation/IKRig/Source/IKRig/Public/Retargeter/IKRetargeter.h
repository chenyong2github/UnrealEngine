// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "IKRigDefinition.h"

#include "IKRetargeter.generated.h"

struct FIKRetargetPose;

struct UE_DEPRECATED(5.1, "Use URetargetChainSettings instead.") FRetargetChainMap;
USTRUCT()
struct IKRIG_API FRetargetChainMap
{
	GENERATED_BODY()

	FRetargetChainMap() = default;
	FRetargetChainMap(const FName& TargetChain) : TargetChain(TargetChain){}
	
	UPROPERTY(EditAnywhere, Category = Offsets)
	FName SourceChain = NAME_None;
	
	UPROPERTY(EditAnywhere, Category = Offsets)
	FName TargetChain = NAME_None;
};

UENUM(BlueprintType)
enum class ERetargetTranslationMode : uint8
{
	None			UMETA(DisplayName = "None"),
	GloballyScaled	UMETA(DisplayName = "Globally Scaled"),
	Absolute		UMETA(DisplayName = "Absolute"),
};

UENUM(BlueprintType)
enum class ERetargetRotationMode : uint8
{
	
	Interpolated		UMETA(DisplayName = "Interpolated"),
	OneToOne			UMETA(DisplayName = "One to One"),
	OneToOneReversed	UMETA(DisplayName = "One to One Reversed"),
	None				UMETA(DisplayName = "None"),
};

UCLASS()
class IKRIG_API URetargetChainSettings : public UObject
{
	GENERATED_BODY()

	public:
	
	URetargetChainSettings() = default;
	
	URetargetChainSettings(const FName& TargetChain) : TargetChain(TargetChain){}
	
	/** The chain on the Source IK Rig asset to copy animation FROM. */
	UPROPERTY(VisibleAnywhere, Category = "Chain Mapping")
	FName SourceChain;

	/** The chain on the Target IK Rig asset to copy animation TO. */
	UPROPERTY(VisibleAnywhere, Category = "Chain Mapping")
	FName TargetChain;

	/** Whether to copy the shape of the chain from the source skeleton using the Rotation and Translation modes. Default is true.
	* NOTE: All FK operations run before the IK pass to copy the shape of the FK chain from the source skeleton. */
	UPROPERTY(EditAnywhere, Category = "FK Adjustments")
	bool CopyPoseUsingFK = true;
	
	/** Determines how rotation is copied from the source chain to the target chain. Default is Interpolated.
	* Interpolated: Source and target chains are normalized by their length, then each target bone rotation is generated by finding the rotation at the same normalized distance on the source chain and interpolating between the neighboring bones.
	* One to One: Each target bone rotation is copied from the equivalent bone in the source chain, based on the order in the chain, starting at the root of the chain. If the target chain has more bones than the source, the extra bones will remain at their reference pose.
	* One to One Reversed: Same as One-to-One, but starting from the tip of the chain.
	* None: The rotation of each target bone in the chain is left at the reference pose. */
	UPROPERTY(EditAnywhere, Category = "FK Adjustments")
	ERetargetRotationMode RotationMode;

	/** Range +/- infinity. Default 1. Scales the amount of rotation that is applied.
	*  If Rotation Mode is None this parameter has no effect.
	*  Otherwise, this parameter blends the rotation of each bone in the chain from the base retarget pose (0) to the retargeted pose (1).*/
	UPROPERTY(EditAnywhere, Category = "FK Adjustments", meta = (UIMin = "0.0", UIMax = "1.0"))
	float RotationAlpha = 1.0f;

	/** Determines how translation is copied from the source chain to the target chain. Default is None.
	* None: Translation of target bones are left unmodified from the retarget pose.
	* Globally Scaled: Translation of target bone is set to the source bone offset multiplied by the global scale of the skeleton (determined by the relative height difference between retarget root bones).
	* Absolute: Translation of target bone is set to the absolute position of the source bone. */
	UPROPERTY(EditAnywhere, Category = "FK Adjustments")
	ERetargetTranslationMode TranslationMode;

	/** Range +/- infinity. Default 1. Scales the amount of translation that is applied. Exact behavior depends on the Translation Mode.
	*  In None Mode, this parameter has no effect.
	*  In Globally Scaled and Absolute modes, the translation offset is scaled by this parameter.*/
	UPROPERTY(EditAnywhere, Category = "FK Adjustments", meta = (UIMin = "0.0", UIMax = "1.0"))
	float TranslationAlpha = 1.0f;

	/** Whether to modify the location of the IK goal on this chain. Default is true.
	 * NOTE: This only has an effect if the chain has an IK Goal assigned to it in the Target IK Rig asset.
	 * NOTE: If off, and this chain has an IK Goal, the IK will still be evaluated, but the Goal is set to the input bone location (from the FK pass).*/
	UPROPERTY(EditAnywhere, Category = "IK Adjustments")
	bool DriveIKGoal = true;

	/** Range 0 to 1. Default 0. Blends IK goal position from retargeted location (0) to source bone location (1).
	*  At 0 the goal is placed at the retargeted location.
	*  At 1 the goal is placed at the location of the source chain's end bone. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments", meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
	float BlendToSource = 0.0f;
	
	/** Range 0 to 1. Default 1. Weight each axis separately when using Blend To Source.
	*  At 0 the goal is placed at the retargeted location.
	*  At 1 the goal is placed at the location of the source chain's end bone. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments", meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0"))
	FVector BlendToSourceWeights = FVector::OneVector;

	/** Default 0, 0, 0. Apply static global-space offset to IK goal position. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments")
	FVector StaticOffset;

	/** Default 0, 0, 0. Apply static local-space offset to IK goal position. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments")
	FVector StaticLocalOffset;

	/** Default 0, 0, 0. Apply static local-space offset to IK goal rotation. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments")
	FRotator StaticRotationOffset;
	
	/** Range 0 to 5. Default 1. Brings IK goal closer (-) or further (+) from origin of chain.
	*  At 0 the effector is placed at the origin of the chain.
	*  Values greater than 1 will stretch the chain beyond the retargeted length. */
	UPROPERTY(EditAnywhere, Category = "IK Adjustments", meta = (ClampMin = "0.0", ClampMax = "5.0", UIMin = "0.1", UIMax = "2.0"))
	float Extension = 1.0f;

	/** The name of the curve on the source animation that contains the speed of the end effector bone.*/
	UPROPERTY(EditAnywhere, Category = "Plant IK by Speed", meta = (ClampMin = "0.0", ClampMax = "100.0", UIMin = "0.0", UIMax = "100.0"))
	bool UseSpeedCurveToPlantIK = false;
	
	/** The name of the curve on the source animation that contains the speed of the end effector bone.*/
	UPROPERTY(EditAnywhere, Category = "Plant IK by Speed", meta = (ClampMin = "0.0", ClampMax = "100.0", UIMin = "0.0", UIMax = "100.0"))
	FName SpeedCurveName;

	/** Range 0 to 1000. Default 15. The maximum speed a source bone can be moving while being considered 'planted'.
	*  The target IK goal will not be allowed to move whenever the source bone speed drops below this threshold speed. */
	UPROPERTY(EditAnywhere, Category = "Plant IK by Speed", meta = (ClampMin = "0.0", ClampMax = "100.0", UIMin = "0.0", UIMax = "100.0"))
	float VelocityThreshold = 15.0f;

	// How stiff the spring model is that smoothly pulls the IK position after unplanting (more stiffness means more oscillation around the target value)
	UPROPERTY(EditAnywhere, Category = "Plant IK by Speed", meta = (ClampMin = "0.0", UIMin = "0.0"))
	float UnplantStiffness = 250.0f;

	// How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
	UPROPERTY(EditAnywhere, Category = "Plant IK by Speed", meta = (ClampMin = "0.0", ClampMax = "10.0", UIMin = "0.0", UIMax = "1.0"))
	float UnplantCriticalDamping = 1.0f;
};

UCLASS()
class IKRIG_API URetargetRootSettings: public UObject
{
	GENERATED_BODY()

	public:
	
	URetargetRootSettings() = default;

	/** Whether to modify the location of the retarget root bone. Default is true. */
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings")
	bool RetargetRootTranslation = true;

	/** Default 1. Scales the motion of the root position in the horizontal plane (X,Y). */
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings", meta = (UIMin = "0.0", UIMax = "3.0"))
	float GlobalScaleHorizontal = 1.0f;

	/** Default 1. Scales the motion of the root position in the vertical direction (Z). */
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings", meta = (UIMin = "0.0", UIMax = "3.0"))
	float GlobalScaleVertical = 1.0f;
	
	/** Range 0 to 1. Default 0. Blends the retarget root's translation to the exact source location (per axis).
	*  At 0 the root is placed at the retargeted location.
	*  At 1 the root is placed at the location of the source's retarget root bone. */
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings")
	FVector BlendToSource = FVector::ZeroVector;

	/** Applies a static component-space translation offset to the retarget root.*/
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings")
	FVector StaticOffset = FVector::ZeroVector;

	/** Applies a static component-space rotation offset to the retarget root.*/
	UPROPERTY(EditAnywhere, Category = "Root Retarget Settings")
	FRotator StaticRotationOffset = FRotator::ZeroRotator;
};

USTRUCT()
struct IKRIG_API FIKRetargetPose
{
	GENERATED_BODY()
	
public:
	
	FIKRetargetPose() = default;

	// a translational delta in GLOBAL space, applied only to the retarget root bone
	UPROPERTY(EditAnywhere, Category = RetargetPose)
	FVector RootTranslationOffset = FVector::ZeroVector;

	// these are LOCAL-space rotation deltas to be applied to a bone to modify it's retarget pose
	UPROPERTY(EditAnywhere, Category = RetargetPose)
	TMap<FName, FQuat> BoneRotationOffsets;
	
	void SetBoneRotationOffset(FName BoneName, FQuat RotationOffset, const FIKRigSkeleton& Skeleton);
	void SetRootTranslationDelta(FVector TranslationDelta);
	void AddToRootTranslationDelta(FVector TranslationDelta);
	void SortHierarchically(const FIKRigSkeleton& Skeleton);
};

UCLASS(Blueprintable)
class IKRIG_API URetargetPose: public UObject
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere, Category = RetargetPose)
	FVector RootTranslationOffset = FVector::ZeroVector;
	
	UPROPERTY(EditAnywhere, Category = RetargetPose)
	TMap<FName, FQuat> BoneRotationOffsets;

	void GetAsRetargetPose(FIKRetargetPose& OutPose) const
	{
		OutPose.RootTranslationOffset = RootTranslationOffset;
		OutPose.BoneRotationOffsets = BoneRotationOffsets;
	}
};

#if WITH_EDITOR
enum class ERetargeterOutputMode : uint8
{
	RunRetarget,
	ShowRetargetPose,
	EditRetargetPose
};
#endif

UCLASS(Blueprintable)
class IKRIG_API UIKRetargeter : public UObject
{
	GENERATED_BODY()
	
public:
	
	UIKRetargeter(const FObjectInitializer& ObjectInitializer);

	/** Get read-only access to the source IK Rig asset */
	const UIKRigDefinition* GetSourceIKRig() const { return SourceIKRigAsset.LoadSynchronous(); };
	/** Get read-only access to the target IK Rig asset */
	const UIKRigDefinition* GetTargetIKRig() const { return TargetIKRigAsset.LoadSynchronous(); };
	/** Get read-write access to the source IK Rig asset.
	 * WARNING: do not use for editing the data model. Use Controller class instead. */
	 UIKRigDefinition* GetSourceIKRigWriteable() const { return SourceIKRigAsset.LoadSynchronous(); };
	/** Get read-write access to the target IK Rig asset.
	 * WARNING: do not use for editing the data model. Use Controller class instead. */
	UIKRigDefinition* GetTargetIKRigWriteable() const { return TargetIKRigAsset.LoadSynchronous(); };
	/** Get read-only access to the chain mapping */
	const TArray<TObjectPtr<URetargetChainSettings>> GetAllChainSettings() const { return ChainSettings; };
	/** Get access to the root settings */
	URetargetRootSettings* GetRetargetRootSettings() const { return RootSettings; };
	/** Get read-only access to a retarget pose */
	const FIKRetargetPose* GetCurrentRetargetPose() const { return &RetargetPoses[CurrentRetargetPose]; };
	/* Get name of default pose */
	static const FName GetDefaultPoseName();

	/** UObject */
	virtual void Serialize(FArchive& Ar) override;
	virtual void PostLoad() override;
	/** END UObject */

#if WITH_EDITOR
	/* Get name of Source IK Rig property */
	static const FName GetSourceIKRigPropertyName();
	/* Get name of Target IK Rig property */
	static const FName GetTargetIKRigPropertyName();
	/* Get name of Source Preview Mesh property */
	static const FName GetSourcePreviewMeshPropertyName();
	/* Get name of Target Preview Mesh property */
	static const FName GetTargetPreviewMeshPropertyName();
	/** Get the names of the all the speed curves the retargeter will be looking for */
	void GetSpeedCurveNames(TArray<FName>& OutSpeedCurveNames) const;
#endif

#if WITH_EDITOR
	ERetargeterOutputMode GetOutputMode() const { return bOutputMode; }
	void SetOutputMode(const ERetargeterOutputMode InMode) { bOutputMode = InMode; }
#endif

private:

	/** The rig to copy animation FROM.*/
	UPROPERTY(EditAnywhere, Category = Source)
	TSoftObjectPtr<UIKRigDefinition> SourceIKRigAsset = nullptr;

#if WITH_EDITORONLY_DATA
	/** Optional. Override the Skeletal Mesh to copy animation from. Uses the preview mesh from the Source IK Rig asset by default. */
	UPROPERTY(EditAnywhere, Category = Source)
	TSoftObjectPtr<USkeletalMesh> SourcePreviewMesh = nullptr;
#endif
	
	/** The rig to copy animation TO.*/
	UPROPERTY(EditAnywhere, Category = Target)
	TSoftObjectPtr<UIKRigDefinition> TargetIKRigAsset = nullptr;

#if WITH_EDITORONLY_DATA
	/** Optional. Override the Skeletal Mesh to preview the retarget on. Uses the preview mesh from the Target IK Rig asset by default. */
	UPROPERTY(EditAnywhere, Category = Target)
	TSoftObjectPtr<USkeletalMesh> TargetPreviewMesh = nullptr;
#endif

	/** the retarget root settings */
	UPROPERTY()
	TObjectPtr<URetargetRootSettings> RootSettings;
	
public:
	
	/** When false, translational motion of skeleton root is not copied. Useful for debugging.*/
	UPROPERTY(EditAnywhere, Category = RetargetPhases)
	bool bRetargetRoot = true;
	
	/** When false, limbs are not copied via FK. Useful for debugging limb issues suspected to be caused by FK pose.*/
	UPROPERTY(EditAnywhere, Category = RetargetPhases)
	bool bRetargetFK = true;
	
	/** When false, IK is not applied as part of retargeter. Useful for debugging limb issues suspected to be caused by IK.*/
	UPROPERTY(EditAnywhere, Category = RetargetPhases)
	bool bRetargetIK = true;

#if WITH_EDITORONLY_DATA
	UPROPERTY()
	float TargetActorOffset_DEPRECATED = 0.0f;
	UPROPERTY()
	float TargetActorScale_DEPRECATED = 0.0f;

	/** The offset applied to the target mesh in the editor viewport. */
	UPROPERTY(EditAnywhere, Category = PreviewSettings)
	FVector TargetMeshOffset;

	/** Scale the target mesh in the viewport for easier visualization next to the source.*/
	UPROPERTY(EditAnywhere, Category = PreviewSettings, meta = (UIMin = "0.01", UIMax = "10.0"))
	float TargetMeshScale = 1.0f;

	/** The offset applied to the source mesh in the editor viewport. */
	UPROPERTY(EditAnywhere, Category = PreviewSettings)
	FVector SourceMeshOffset;

	/** The visual size of the bones in the viewport (saved between sessions). This is set from the viewport Character>Bones menu*/
	UPROPERTY()
	float BoneDrawSize = 8.0f;
	
private:
	/** A special editor-only mode which forces the retargeter to output the current retarget reference pose,
	* rather than actually running the retarget and outputting the retargeted pose. Used in Edit-Pose mode.*/
	ERetargeterOutputMode bOutputMode;

	/** The controller responsible for managing this asset's data (all editor mutation goes through this) */
	UPROPERTY(Transient)
	TObjectPtr<UObject> Controller;
#endif
	
private:
	/** The set of retarget poses available as options for retargeting.*/
	UPROPERTY()
	TMap<FName, FIKRetargetPose> RetargetPoses;

	/** (OLD VERSION) Mapping of chains to copy animation between source and target rigs.*/
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	UPROPERTY()
	TArray<FRetargetChainMap> ChainMapping_DEPRECATED;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
	
	/** Settings for how to map source chains to target chains.*/
	UPROPERTY()
	TArray<TObjectPtr<URetargetChainSettings>> ChainSettings;
	
	/** The set of retarget poses available as options for retargeting.*/
	UPROPERTY()
	FName CurrentRetargetPose;

	friend class UIKRetargeterController;
};
