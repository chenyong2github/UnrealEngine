// Copyright Epic Games, Inc. All Rights Reserved.

#include "USDClassesModule.h"

#include "USDLog.h"

#include "HAL/FileManager.h"
#include "Misc/FileHelper.h"
#include "Misc/Paths.h"
#include "Modules/ModuleManager.h"
#include "Serialization/JsonSerializer.h"

DEFINE_LOG_CATEGORY( LogUsd );

namespace UE
{
	namespace USDClasses
	{
		namespace Private
		{
			TSharedPtr<FJsonObject> ParseJSON( const FString& FileContents )
			{
				if ( FileContents.IsEmpty() )
				{
					return nullptr;
				}

				const TSharedRef< TJsonReader<> >& Reader = TJsonReaderFactory<>::Create( FileContents );

				TSharedPtr<FJsonObject> DescriptorObject;
				if ( FJsonSerializer::Deserialize( Reader, DescriptorObject ) && DescriptorObject.IsValid() )
				{
					return DescriptorObject;
				}
				else
				{
					UE_LOG( LogUsd, Warning, TEXT( "Failed to parse plugInfo.json file: '%s'" ), *Reader->GetErrorMessage() );
				}

				return nullptr;
			}
		}
	}
}

void IUsdClassesModule::UpdatePlugInfoFiles( const FString& PluginDirectory, const FString& TargetDllFolder )
{
	// Traverse all USD plugins
	TArray<FString> JsonPaths;
	const bool bFiles = true;
	const bool bDirectories = false;
	const bool bClearFileNames = false;  // Whether it needs to reset the output array or not
	IFileManager::Get().FindFilesRecursive( JsonPaths, *PluginDirectory, TEXT( "plugInfo.json" ), bFiles, bDirectories, bClearFileNames );
	for ( const FString& JsonFilePath : JsonPaths )
	{
		FString FileContent;
		if ( !FFileHelper::LoadFileToString( FileContent, *JsonFilePath ) )
		{
			continue;
		}

		// Strip a preamble that looks like this:
		//		# Portions of this file auto-generated by usdGenSchema.
		//		# Edits will survive regeneration except for comments and
		//		# changes to types with autoGenerated=true.
		// We will not save this preamble back into the file, but that's not bad as the file is already in the binaries folder
		// and the preamble is actually invalid json anyway
		int32 FirstOpenBracketPos = FileContent.Find( TEXT( "{" ) );
		int32 NewLen = FileContent.Len() - FirstOpenBracketPos;
		FileContent.RightInline( NewLen );

		TSharedPtr<FJsonObject> DescriptorObject = UE::USDClasses::Private::ParseJSON( FileContent );
		if ( !DescriptorObject.IsValid() )
		{
			continue;
		}

		TSharedPtr<FJsonValue> PluginsField = DescriptorObject->TryGetField( TEXT( "Plugins" ) );
		if ( !PluginsField.IsValid() )
		{
			continue;
		}

		bool bUpdatedFile = false;

		const TArray< TSharedPtr<FJsonValue> >* PluginEntriesPtr = nullptr;
		if ( !PluginsField->TryGetArray( PluginEntriesPtr ) || !PluginEntriesPtr )
		{
			continue;
		}

		for ( const TSharedPtr<FJsonValue>& PluginEntry : *PluginEntriesPtr )
		{
			const TSharedPtr<FJsonObject>* PluginEntryObjectPtr = nullptr;
			if ( !PluginEntry->TryGetObject( PluginEntryObjectPtr ) || !PluginEntryObjectPtr || !PluginEntryObjectPtr->IsValid() )
			{
				continue;
			}

			TSharedPtr<FJsonValue> LibraryPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "LibraryPath" ) );
			if ( !LibraryPathField.IsValid() )
			{
				continue;
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString LibraryPath;
			if ( !LibraryPathField->TryGetString( LibraryPath ) )
			{
				continue;
			}

			// e.g. "sdf.dll"
			FString DllName = FPaths::GetCleanFilename( LibraryPath );
			if ( DllName.IsEmpty() )
			{
				continue;
			}

			// e.g. ".."
			FString RootPath;
			if ( TSharedPtr<FJsonValue> RootPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "Root" ) ) )
			{
				RootPathField->TryGetString( RootPath );
			}

			// e.g. "E:/Folder/Workspace/Engine/Binaries/ThirdParty/USD/UsdResources/Win64/plugins/ar/resources/.."
			RootPath = FPaths::Combine( FPaths::GetPath( JsonFilePath ), RootPath );
			FPaths::NormalizeDirectoryName( RootPath );
			FPaths::CollapseRelativeDirectories( RootPath );

			FString PathToDll = TargetDllFolder;

			// Ensure directories end with a slash, otherwise FPaths::MakePathRelativeTo may strip the last folder thinking it's a filename
			if ( !PathToDll.EndsWith( TEXT( "/" ) ) )
			{
				PathToDll.AppendChar( TEXT( '/' ) );
			}
			if ( !RootPath.EndsWith( TEXT( "/" ) ) )
			{
				RootPath.AppendChar( TEXT( '/' ) );
			}

			// e.g. "../../../../../../Win64"
			// This can fail if we're in different drives. Then we're forced to assume that CurrentDllLocation is an absolute path and use it directly
			if ( !FPaths::MakePathRelativeTo( PathToDll, *RootPath ) )
			{
				if ( FPaths::IsRelative( PathToDll ) && !FPaths::DirectoryExists( PathToDll ) )
				{
					UE_LOG( LogUsd, Warning, TEXT( "Failed to handle Current DLL Location '%s' when trying to update plugInfo.json paths" ), *PathToDll );
					continue;
				}
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString NewLibraryPath = FPaths::Combine( PathToDll, DllName );
			( *PluginEntryObjectPtr )->SetField( TEXT( "LibraryPath" ), MakeShared<FJsonValueString>( NewLibraryPath ) );
			bUpdatedFile = true;
		}

		// Serialize them back to JSON if we changed anything
		if ( bUpdatedFile )
		{
			FString OutputString;
			TSharedRef< TJsonWriter<> > Writer = TJsonWriterFactory<>::Create( &OutputString );
			FJsonSerializer::Serialize( DescriptorObject.ToSharedRef(), Writer );

			if ( FFileHelper::SaveStringToFile( OutputString, *JsonFilePath, FFileHelper::EEncodingOptions::AutoDetect, &IFileManager::Get(), FILEWRITE_EvenIfReadOnly ) )
			{
				UE_LOG( LogUsd, Log, TEXT( "Updated LibraryPaths for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
			else
			{
				UE_LOG( LogUsd, Warning, TEXT( "Failed to update LibraryPath for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
		}
	}
}

class FUsdClassesModule : public IUsdClassesModule
{
};

IMPLEMENT_MODULE( FUsdClassesModule, USDClasses );

