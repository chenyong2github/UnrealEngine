// Copyright Epic Games, Inc. All Rights Reserved.

#include "NiagaraNodeFunctionCall.h"

#include "AssetRegistryModule.h"
#include "EdGraphSchema_Niagara.h"
#include "NiagaraComponent.h"
#include "NiagaraConstants.h"
#include "NiagaraCustomVersion.h"
#include "NiagaraDataInterfaceSkeletalMesh.h"
#include "NiagaraEditorUtilities.h"
#include "NiagaraGraph.h"
#include "NiagaraHlslTranslator.h"
#include "NiagaraMessages.h"
#include "NiagaraNodeInput.h"
#include "NiagaraNodeOutput.h"
#include "NiagaraNodeParameterMapGet.h"
#include "NiagaraNodeParameterMapSet.h"
#include "NiagaraScript.h"
#include "NiagaraScriptSource.h"
#include "NiagaraScriptVariable.h"
#include "SNiagaraGraphNodeFunctionCallWithSpecifiers.h"
#include "Misc/SecureHash.h"
#include "Modules/ModuleManager.h"
#include "UObject/UnrealType.h"
#include "ViewModels/Stack/NiagaraParameterHandle.h"
#include "ViewModels/Stack/NiagaraStackGraphUtilities.h"
#include "NiagaraNodeStaticSwitch.h"
#include "ScopedTransaction.h"


#define LOCTEXT_NAMESPACE "NiagaraNodeFunctionCall"

void UNiagaraNodeFunctionCall::PostLoad()
{
	Super::PostLoad();

	if (FunctionScript)
	{
		const int32 NiagaraCustomVersion = GetLinkerCustomVersion(FNiagaraCustomVersion::GUID);
		FunctionScript->ConditionalPostLoad();
		if (NiagaraCustomVersion < FNiagaraCustomVersion::ModuleVersioning)
		{
			SelectedScriptVersion = FGuid();
			InvalidScriptVersionReference = FGuid();
			PreviousScriptVersion = FGuid();
		}
		FixupFunctionScriptVersion();

		// We need to make sure that the variables that could potentially be used in AllocateDefaultPins have been properly
		// loaded. Otherwise, we could be out of date.
		UNiagaraScriptSource* Source = GetFunctionScriptSource();
		if (Source)
		{
			Source->ConditionalPostLoad();
			UNiagaraGraph* Graph = Source->NodeGraph;
			Graph->ConditionalPostLoad();

			// Fix up autogenerated default values if necessary.
			if (NiagaraCustomVersion < FNiagaraCustomVersion::EnabledAutogeneratedDefaultValuesForFunctionCallNodes)
			{
				FPinCollectorArray InputPins;
				GetInputPins(InputPins);

				TArray<UNiagaraNodeInput*> InputNodes;
				UNiagaraGraph::FFindInputNodeOptions Options;
				Options.bSort = true;
				Options.bFilterDuplicates = true;
				Graph->FindInputNodes(InputNodes, Options);

				for (UEdGraphPin* InputPin : InputPins)
				{
					auto FindInputNodeByName = [&](UNiagaraNodeInput* InputNode) { return InputNode->Input.GetName().ToString() == InputPin->PinName.ToString(); };
					UNiagaraNodeInput** MatchingInputNodePtr = InputNodes.FindByPredicate(FindInputNodeByName);
					if (MatchingInputNodePtr != nullptr)
					{
						UNiagaraNodeInput* MatchingInputNode = *MatchingInputNodePtr;
						SetPinAutoGeneratedDefaultValue(*InputPin, *MatchingInputNode);

						// If the default value wasn't set, update it with the new autogenerated default.
						if (InputPin->DefaultValue.IsEmpty())
						{
							InputPin->DefaultValue = InputPin->AutogeneratedDefaultValue;
						}
					}
				}
			}
		}
	}

	// Allow data interfaces an opportunity to intercept changes
	if (Signature.IsValid() && Signature.bMemberFunction)
	{
		if ((Signature.Inputs.Num() > 0) && Signature.Inputs[0].GetType().IsDataInterface())
		{
			UNiagaraDataInterface* CDO = CastChecked<UNiagaraDataInterface>(Signature.Inputs[0].GetType().GetClass()->GetDefaultObject());
			if (CDO->UpgradeFunctionCall(Signature))
			{
				FunctionDisplayName.Empty();
				ReallocatePins();
			}
		}
	}

	UpdatePinTooltips();

	// Clean up invalid old references to propagated parameters
	CleanupPropagatedSwitchValues();
	
	if (FunctionDisplayName.IsEmpty())
	{
		ComputeNodeName();
	}
	
	// check if maybe the parameter names in the referenced module were changed and try to move over existing values
	FixupPinNames();
}

void UNiagaraNodeFunctionCall::UpgradeDIFunctionCalls()
{
	// We no longer use this upgrade path, but leaving here for convience in case we need to use this route again for other things
#if 0
	UClass* InterfaceClass = nullptr;
	UNiagaraDataInterface* InterfaceCDO = nullptr;
	if (Signature.IsValid() && FunctionScript == nullptr)
	{
		if (Signature.Inputs.Num() > 0)
		{
			if (Signature.Inputs[0].GetType().IsDataInterface())
			{
				InterfaceClass = Signature.Inputs[0].GetType().GetClass();
				InterfaceCDO = Cast<UNiagaraDataInterface>(InterfaceClass->GetDefaultObject());
			}
		}
	}

	FString UpgradeNote;
	if (!UpgradeNote.IsEmpty())
	{
		UE_LOG(LogNiagaraEditor, Log, TEXT("Upgradeing Niagara Data Interface fuction call node. This may cause unnessessary recompiles. Please resave these assets if this occurs. Or use fx.UpgradeAllNiagaraAssets."));
		UE_LOG(LogNiagaraEditor, Log, TEXT("Node: %s"), *GetFullName());
		if (InterfaceCDO)
		{
			UE_LOG(LogNiagaraEditor, Log, TEXT("Interface: %s"), *InterfaceCDO->GetFullName());
		}
		UE_LOG(LogNiagaraEditor, Log, TEXT("Function: %s"), *Signature.GetName());
		UE_LOG(LogNiagaraEditor, Log, TEXT("Upgrade Note: %s"),* UpgradeNote);
	}
#endif
}

TSharedPtr<SGraphNode> UNiagaraNodeFunctionCall::CreateVisualWidget()
{
	if (!FunctionScript && FunctionSpecifiers.Num() == 0)
	{
		FunctionSpecifiers = Signature.FunctionSpecifiers;
	}
	if (FunctionSpecifiers.Num() == 0)
	{
		return Super::CreateVisualWidget();
	}
	else
	{
		return SNew(SNiagaraGraphNodeFunctionCallWithSpecifiers, this);
	}
}

void UNiagaraNodeFunctionCall::AddCustomNote(const FNiagaraStackMessage& StackMessage)
{
	StackMessages.Add(StackMessage);
    OnCustomNotesChangedDelegate.ExecuteIfBound();
    GetNiagaraGraph()->NotifyGraphChanged();
}

void UNiagaraNodeFunctionCall::RemoveCustomNote(const FGuid& MessageKey)
{
	StackMessages.RemoveAll([&](const FNiagaraStackMessage& Message)
	{
		return Message.Guid == MessageKey;
	});
		
	OnCustomNotesChangedDelegate.ExecuteIfBound();
	GetNiagaraGraph()->NotifyGraphChanged();
}

void UNiagaraNodeFunctionCall::RemoveCustomNoteViaDelegate(const FGuid MessageKey)
{
	const bool bContainsMessage = StackMessages.ContainsByPredicate([&](const FNiagaraStackMessage& Message)
	{
		return Message.Guid == MessageKey;
	});

	if(bContainsMessage)
	{
		FScopedTransaction Transaction(LOCTEXT("NoteRemoved", "Note Removed"));
		Modify();
			
		RemoveCustomNote(MessageKey);
	}
}

void UNiagaraNodeFunctionCall::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	if (PropertyChangedEvent.Property != nullptr)
	{
		ReallocatePins();
	}
	Super::PostEditChangeProperty(PropertyChangedEvent);

	MarkNodeRequiresSynchronization(__FUNCTION__, true);
	//GetGraph()->NotifyGraphChanged();
}

void UNiagaraNodeFunctionCall::AllocateDefaultPins()
{
	if (FunctionScriptAssetObjectPath != NAME_None && FunctionScript == nullptr)
	{
		FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
		FAssetData ScriptAssetData = AssetRegistryModule.Get().GetAssetByObjectPath(FunctionScriptAssetObjectPath);
		if (ScriptAssetData.IsValid())
		{
			FunctionScript = Cast<UNiagaraScript>(ScriptAssetData.GetAsset());
			if (FunctionScript && FunctionScript->IsVersioningEnabled())
			{
				SelectedScriptVersion = FunctionScript->GetExposedVersion().VersionGuid;
			}
		}
	}

	const UEdGraphSchema_Niagara* Schema = CastChecked<UEdGraphSchema_Niagara>(GetSchema());
	if (FunctionScript)
	{
		UNiagaraScriptSource* Source = GetFunctionScriptSource();
		UNiagaraGraph* Graph = Source->NodeGraph;

		//These pins must be refreshed and kept in the correct order for the function
		TArray<FNiagaraVariable> Inputs;
		TArray<FNiagaraVariable> Outputs;
		Graph->GetParameters(Inputs, Outputs);

		TArray<UNiagaraNodeInput*> InputNodes;
		UNiagaraGraph::FFindInputNodeOptions Options;
		Options.bSort = true;
		Options.bFilterDuplicates = true;
		Graph->FindInputNodes(InputNodes, Options);

		AdvancedPinDisplay = ENodeAdvancedPins::NoPins;
		for (UNiagaraNodeInput* InputNode : InputNodes)
		{
			if (InputNode->IsExposed())
			{
				UEdGraphPin* NewPin = CreatePin(EGPD_Input, Schema->TypeDefinitionToPinType(InputNode->Input.GetType()), InputNode->Input.GetName());
					
				//An inline pin default only makes sense if we are required. 
				//Non exposed or optional inputs will used their own function input nodes defaults when not directly provided by a link.
				//Special class types cannot have an inline default.
 				NewPin->bDefaultValueIsIgnored = !(InputNode->IsRequired() && InputNode->Input.GetType().GetClass() == nullptr);

				SetPinAutoGeneratedDefaultValue(*NewPin, *InputNode);
				NewPin->DefaultValue = NewPin->AutogeneratedDefaultValue;

				//TODO: Some visual indication of Auto bound pins.
				//I tried just linking to null but
// 				FNiagaraVariable AutoBoundVar;
// 				ENiagaraInputNodeUsage AutBoundUsage = ENiagaraInputNodeUsage::Undefined;
// 				bool bCanAutoBind = FindAutoBoundInput(InputNode->AutoBindOptions, NewPin, AutoBoundVar, AutBoundUsage);
// 				if (bCanAutoBind)
// 				{
// 
// 				}

				if (InputNode->IsHidden())
				{
					NewPin->bAdvancedView = true;
					AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
				}
				else
				{
					NewPin->bAdvancedView = false;
				}
			}
		}

		TArray<FNiagaraVariable> SwitchNodeInputs = Graph->FindStaticSwitchInputs();
		for (FNiagaraVariable& Input : SwitchNodeInputs)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Input, Schema->TypeDefinitionToPinType(Input.GetType()), Input.GetName());
			NewPin->bNotConnectable = true;
			NewPin->bDefaultValueIsIgnored = FindPropagatedVariable(Input) != nullptr;
			
			FString PinDefaultValue;
			UNiagaraScriptVariable* ScriptVar = Graph->GetScriptVariable(Input);
			if (ScriptVar)
			{
				int32 DefaultValue = ScriptVar->GetStaticSwitchDefaultValue();
				Input.AllocateData();
				Input.SetValue<FNiagaraInt32>({ DefaultValue });
				
				if (Schema->TryGetPinDefaultValueFromNiagaraVariable(Input, PinDefaultValue))
				{
					NewPin->DefaultValue = PinDefaultValue;
				}
			}
			else
			{
				if (Schema->TryGetPinDefaultValueFromNiagaraVariable(Input, PinDefaultValue))
				{
					NewPin->DefaultValue = PinDefaultValue;
				}
			}
		}

		for (FNiagaraVariable& Output : Outputs)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Output, Schema->TypeDefinitionToPinType(Output.GetType()), Output.GetName());
			NewPin->bDefaultValueIsIgnored = true;
		}

		// Make sure to note that we've synchronized with the external version.
		CachedChangeId = Graph->GetChangeID();
	}
	else
	{
		if (Signature.bRequiresExecPin)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Input, Schema->TypeDefinitionToPinType(FNiagaraTypeDefinition::GetParameterMapDef()), TEXT(""));
			NewPin->bDefaultValueIsIgnored = true;
		}
		
		for (FNiagaraVariable& Input : Signature.Inputs)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Input, Schema->TypeDefinitionToPinType(Input.GetType()), Input.GetName());
			NewPin->bDefaultValueIsIgnored = false;
			NewPin->PinToolTip = Signature.InputDescriptions.Contains(Input) ? Signature.InputDescriptions[Input].ToString() : FString();
			FString PinDefaultValue;
			if (Schema->TryGetPinDefaultValueFromNiagaraVariable(Input, PinDefaultValue))
			{
				NewPin->AutogeneratedDefaultValue = PinDefaultValue;
				NewPin->DefaultValue = PinDefaultValue;
			}
		}

		if (Signature.bRequiresExecPin)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Output, Schema->TypeDefinitionToPinType(FNiagaraTypeDefinition::GetParameterMapDef()), TEXT(""));
			NewPin->bDefaultValueIsIgnored = true;
		}

		for (FNiagaraVariable& Output : Signature.Outputs)
		{
			UEdGraphPin* NewPin = CreatePin(EGPD_Output, Schema->TypeDefinitionToPinType(Output.GetType()), Output.GetName());
			NewPin->bDefaultValueIsIgnored = true;
			NewPin->PinToolTip = Signature.OutputDescriptions.Contains(Output) ? Signature.OutputDescriptions[Output].ToString() : FString();
		}

		if (AllowDynamicPins())
		{
			CreateAddPin(EGPD_Input);
			CreateAddPin(EGPD_Output);
		}

		// We don't reference an external function, so set an invalid id.
		CachedChangeId = FGuid();
	}

	if (FunctionDisplayName.IsEmpty())
	{
		ComputeNodeName();
	}

	UpdateNodeErrorMessage();
}

// Returns true if this node is deprecated
bool UNiagaraNodeFunctionCall::IsDeprecated() const
{
	FVersionedNiagaraScriptData* ScriptData = GetScriptData();
	if (ScriptData)
	{
		return ScriptData->bDeprecated;
	}
	return false;
}

bool UNiagaraNodeFunctionCall::FixupPinNames()
{
	// This checks the override pins to see if any of the inputs were renamed since we last checked.
	// Note that this does *not* fix inputs set via rapid iteration parameters, they are fixed by UNiagaraScriptSource::UpdateRenamedParameters.
	if (UNiagaraNodeParameterMapSet* OverrideNode = FNiagaraStackGraphUtilities::GetStackFunctionOverrideNode(*this))
	{
		FixupFunctionScriptVersion();
		UNiagaraGraph* Graph = GetCalledGraph();
		if (Graph == nullptr)
		{
			return false;
		}
		const UEdGraphSchema_Niagara* NiagaraSchema = Graph->GetNiagaraSchema();
		
		// find out which inputs the module offers
		TSet<const UEdGraphPin*> HiddenModulePins;
		TArray<const UEdGraphPin*> ModuleInputPins;
		FCompileConstantResolver ConstantResolver;
		GetStackFunctionInputPins(*this, ModuleInputPins, HiddenModulePins, ConstantResolver, FNiagaraStackGraphUtilities::ENiagaraGetStackFunctionInputPinsOptions::ModuleInputsOnly);
		TSet<FName> ModulePinNames;
		TMap<FGuid, FNiagaraVariable> ModuleInputGuidMapping;
		for (const UEdGraphPin* ModulePin : ModuleInputPins)
		{
			FName InputName = FNiagaraParameterHandle(ModulePin->PinName).GetName();
			FNiagaraVariable InputVar = NiagaraSchema->PinToNiagaraVariable(ModulePin);
			TOptional<FNiagaraVariableMetaData> VariableMetaData = Graph->GetMetaData(InputVar);
			if (VariableMetaData.IsSet()) // check if there is metadata with a guid available
			{
				ModuleInputGuidMapping.Add(VariableMetaData->GetVariableGuid(), InputVar);
				ModulePinNames.Add(InputName);
			}
		}

		// gather inputs that are overriden
		TArray<UEdGraphPin*> OverrideInputPins;
		TArray<UEdGraphPin*> LinkedModuleOutputs;
		OverrideNode->GetInputPins(OverrideInputPins);
		bool bNodeChanged = false;
		for (UEdGraphPin* OverridePin : OverrideInputPins)
		{
			if (OverridePin->Direction != EGPD_Input || !OverridePin->PinName.ToString().StartsWith(GetFunctionName()))
			{
				continue;
			}

			// Gather module output linked to our inputs
			if (UEdGraphPin* LinkedValuePin = FNiagaraStackGraphUtilities::GetLinkedValueHandleForFunctionInput(*OverridePin))
			{
				FNiagaraParameterHandle PinHandle(LinkedValuePin->PinName);
				FString LinkedToName = PinHandle.GetParameterHandleString().ToString();
				if (PinHandle.IsOutputHandle())
				{
					LinkedModuleOutputs.Add(LinkedValuePin);
				}
			}

			// check if the pin is still a valid input name from the module
			FNiagaraVariable InputVar = NiagaraSchema->PinToNiagaraVariable(OverridePin);
			FNiagaraParameterHandle CurrentPinHandle = FNiagaraParameterHandle(OverridePin->PinName);
			FName InputName = CurrentPinHandle.GetName();
			if (ModulePinNames.Contains(InputName))
			{
				// update the existing binding data
				for (auto Entry : ModuleInputGuidMapping)
				{
					FNiagaraParameterHandle ModuleInputName = FNiagaraParameterHandle(Entry.Value.GetName());
					if (ModuleInputName.GetName() == InputName && Entry.Value.GetType() == InputVar.GetType())
					{
						UpdateInputNameBinding(Entry.Key, InputName);
						break;
					}
				}
				continue;
			}

			// see if we can find a match with a previously set guid and name
			TArray<FGuid> PossibleGuidMatches = GetBoundPinGuidsByName(InputName);
			for (FGuid InputGuid : PossibleGuidMatches)
			{
				FNiagaraVariable* ModuleVar = ModuleInputGuidMapping.Find(InputGuid);
				if (ModuleVar && ModuleVar->GetType() == InputVar.GetType())
				{
					// found a match! Lets rename the pin
					FNiagaraParameterHandle CurrentVarName(ModuleVar->GetName());
					FNiagaraParameterHandle NewName(CurrentPinHandle.GetNamespace(), CurrentVarName.GetName());
					OverridePin->PinName = NewName.GetParameterHandleString();
					bNodeChanged = true;
					break;
				}
			}
		}

		// see if any of the linked inputs were renamed
		UNiagaraGraph* Owner = GetNiagaraGraph();
		TMap<FGuid, TArray<FNiagaraVariable>> GraphVariablesGuidMapping;
		if (Owner && LinkedModuleOutputs.Num() > 0)
		{
			// Search for guids of the linked inputs by looking backwards in the current script graph (not the graph this function node calls, but the one it's embedded in)
			TArray<UNiagaraNode*> NodesTraversed;
			UNiagaraGraph::BuildTraversal(NodesTraversed, this);
			for (UNiagaraNode* Node : NodesTraversed)
			{
				if (Node != this && Node->IsA<UNiagaraNodeFunctionCall>())
				{
					UNiagaraNodeFunctionCall* FunctionNode = CastChecked<UNiagaraNodeFunctionCall>(Node);
					FunctionNode->ConditionalPostLoad();
					UNiagaraGraph* CalledGraph = FunctionNode->GetCalledGraph();
					if (!CalledGraph)
					{
						continue;
					}
					const TMap<FNiagaraVariable, UNiagaraScriptVariable*>& MetaData = CalledGraph->GetAllMetaData();
					for (const auto& Entry : MetaData)
					{
						if (Entry.Value && Entry.Key.IsInNameSpace(FNiagaraConstants::OutputNamespace))
						{
							TArray<FName> HandleParts = FNiagaraParameterHandle(Entry.Key.GetName()).GetHandleParts();
							if (HandleParts.Num() >= 3 && HandleParts[1] == FNiagaraConstants::ModuleNamespace)
							{
								FString AliasedName = *FString::Printf(TEXT("%s.%s"), *FNiagaraConstants::OutputNamespace.ToString(), *FunctionNode->GetFunctionName());
								for (int i = 2; i < HandleParts.Num(); i++)
								{
									AliasedName.Appendf(TEXT(".%s"), *HandleParts[i].ToString());
								}
								FNiagaraVariable OutputVar = Entry.Key;
								OutputVar.SetName(FName(AliasedName));
								GraphVariablesGuidMapping.FindOrAdd(Entry.Value->Metadata.GetVariableGuid()).Add(OutputVar);
							}
						}
					}
				}
			}

			// Now compare the linked inputs with the guids and names we have
			for (UEdGraphPin* LinkedOutPin : LinkedModuleOutputs)
			{
				// See if we have a matching guid for this input
				bool bFoundMatch = false;
				TArray<FGuid> GuidMatches = GetBoundPinGuidsByName(LinkedOutPin->PinName);
				for (FGuid Guid : GuidMatches)
				{
					// see if the name still matches and rename the linked input if not
					TArray<FNiagaraVariable>* VarsFromGraph = GraphVariablesGuidMapping.Find(Guid);
					if (VarsFromGraph)
					{
						bFoundMatch = true;

						// there might be several modules in different version giving us the same guid for the output, so we check them all
						if (!VarsFromGraph->ContainsByPredicate([LinkedOutPin](const FNiagaraVariable& Var) { return LinkedOutPin->PinName == Var.GetName(); }))
						{
							FNiagaraParameterHandle PinHandle(LinkedOutPin->PinName);
							FNiagaraVariable* OriginalModuleVar = VarsFromGraph->FindByPredicate([PinHandle](const FNiagaraVariable& Var)
							{
								FNiagaraParameterHandle ModuleVarHandle(Var.GetName());
								return PinHandle.GetNamespace() == ModuleVarHandle.GetNamespace();
							});
							
							if (OriginalModuleVar)
							{
								// we found a reference from the original module namespace, so use that
								LinkedOutPin->PinName = OriginalModuleVar->GetName();
							}
							else
							{
								// seems like the module was lost or got replaced, so just use any one of the new handles
								LinkedOutPin->PinName = (*VarsFromGraph)[0].GetName();
							}
							
							bNodeChanged = true;
							UpdateInputNameBinding(Guid, LinkedOutPin->PinName);
							break;
						}
					}
				}

				// We have not found a match, see if we can still find a matching var to save the guid for upcoming renames
				if (!bFoundMatch)
				{
					FNiagaraVariable InputVariable = NiagaraSchema->PinToNiagaraVariable(LinkedOutPin);
					for (auto& Entry : GraphVariablesGuidMapping)
					{
						FNiagaraVariable* MatchingVar = Entry.Value.FindByPredicate([InputVariable](const FNiagaraVariable& Var){ return InputVariable == Var; });
						if (MatchingVar)
						{
							UpdateInputNameBinding(Entry.Key, LinkedOutPin->PinName);
						}
					}
				}
			}
		}
		
		return bNodeChanged;
	}
	return false;
}

void UNiagaraNodeFunctionCall::UpdateInputNameBinding(const FGuid& BoundVariableGuid, const FName& BoundName)
{
	if (!BoundVariableGuid.IsValid() || BoundName.IsNone())
	{
		return;
	}
	BoundPinNames.Add(BoundVariableGuid, BoundName);
}

FText UNiagaraNodeFunctionCall::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	FString DetectedName = FunctionScript ? FunctionScript->GetName() : Signature.GetName();
	if (DetectedName.IsEmpty())
	{
		return FText::FromString(TEXT("Missing ( Was\"") + FunctionDisplayName + TEXT("\")"));
	}
	else
	{
		return FText::FromString(FName::NameToDisplayString(FunctionDisplayName, false));
	}
}

FText UNiagaraNodeFunctionCall::GetTooltipText()const
{
	if (FunctionScript != nullptr)
	{
		return FunctionScript->GetDescription(SelectedScriptVersion);
	}
	else if (Signature.IsValid())
	{
		return Signature.Description;
	} 
	else
	{
		return LOCTEXT("NiagaraFuncCallUnknownSignatureTooltip", "Unknown function call");
	}
}

FLinearColor UNiagaraNodeFunctionCall::GetNodeTitleColor() const
{
	return UEdGraphSchema_Niagara::NodeTitleColor_FunctionCall;
}

bool UNiagaraNodeFunctionCall::CanAddToGraph(UNiagaraGraph* TargetGraph, FString& OutErrorMsg) const
{
	if (Super::CanAddToGraph(TargetGraph, OutErrorMsg) == false)
	{
		return false;
	}
	UPackage* TargetPackage = TargetGraph->GetOutermost();

	TArray<const UNiagaraGraph*> FunctionGraphs;
	UNiagaraScript* SpawningFunctionScript = FunctionScript;
	
	// We probably haven't loaded the script yet. Let's do so now so that we can trace its lineage.
	if (FunctionScriptAssetObjectPath != NAME_None && FunctionScript == nullptr)
	{
		FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
		FAssetData ScriptAssetData = AssetRegistryModule.Get().GetAssetByObjectPath(FunctionScriptAssetObjectPath);
		if (ScriptAssetData.IsValid())
		{
			SpawningFunctionScript = Cast<UNiagaraScript>(ScriptAssetData.GetAsset());
		}
	}

	// Now we need to get the graphs referenced by the script that we are about to spawn in.
	if (SpawningFunctionScript && SpawningFunctionScript->GetSource(SelectedScriptVersion))
	{
		UNiagaraScriptSource* Source = Cast<UNiagaraScriptSource>(SpawningFunctionScript->GetSource(SelectedScriptVersion));
		if (Source)
		{
			UNiagaraGraph* FunctionGraph = Source->NodeGraph;
			if (FunctionGraph)
			{
				FunctionGraph->GetAllReferencedGraphs(FunctionGraphs);
			}
		}
	}

	// Iterate over each graph referenced by this spawning function call and see if any of them reference the graph that we are about to be spawned into. If 
	// a match is found, then adding us would introduce a cycle and we need to abort the add.
	for (const UNiagaraGraph* Graph : FunctionGraphs)
	{
		UPackage* FunctionPackage = Graph->GetOutermost();
		if (FunctionPackage != nullptr && TargetPackage != nullptr && FunctionPackage == TargetPackage)
		{
			OutErrorMsg = LOCTEXT("NiagaraFuncCallCannotAddToGraph", "Cannot add to graph because the Function Call used by this node would lead to a cycle.").ToString();
			return false;
		}
	}

	return true;
}

UNiagaraGraph* UNiagaraNodeFunctionCall::GetCalledGraph() const
{
	if (FunctionScript)
	{
		if (UNiagaraScriptSource* Source = GetFunctionScriptSource())
		{
			UNiagaraGraph* FunctionGraph = Source->NodeGraph;
			return FunctionGraph;
		}
	}

	return nullptr;
}


ENiagaraScriptUsage UNiagaraNodeFunctionCall::GetCalledUsage() const
{
	if (FunctionScript)
	{
		return FunctionScript->GetUsage();
	}
	return ENiagaraScriptUsage::Function;
}

UNiagaraScriptSource* UNiagaraNodeFunctionCall::GetFunctionScriptSource() const
{
	if (FunctionScript == nullptr)
	{
		return nullptr;
	}
	UNiagaraScriptSourceBase* SourceBase = FunctionScript->GetSource(SelectedScriptVersion);
	return SourceBase ? CastChecked<UNiagaraScriptSource>(SourceBase) : nullptr;
}

FVersionedNiagaraScriptData* UNiagaraNodeFunctionCall::GetScriptData() const
{
	return FunctionScript ? FunctionScript->GetScriptData(SelectedScriptVersion) : nullptr;
}

static FText GetFormattedDeprecationMessage(const FVersionedNiagaraScriptData* ScriptData, const FString& FunctionDisplayName)
{
	FFormatNamedArguments Args;
	Args.Add(TEXT("NodeName"), FText::FromString(FunctionDisplayName));

	if (ScriptData->DeprecationRecommendation != nullptr)
	{
		Args.Add(TEXT("Recommendation"), FText::FromString(ScriptData->DeprecationRecommendation->GetPathName()));
	}

	if (ScriptData->DeprecationMessage.IsEmptyOrWhitespace() == false)
	{
		Args.Add(TEXT("Message"), ScriptData->DeprecationMessage);
	}

	FText FormatString = LOCTEXT("DeprecationErrorFmtUnknown", "Function call \"{NodeName}\" is deprecated. No recommendation was provided.");

	if (ScriptData->DeprecationRecommendation != nullptr && ScriptData->DeprecationMessage.IsEmptyOrWhitespace() == false)
	{
		FormatString = LOCTEXT("DeprecationErrorFmtMessageAndRecommendation", "Function call \"{NodeName}\" is deprecated. Reason:\n{Message}.\nPlease use {Recommendation} instead.");
	}
	else if (ScriptData->DeprecationRecommendation != nullptr)
	{
		FormatString = LOCTEXT("DeprecationErrorFmtRecommendation", "Function call \"{NodeName}\" is deprecated. Please use {Recommendation} instead.");
	}
	else if (ScriptData->DeprecationMessage.IsEmptyOrWhitespace() == false)
	{
		FormatString = LOCTEXT("DeprecationErrorFmtMessage", "Function call \"{NodeName}\" is deprecated. Reason:\n{Message} ");
	}

	return FText::Format(FormatString, Args);
}

void UNiagaraNodeFunctionCall::Compile(class FHlslNiagaraTranslator* Translator, TArray<int32>& Outputs)
{
	TArray<int32> Inputs;

	bool bError = false;

	const UEdGraphSchema_Niagara* Schema = CastChecked<UEdGraphSchema_Niagara>(GetSchema());
	UNiagaraGraph* CallerGraph = GetNiagaraGraph();
	FVersionedNiagaraScriptData* ScriptData = GetScriptData();
	if (ScriptData)
	{
		if (InvalidScriptVersionReference.IsValid())
		{
			FText WarningMessage = FText::Format(LOCTEXT("InvalidScriptVersionReferenceMessage", "Function call \"{0}\" references an invalid script version ({1}). Compiling with the exposed version as fallback, but please check the node and set a valid version."), FText::FromString(FunctionDisplayName), FText::FromString(InvalidScriptVersionReference.ToString()));
			Translator->Warning(WarningMessage, this, nullptr);
		}
		if (ScriptData->bDeprecated && IsNodeEnabled())
		{
			FText DeprecationMessage = GetFormattedDeprecationMessage(ScriptData, FunctionDisplayName);

			Translator->Warning(DeprecationMessage, this, nullptr);
		}
		
		FPinCollectorArray CallerInputPins;
		GetInputPins(CallerInputPins);
		
		UNiagaraScriptSource* Source = GetFunctionScriptSource();
		UNiagaraGraph* FunctionGraph = Source->NodeGraph;

		TArray<UNiagaraNodeInput*> FunctionInputNodes;
		UNiagaraGraph::FFindInputNodeOptions Options;
		Options.bSort = true;
		Options.bFilterDuplicates = true;
		FunctionGraph->FindInputNodes(FunctionInputNodes, Options);

		// We check which module inputs are not used so we can later remove them from the compilation of the
		// parameter map that sets the input values for our function. This is mainly done to prevent data interfaces being
		// initialized as parameter when they are not used in the function or module.
		TSet<FName> HiddenPinNames;
		for (UEdGraphPin* Pin : FNiagaraStackGraphUtilities::GetUnusedFunctionInputPins(*this, FCompileConstantResolver(Translator, DebugState)))
		{
			HiddenPinNames.Add(Pin->PinName);
		}
		Translator->EnterFunctionCallNode(HiddenPinNames);

		for (UNiagaraNodeInput* FunctionInputNode : FunctionInputNodes)
		{
			//Finds the matching Pin in the caller.
			UEdGraphPin** PinPtr = CallerInputPins.FindByPredicate([&](UEdGraphPin* InPin) { return Schema->PinToNiagaraVariable(InPin).IsEquivalent(FunctionInputNode->Input); });
			if (!PinPtr)
			{
				if (FunctionInputNode->IsExposed())
				{
					//Couldn't find the matching pin for an exposed input. Probably a stale function call node that needs to be refreshed.
					Translator->Error(LOCTEXT("StaleFunctionCallError", "Function call is stale and needs to be refreshed."), this, nullptr);
					bError = true;
				}
				else if (FunctionInputNode->ExposureOptions.bRequired == true)
				{
					// Not exposed, but required. This means we should just add as a constant.
					Inputs.Add(Translator->GetConstant(FunctionInputNode->Input));
					continue;
				}


				Inputs.Add(INDEX_NONE);
				continue;
			}

			UEdGraphPin* CallerPin = *PinPtr;
			UEdGraphPin* CallerLinkedTo = CallerPin->LinkedTo.Num() > 0 ? UNiagaraNode::TraceOutputPin(CallerPin->LinkedTo[0]) : nullptr;			
			FNiagaraVariable PinVar = Schema->PinToNiagaraVariable(CallerPin);
			if (!CallerLinkedTo)
			{
				//if (Translator->CanReadAttributes())
				{
					//Try to auto bind if we're not linked to by the caller.
					FNiagaraVariable AutoBoundVar;
					ENiagaraInputNodeUsage AutBoundUsage = ENiagaraInputNodeUsage::Undefined;
					if (FindAutoBoundInput(FunctionInputNode, CallerPin, AutoBoundVar, AutBoundUsage))
					{
						UNiagaraNodeInput* NewNode = NewObject<UNiagaraNodeInput>(CallerGraph);
						NewNode->Input = PinVar;
						NewNode->Usage = AutBoundUsage;
						NewNode->AllocateDefaultPins();
						CallerLinkedTo = NewNode->GetOutputPin(0);
						CallerPin->BreakAllPinLinks();
						CallerPin->MakeLinkTo(CallerLinkedTo);
					}
				}
			}

			if (CallerLinkedTo)
			{
				//Param is provided by the caller. Typical case.
				Inputs.Add(Translator->CompilePin(CallerPin));
				continue;
			}
			else
			{
				if (FunctionInputNode->IsRequired())
				{
					if (CallerPin->bDefaultValueIsIgnored)
					{
						//This pin can't use a default and it is required so flag an error.
						Translator->Error(FText::Format(LOCTEXT("RequiredInputUnboundErrorFmt", "Required input {0} was not bound and could not be automatically bound."), CallerPin->GetDisplayName()),
							this, CallerPin);
						bError = true;
						//We weren't linked to anything and we couldn't auto bind so tell the compiler this input isn't provided and it should use it's local default.
						Inputs.Add(INDEX_NONE);
					}
					else
					{
						//We also compile the pin anyway if it is required as we'll be attempting to use it's inline default.
						Inputs.Add(Translator->CompilePin(CallerPin));
					}
				}
				else
				{
					//We optional, weren't linked to anything and we couldn't auto bind so tell the compiler this input isn't provided and it should use it's local default.
					Inputs.Add(INDEX_NONE);
				}
			}
		}

		FCompileConstantResolver ConstantResolver(Translator, DebugState);
		FNiagaraEditorUtilities::SetStaticSwitchConstants(GetCalledGraph(), CallerInputPins, ConstantResolver);
		Translator->ExitFunctionCallNode();
	}
	else if (Signature.IsValid())
	{
		if (Signature.Inputs.Num() > 0)
		{
			if (Signature.Inputs[0].GetType().IsDataInterface() && GetValidateDataInterfaces())
			{
				UClass* DIClass = Signature.Inputs[0].GetType().GetClass();
				if (UNiagaraDataInterface* DataInterfaceCDO = Cast<UNiagaraDataInterface>(DIClass->GetDefaultObject()))
				{
					TArray<FText> ValidationErrors;
					DataInterfaceCDO->ValidateFunction(Signature, ValidationErrors);

					bError = ValidationErrors.Num() > 0;

					for (FText& ValidationError : ValidationErrors)
					{
						Translator->Error(ValidationError, this, nullptr);
					}

					if (bError)
					{
						return;
					}
				}
			}
		}
		Translator->EnterFunctionCallNode(TSet<FName>());
		Signature.FunctionSpecifiers = FunctionSpecifiers;
		bError = CompileInputPins(Translator, Inputs);
		Translator->ExitFunctionCallNode();
	}		
	else
	{
		Translator->Error(FText::Format(LOCTEXT("UnknownFunction", "Unknown Function Call! Missing Script or Data Interface Signature. Stack Name: {0}"), FText::FromString(GetFunctionName())), this, nullptr);
		bError = true;
	}

	if (!bError)
	{
		Translator->FunctionCall(this, Inputs, Outputs);
	}
}

UObject*  UNiagaraNodeFunctionCall::GetReferencedAsset() const
{
	if (FunctionScript && FunctionScript->GetOutermost() != GetOutermost())
	{
		return FunctionScript;
	}
	else
	{
		return nullptr;
	}
}

void UNiagaraNodeFunctionCall::UpdateNodeErrorMessage()
{
	FVersionedNiagaraScriptData* ScriptData = GetScriptData();
	if (ScriptData)
	{
		if (ScriptData->bDeprecated)
		{
			UEdGraphNode::bHasCompilerMessage = true;
			ErrorType = EMessageSeverity::Warning;
			
			UEdGraphNode::ErrorMsg = GetFormattedDeprecationMessage(ScriptData, FunctionDisplayName).ToString();
		}
		else if (ScriptData->bExperimental)
		{
			UEdGraphNode::bHasCompilerMessage = true;
			UEdGraphNode::ErrorType = EMessageSeverity::Info;

			if (ScriptData->ExperimentalMessage.IsEmptyOrWhitespace())
			{
				UEdGraphNode::NodeUpgradeMessage = LOCTEXT("FunctionExperimental", "This function is marked as experimental, use with care!");
			}
			else
			{
				FFormatNamedArguments Args;
				Args.Add(TEXT("Message"), ScriptData->ExperimentalMessage);
				UEdGraphNode::NodeUpgradeMessage = FText::Format(LOCTEXT("FunctionExperimentalReason", "This function is marked as experimental, reason:\n{Message}."), Args);
			}
		}
		else
		{
			UEdGraphNode::bHasCompilerMessage = false;
			UEdGraphNode::ErrorMsg = FString();
		}
	}
	else if (Signature.IsValid())
	{
		if (Signature.bSoftDeprecatedFunction)
		{
			UEdGraphNode::bHasCompilerMessage = true;
			UEdGraphNode::ErrorType = EMessageSeverity::Info;

			UEdGraphNode::NodeUpgradeMessage = LOCTEXT("FunctionDeprecatedSoftly", "There is a newer version of this function, consider switching over to it.");
		}
		else if (Signature.bExperimental)
		{
			UEdGraphNode::bHasCompilerMessage = true;
			UEdGraphNode::ErrorType = EMessageSeverity::Info;

			if (Signature.ExperimentalMessage.IsEmptyOrWhitespace())
			{
				UEdGraphNode::NodeUpgradeMessage = LOCTEXT("FunctionExperimental", "This function is marked as experimental, use with care!");
			}
			else
			{
				FFormatNamedArguments Args;
				Args.Add(TEXT("Message"), Signature.ExperimentalMessage);
				UEdGraphNode::NodeUpgradeMessage = FText::Format(LOCTEXT("FunctionExperimentalReason", "This function is marked as experimental, reason:\n{Message}."), Args);
			}
		}
	}
}

TArray<FGuid> UNiagaraNodeFunctionCall::GetBoundPinGuidsByName(FName InputName) const
{
	TArray<FGuid> Result;
	for (auto Entry : BoundPinNames)
	{
		if (Entry.Value == InputName)
		{
			Result.Add(Entry.Key);
		}
	}
	return Result;
}

void UNiagaraNodeFunctionCall::FixupFunctionScriptVersion()
{
	if (!FunctionScript)
	{
		return;
	}
	FunctionScript->CheckVersionDataAvailable();
	if (FunctionScript->IsVersioningEnabled())
	{
		if (!SelectedScriptVersion.IsValid())
		{
			// When we did not reference a versioned script before and do now, reference the first version (instead of the exposed version as new function calls do)
			SelectedScriptVersion = FunctionScript->GetAllAvailableVersions()[0].VersionGuid;
		}
		else if (!FunctionScript->GetAllAvailableVersions().ContainsByPredicate([this](const FNiagaraAssetVersion& Version) { return SelectedScriptVersion == Version.VersionGuid; }))
		{
			// The version we are referencing does not exist any more, maybe it was deleted.
			// So we fall back to the exposed version, but save the old guid to generate a warning.
			InvalidScriptVersionReference = SelectedScriptVersion;
			SelectedScriptVersion = FunctionScript->GetExposedVersion().VersionGuid;
		}
	}
	else
	{
		SelectedScriptVersion = FGuid();
		InvalidScriptVersionReference = FGuid();
		PreviousScriptVersion = FGuid();
	}
}

void UNiagaraNodeFunctionCall::UpdatePinTooltips()
{
	if (!Signature.IsValid())
	{
		return;
	}

	// if it's a DI function we grab the newest tooltips first
	if ((Signature.Inputs.Num() > 0) && Signature.Inputs[0].GetType().IsDataInterface())
	{
		UNiagaraDataInterface* CDO = CastChecked<UNiagaraDataInterface>(Signature.Inputs[0].GetType().GetClass()->GetDefaultObject());
		TArray<FNiagaraFunctionSignature> AllSignatures;
		CDO->GetFunctions(AllSignatures);
		for (const FNiagaraFunctionSignature& DISignature : AllSignatures)
		{
			if (Signature.Name != DISignature.Name)
			{
				continue;
			}
			Signature.Description = DISignature.Description;
			Signature.InputDescriptions = DISignature.InputDescriptions;
			Signature.OutputDescriptions = DISignature.OutputDescriptions;
		}
	}

	// update input pin tooltips
	TArray<UEdGraphPin*> InputPins;
	GetInputPins(InputPins);
	if (Signature.Inputs.Num() == InputPins.Num())
	{
		for (int i = 0; i < InputPins.Num(); i++)
		{
			FNiagaraVariable& Input = Signature.Inputs[i];
			InputPins[i]->PinToolTip = Signature.InputDescriptions.Contains(Input) ? Signature.InputDescriptions[Input].ToString() : FString();
		}
	}

	// update output pin tooltips
	TArray<UEdGraphPin*> OutputPins;
	GetOutputPins(OutputPins);
	if (Signature.Outputs.Num() == OutputPins.Num())
	{
		for (int i = 0; i < OutputPins.Num(); i++)
		{
			FNiagaraVariable& Output = Signature.Outputs[i];
			OutputPins[i]->PinToolTip = Signature.OutputDescriptions.Contains(Output) ? Signature.OutputDescriptions[Output].ToString() : FString();
		}
	}
}

void FixupLinkedOutputs(UNiagaraNode* StartNode)
{
	// This searches for function call nodes linked to this node via the graph and calls FixupPinNames on them so they can react to changes in this node's called graph
	TSet<UNiagaraNode*> SeenNodes;
	TArray<UNiagaraNode*> NodesToCheck;
	NodesToCheck.Add(StartNode);
	int LoopGuard = 0;
	while (NodesToCheck.Num() > 0)
	{
		UNiagaraNode* Node = NodesToCheck.Pop();
		if (SeenNodes.Contains(Node))
		{
			continue;
		}
		SeenNodes.Add(Node);

		if (UNiagaraNodeFunctionCall* FunctionNode = Cast<UNiagaraNodeFunctionCall>(Node))
		{
			FunctionNode->ConditionalPostLoad();
			FunctionNode->FixupPinNames();
		}
		
		for (UEdGraphPin* Pin : Node->GetAllPins())
		{
			if (Pin->Direction == EGPD_Output && Pin->LinkedTo.Num() > 0)
			{
				for (UEdGraphPin* LinkedPin : Pin->LinkedTo)
				{
					if (LinkedPin != nullptr)
					{
						UNiagaraNode* LinkedNode = Cast<UNiagaraNode>(LinkedPin->GetOwningNode());
						if (LinkedNode)
						{
							NodesToCheck.Add(LinkedNode);
						}
					}
				}
			}
		}

		LoopGuard++;
		if (!ensure(LoopGuard < 100000)) // Guard against loops in the graph or other bugs
		{
			return;
		}
	}
}

bool UNiagaraNodeFunctionCall::RefreshFromExternalChanges()
{
	bool bReload = false;
	if (FunctionScript)
	{
		FixupFunctionScriptVersion();
		UNiagaraScriptSource* Source = GetFunctionScriptSource();
		if (ensureMsgf(Source != nullptr, TEXT("No source found for FunctionScript %s in RefreshFromExternalChanges for %s"), *GetPathNameSafe(FunctionScript), *GetPathNameSafe(this)))
		{
			bReload = CachedChangeId != Source->NodeGraph->GetChangeID();
		}
	}
	else if (Signature.IsValid())
	{
		bReload = true;		
	}

	UpdateNodeErrorMessage();

	// Go over the static switch parameters to set their propagation status on the pins
	UNiagaraGraph* CalledGraph = GetCalledGraph();
	if (CalledGraph)
	{
		CleanupPropagatedSwitchValues();
		FPinCollectorArray InputPins;
		GetInputPins(InputPins);
		for (FNiagaraVariable InputVar : CalledGraph->FindStaticSwitchInputs())
		{
			for (UEdGraphPin* Pin : InputPins)
			{
				if (InputVar.GetName().IsEqual(Pin->GetFName()))
				{
					Pin->bDefaultValueIsIgnored = FindPropagatedVariable(InputVar) != nullptr;
					break;
				}
			}
		}
	}

	// check if one of our overriden input parameters was renamed 
	FixupPinNames();

	if (bReload)
	{
		// TODO - Leverage code in reallocate pins to determine if any pins have changed...
		ReallocatePins(false);
		FixupLinkedOutputs(this); // If our called graph changed we might need to update downstream function call nodes as well
		return true;
	}
	else
	{
		return false;
	}
}

void UNiagaraNodeFunctionCall::GatherExternalDependencyData(ENiagaraScriptUsage InMasterUsage, const FGuid& InMasterUsageId, TArray<FNiagaraCompileHash>& InReferencedCompileHashes, TArray<FString>& InReferencedObjs) const
{
	if (FunctionScript)
	{
		UNiagaraScriptSource* Source = GetFunctionScriptSource();
		UNiagaraGraph* FunctionGraph = CastChecked<UNiagaraGraph>(Source->NodeGraph);
		
		// We don't know which graph type we're referencing, so we try them all... may need to replace this with something faster in the future.
		if (FunctionGraph)
		{
			FunctionGraph->RebuildCachedCompileIds();
			for (int32 i = (int32)ENiagaraScriptUsage::Function; i <= (int32)ENiagaraScriptUsage::DynamicInput; i++)
			{
				FGuid FoundGuid = FunctionGraph->GetBaseId((ENiagaraScriptUsage)i, FGuid(0, 0, 0, 0));
				FNiagaraCompileHash FoundCompileHash = FunctionGraph->GetCompileDataHash((ENiagaraScriptUsage)i, FGuid(0, 0, 0, 0));
				if (FoundGuid.IsValid() && FoundCompileHash.IsValid())
				{
					InReferencedCompileHashes.Add(FoundCompileHash);
					InReferencedObjs.Add(FunctionGraph->GetPathName());
					FunctionGraph->GatherExternalDependencyData((ENiagaraScriptUsage)i, FGuid(0, 0, 0, 0), InReferencedCompileHashes, InReferencedObjs);
				}
			}
		}
	}
}

void UNiagaraNodeFunctionCall::UpdateCompileHashForNode(FSHA1& HashState) const
{
	Super::UpdateCompileHashForNode(HashState);
	HashState.UpdateWithString(*GetFunctionName(), GetFunctionName().Len());
}

bool UNiagaraNodeFunctionCall::ScriptIsValid() const
{
	if (FunctionScript != nullptr)
	{
		return true;
	}
	else if (Signature.IsValid())
	{
		return true;
	}
	return false;
}

void UNiagaraNodeFunctionCall::BuildParameterMapHistory(FNiagaraParameterMapHistoryBuilder& OutHistory, bool bRecursive /*= true*/, bool bFilterForCompilation /*= true*/) const
{
	const UEdGraphSchema_Niagara* Schema = CastChecked<UEdGraphSchema_Niagara>(GetSchema());
	const UEdGraphPin* ParamMapPin = GetInputPin(0);
	bool bHasParamMapPin = ParamMapPin && Schema->PinToTypeDefinition(ParamMapPin) == FNiagaraTypeDefinition::GetParameterMapDef();
	if (bHasParamMapPin && ParamMapPin->LinkedTo.Num() == 0)
	{
		// Looks like this function call is not yet hooked up. Skip it to prevent cascading errors in the compilation
		return;
	}
	
	Super::BuildParameterMapHistory(OutHistory, bRecursive, bFilterForCompilation);
	if (!IsNodeEnabled() && OutHistory.GetIgnoreDisabled())
	{
		RouteParameterMapAroundMe(OutHistory, bRecursive);
		return;
	}

	
	UNiagaraScriptSource* Source = GetFunctionScriptSource();
	if (Source)
	{
		UNiagaraGraph* FunctionGraph = CastChecked<UNiagaraGraph>(Source->NodeGraph);

		UNiagaraNodeOutput* OutputNode = FunctionGraph->FindOutputNode(ENiagaraScriptUsage::Function);
		if (OutputNode == nullptr)
		{
			OutputNode = FunctionGraph->FindOutputNode(ENiagaraScriptUsage::Module);
		}
		if (OutputNode == nullptr)
		{
			OutputNode = FunctionGraph->FindOutputNode(ENiagaraScriptUsage::DynamicInput);
		}

		FPinCollectorArray InputPins;
		GetInputPins(InputPins);

		FCompileConstantResolver FunctionResolver = OutHistory.ConstantResolver.WithDebugState(DebugState);
		if (OutHistory.HasCurrentUsageContext())
		{
			// if we traverse a full emitter graph the usage might change during the traversal, so we need to update the constant resolver
			FunctionResolver = FunctionResolver.WithUsage(OutHistory.GetCurrentUsageContext());
		}
		FNiagaraEditorUtilities::SetStaticSwitchConstants(FunctionGraph, InputPins, FunctionResolver);

		int32 ParamMapIdx = INDEX_NONE;
		uint32 NodeIdx = INDEX_NONE;
		
		if (bHasParamMapPin && bRecursive)
		{
			ParamMapIdx = OutHistory.TraceParameterMapOutputPin(UNiagaraNode::TraceOutputPin(GetInputPin(0)->LinkedTo[0]));
		}

		OutHistory.EnterFunction(GetFunctionName(), FunctionScript, FunctionGraph, this);
		if (ParamMapIdx != INDEX_NONE)
		{
			NodeIdx = OutHistory.BeginNodeVisitation(ParamMapIdx, this);
		}
		OutputNode->BuildParameterMapHistory(OutHistory, true, bFilterForCompilation);

		// Since we're about to lose the pin calling context, we finish up the function call parameter map pin wiring
		// here when we have the calling context and the child context still available to us...
		FPinCollectorArray OutputPins;
		GetOutputPins(OutputPins);

		TArray<TPair<UEdGraphPin*, int32>, TInlineAllocator<16> > MatchedPairs;

		// Find the matches of names and types of the sub-graph output pins and this function call nodes' outputs.
		for (UEdGraphPin* ChildOutputNodePin : OutputNode->GetAllPins())
		{
			FNiagaraVariable VarChild = Schema->PinToNiagaraVariable(ChildOutputNodePin);

			if (ChildOutputNodePin->LinkedTo.Num() > 0 && VarChild.GetType() == FNiagaraTypeDefinition::GetParameterMapDef())
			{
				for (int32 i = 0; i < OutputPins.Num(); i++)
				{
					FNiagaraVariable OutputVar = Schema->PinToNiagaraVariable(OutputPins[i]);
					if (OutputVar.IsEquivalent(VarChild))
					{
						TPair<UEdGraphPin*, int32> Pair;
						Pair.Key = OutputPins[i];
						Pair.Value = OutHistory.TraceParameterMapOutputPin(UNiagaraNode::TraceOutputPin(ChildOutputNodePin->LinkedTo[0]));
						MatchedPairs.Add(Pair);
					}
				}
			}
		}

		if (ParamMapIdx != INDEX_NONE)
		{
			OutHistory.EndNodeVisitation(ParamMapIdx, NodeIdx);
		}

		OutHistory.ExitFunction(GetFunctionName(), FunctionScript, this);

		for (int32 i = 0; i < MatchedPairs.Num(); i++)
		{
			OutHistory.RegisterParameterMapPin(MatchedPairs[i].Value, MatchedPairs[i].Key);
		}
	}
	else if (!ScriptIsValid() || Signature.bRequiresExecPin)
	{
		RouteParameterMapAroundMe(OutHistory, bRecursive);
	}
}

void UNiagaraNodeFunctionCall::ChangeScriptVersion(FGuid NewScriptVersion, const FNiagaraScriptVersionUpgradeContext& UpgradeContext, bool bShowNotesInStack)
{
	bool bPreviousVersionValid = !InvalidScriptVersionReference.IsValid();
	if (NewScriptVersion == SelectedScriptVersion && bPreviousVersionValid)
	{
		return;
	}
	Modify();

	PythonUpgradeScriptWarnings.Empty();
	if (bPreviousVersionValid && FunctionScript && !UpgradeContext.bSkipPythonScript)
	{
		// run python update scripts
		TArray<FVersionedNiagaraScriptData*> UpgradeVersionData;
		FVersionedNiagaraScriptData* PreviousData = FunctionScript->GetScriptData(SelectedScriptVersion);
		FVersionedNiagaraScriptData* NewData = FunctionScript->GetScriptData(NewScriptVersion);
		for (const FNiagaraAssetVersion& Version : FunctionScript->GetAllAvailableVersions())
		{
			if (PreviousData->Version <= Version && Version <= NewData->Version)
			{
				UpgradeVersionData.Add(FunctionScript->GetScriptData(Version.VersionGuid));
			}
		}
		FNiagaraEditorUtilities::RunPythonUpgradeScripts(this, UpgradeVersionData, UpgradeContext, PythonUpgradeScriptWarnings);
	}
	
	InvalidScriptVersionReference = FGuid();
	PreviousScriptVersion = bShowNotesInStack ? SelectedScriptVersion : NewScriptVersion;
	SelectedScriptVersion = NewScriptVersion;

	if (FunctionScript)
	{
		// Automatically remove old inputs so it does not show a bunch of warnings to the user
		TArray<FName> FunctionInputNames;
		FPinCollectorArray OverridePins;
		UNiagaraNodeParameterMapSet* OverrideNode = FNiagaraStackGraphUtilities::GetStackFunctionOverrideNode(*this);
		if (OverrideNode != nullptr)
		{
			OverrideNode->GetInputPins(OverridePins);
			
			TSet<const UEdGraphPin*> HiddenModulePins;
			TArray<const UEdGraphPin*> ModuleInputPins;
			GetStackFunctionInputPins(*this, ModuleInputPins, HiddenModulePins, UpgradeContext.ConstantResolver, FNiagaraStackGraphUtilities::ENiagaraGetStackFunctionInputPinsOptions::ModuleInputsOnly);
			for (const UEdGraphPin* InputPin : ModuleInputPins)
			{
				FunctionInputNames.Add(FNiagaraParameterHandle(InputPin->PinName).GetName());
			}
		}
		for (UEdGraphPin* OverridePin : OverridePins)
		{
			FName InputName = FNiagaraParameterHandle(OverridePin->PinName).GetName();
			if (FNiagaraStackGraphUtilities::IsOverridePinForFunction(*OverridePin, *this) && FunctionInputNames.Contains(InputName) == false)
			{
				TArray<TWeakObjectPtr<UNiagaraDataInterface>> RemovedDataObjects;
				FNiagaraStackGraphUtilities::RemoveNodesForStackFunctionInputOverridePin(*OverridePin, RemovedDataObjects);
				OverrideNode->RemovePin(OverridePin);
			}
		}
	}

	MarkNodeRequiresSynchronization(__FUNCTION__, true);
}

UEdGraphPin* UNiagaraNodeFunctionCall::FindParameterMapDefaultValuePin(const FName VariableName, ENiagaraScriptUsage InParentUsage, FCompileConstantResolver ConstantResolver) const
{
	if (FunctionScript)
	{
		UNiagaraScriptSource* ScriptSource = GetFunctionScriptSource();
		if (ScriptSource != nullptr && ScriptSource->NodeGraph != nullptr)
		{
			// Set the static switch values so we traverse the correct node paths
			TArray<UEdGraphPin*> InputPins;
			GetInputPins(InputPins);

			FNiagaraEditorUtilities::SetStaticSwitchConstants(ScriptSource->NodeGraph, InputPins, ConstantResolver.WithDebugState(DebugState));
			
			return ScriptSource->NodeGraph->FindParameterMapDefaultValuePin(VariableName, FunctionScript->GetUsage(), InParentUsage);
		}
	}
	return nullptr;
}

UEdGraphPin* UNiagaraNodeFunctionCall::FindStaticSwitchInputPin(const FName& VariableName) const
{
	UNiagaraGraph* CalledGraph = GetCalledGraph();
	if (CalledGraph == nullptr)
	{
		return nullptr;
	}
	FPinCollectorArray InputPins;
	GetInputPins(InputPins);
	for (FNiagaraVariable InputVar : CalledGraph->FindStaticSwitchInputs())
	{
		if (InputVar.GetName().IsEqual(VariableName))
		{			
			for (UEdGraphPin* Pin : InputPins)
			{
				if (VariableName.IsEqual(Pin->GetFName()))
				{
					return Pin;
				}
			}
		}
	}
	return nullptr;
}

bool UNiagaraNodeFunctionCall::ContainsDebugSwitch() const
{
	UNiagaraGraph* CalledGraph = GetCalledGraph();
	if (CalledGraph)
	{
		TArray<UNiagaraNodeStaticSwitch*> Switches;
		CalledGraph->GetNodesOfClass<UNiagaraNodeStaticSwitch>(Switches);
		for (const auto& Switch : Switches)
		{
			if (Switch->IsDebugSwitch())
			{
				return true;
			}
		}

		TArray<UNiagaraNodeFunctionCall*> FunctionCalls;
		CalledGraph->GetNodesOfClass<UNiagaraNodeFunctionCall>(FunctionCalls);
		for (const auto& Function : FunctionCalls)
		{
			if (Function->ContainsDebugSwitch())
			{
				return true;
			}
		}
	}
	return false;
}

void UNiagaraNodeFunctionCall::SuggestName(FString SuggestedName, bool bForceSuggestion)
{
	ComputeNodeName(SuggestedName, bForceSuggestion);
}

UNiagaraNodeFunctionCall::FOnInputsChanged& UNiagaraNodeFunctionCall::OnInputsChanged()
{
	return OnInputsChangedDelegate;
}

FNiagaraPropagatedVariable* UNiagaraNodeFunctionCall::FindPropagatedVariable(const FNiagaraVariable& Variable)
{
	for (FNiagaraPropagatedVariable& Propagated : PropagatedStaticSwitchParameters)
	{
		if (Propagated.SwitchParameter == Variable)
		{
			return &Propagated;
		}
	}
	return nullptr;
}

void UNiagaraNodeFunctionCall::RemovePropagatedVariable(const FNiagaraVariable& Variable)
{
	for (int i = 0; i < PropagatedStaticSwitchParameters.Num(); i++)
	{
		if (PropagatedStaticSwitchParameters[i].SwitchParameter == Variable)
		{
			PropagatedStaticSwitchParameters.RemoveAt(i);
			return;
		}
	}
}

ENiagaraNumericOutputTypeSelectionMode UNiagaraNodeFunctionCall::GetNumericOutputTypeSelectionMode() const
{
	if (GetScriptData())
	{
		return GetScriptData()->NumericOutputTypeSelectionMode;
	}	
	return ENiagaraNumericOutputTypeSelectionMode::None;
}

void UNiagaraNodeFunctionCall::AutowireNewNode(UEdGraphPin* FromPin)
{
	UNiagaraNode::AutowireNewNode(FromPin);
	ComputeNodeName();
}

void UNiagaraNodeFunctionCall::ComputeNodeName(FString SuggestedName, bool bForceSuggestion)
{
	FString FunctionName = FunctionScript ? FunctionScript->GetName() : Signature.GetName();
	FName ProposedName;
	if (SuggestedName.IsEmpty() == false)
	{ 
		// If we have a suggested name and and either there is no function name, or it is a permutation of the function name
		// it can be used as the proposed name.
		if (bForceSuggestion || FunctionName.IsEmpty() || SuggestedName == FunctionName || (SuggestedName.StartsWith(FunctionName) && SuggestedName.RightChop(FunctionName.Len()).IsNumeric()))
		{
			ProposedName = *SuggestedName;
		}
	}

	if(ProposedName == NAME_None)
	{
		const FString CurrentName = FunctionDisplayName;
		if (FunctionName.IsEmpty() == false)
		{
			ProposedName = *FunctionName;
		}
		else
		{
			ProposedName = *CurrentName;
		}
	}

	UNiagaraGraph* Graph = GetNiagaraGraph();
	TArray<UNiagaraNodeFunctionCall*> Nodes;
	Graph->GetNodesOfClass(Nodes);

	TSet<FName> Names;
	for (UNiagaraNodeFunctionCall* Node : Nodes)
	{
		CA_ASSUME(Node != nullptr);
		if (Node != this)
		{
			Names.Add(*Node->GetFunctionName());
		}
	}

	FString NewName = FNiagaraUtilities::GetUniqueName(ProposedName, Names).ToString();
	if (!FunctionDisplayName.Equals(NewName))
	{
		FunctionDisplayName = NewName;
	}
}

void UNiagaraNodeFunctionCall::SetPinAutoGeneratedDefaultValue(UEdGraphPin& FunctionInputPin, UNiagaraNodeInput& FunctionScriptInputNode)
{
	if (FunctionInputPin.bDefaultValueIsIgnored == false)
	{
		FPinCollectorArray InputPins;
		FunctionScriptInputNode.GetInputPins(InputPins);
		if (InputPins.Num() == 1 && InputPins[0]->bDefaultValueIsIgnored == false)
		{
			// If the function graph's input node had an input pin, and that pin's default wasn't ignored, use that value. 
			FunctionInputPin.AutogeneratedDefaultValue = InputPins[0]->DefaultValue;
		}
		else
		{
			const UEdGraphSchema_Niagara* Schema = CastChecked<UEdGraphSchema_Niagara>(GetSchema());
			FString PinDefaultValue;
			if (Schema->TryGetPinDefaultValueFromNiagaraVariable(FunctionScriptInputNode.Input, PinDefaultValue))
			{
				FunctionInputPin.AutogeneratedDefaultValue = PinDefaultValue;
			}
		}
	}
}

void UNiagaraNodeFunctionCall::CleanupPropagatedSwitchValues()
{
	for (int i = PropagatedStaticSwitchParameters.Num() - 1; i >= 0; i--)
	{
		FNiagaraPropagatedVariable& Propagated = PropagatedStaticSwitchParameters[i];
		if (Propagated.SwitchParameter.GetName().IsNone() || !IsValidPropagatedVariable(Propagated.SwitchParameter))
		{
			PropagatedStaticSwitchParameters.RemoveAt(i);
		}
	}
}

bool UNiagaraNodeFunctionCall::IsValidPropagatedVariable(const FNiagaraVariable& Variable) const
{
	UNiagaraGraph* Graph = GetCalledGraph();
	if (!Graph)
	{
		return false;
	}
	for (const FNiagaraVariable& Var : Graph->FindStaticSwitchInputs(false))
	{
		if (Var == Variable)
		{
			return true;
		}
	}
	return false;
}

bool UNiagaraNodeFunctionCall::FindAutoBoundInput(UNiagaraNodeInput* InputNode, UEdGraphPin* PinToAutoBind, FNiagaraVariable& OutFoundVar, ENiagaraInputNodeUsage& OutNodeUsage)
{
	check(InputNode && InputNode->IsExposed());
	if (PinToAutoBind->LinkedTo.Num() > 0 || !InputNode->CanAutoBind())
	{
		return false;
	}

	const UEdGraphSchema_Niagara* Schema = CastChecked<UEdGraphSchema_Niagara>(GetSchema());
	FNiagaraVariable PinVar = Schema->PinToNiagaraVariable(PinToAutoBind);

	//See if we can auto bind this pin to something in the caller script.
	UNiagaraGraph* CallerGraph = GetNiagaraGraph();
	check(CallerGraph);
	UNiagaraNodeOutput* CallerOutputNodeSpawn = CallerGraph->FindOutputNode(ENiagaraScriptUsage::ParticleSpawnScript);
	UNiagaraNodeOutput* CallerOutputNodeUpdate = CallerGraph->FindOutputNode(ENiagaraScriptUsage::ParticleUpdateScript);

	//First, let's see if we're an attribute of this emitter. Only valid if we're a module call off the primary script.
	if (CallerOutputNodeSpawn || CallerOutputNodeUpdate)
	{
		UNiagaraNodeOutput* CallerOutputNode = CallerOutputNodeSpawn != nullptr ? CallerOutputNodeSpawn : CallerOutputNodeUpdate;
		check(CallerOutputNode);
		{
			FNiagaraVariable* AttrVarPtr = CallerOutputNode->Outputs.FindByPredicate([&](const FNiagaraVariable& Attr) { return PinVar.IsEquivalent(Attr); });
			if (AttrVarPtr)
			{
				OutFoundVar = *AttrVarPtr;
				OutNodeUsage = ENiagaraInputNodeUsage::Attribute;
				return true;
			}
		}
	}
	
	//Next, lets see if we are a system constant.
	//Do we need a smarter (possibly contextual) handling of system constants?
	const TArray<FNiagaraVariable>& SysConstants = FNiagaraConstants::GetEngineConstants();
	if (SysConstants.Contains(PinVar))
	{
		OutFoundVar = PinVar;
		OutNodeUsage = ENiagaraInputNodeUsage::SystemConstant;
		return true;
	}

	//Unable to auto bind.
	return false;
}

#undef LOCTEXT_NAMESPACE
