// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "NiagaraRayTracingCommon.ush"

#define NDICOLLISIONQUERY_USE_GBUFFER_NORMAL    (FEATURE_LEVEL >= FEATURE_LEVEL_SM5)

float NDICollisionQuery_GetSceneDepth(float2 ScreenUV)
{
#if (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
	#if MOBILE_DEFERRED_SHADING
		return ConvertFromDeviceZ(Texture2DSample(MobileSceneTextures.SceneDepthTexture, MobileSceneTextures.SceneDepthTextureSampler, ScreenUV).r);
	#else
		return ConvertFromDeviceZ(Texture2DSample(MobileSceneTextures.SceneColorTexture, MobileSceneTextures.SceneColorTextureSampler, ScreenUV).a);
	#endif
#else
		return CalcSceneDepth(ScreenUV);
#endif
}

float NDICollisionQuery_GetCustomSceneDepth(float2 ScreenUV)
{
#if (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
	return ConvertFromDeviceZ(Texture2DSampleLevel(MobileSceneTextures.CustomDepthTexture, MobileSceneTextures.CustomDepthTextureSampler, ScreenUV, 0).r);
#else
	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct.CustomDepthTexture, SceneTexturesStruct_SceneDepthTextureSampler, ScreenUV, 0).r);
#endif
}

void NDICollisionQuery_QuerySceneDepthGPU(in float3 In_SamplePos, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
	Out_SceneDepth = -1;
	Out_WorldPos = float3(0.0, 0.0, 0.0);
	Out_WorldNormal = float3(0.0, 0.0, 1.0);
	Out_IsInsideView = true;
	Out_CameraPosWorld.xyz = View.WorldCameraOrigin.xyz;

	float4 SamplePosition = float4(In_SamplePos + View.PreViewTranslation, 1);
	float4 ClipPosition = mul(SamplePosition, View.TranslatedWorldToClip);
	float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

	// Check if the sample is inside the view.
	if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
	{
		// Sample the depth buffer to get a world position near the sample position.
		float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float SceneDepth = NDICollisionQuery_GetSceneDepth(ScreenUV);
		float3 WorldPosition = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

#if NDICOLLISIONQUERY_USE_GBUFFER_NORMAL
		float3 WorldNormal = Texture2DSampleLevel(SceneTexturesStruct.GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
#else
		float CollisionDepthBounds = 500.0f;
		float SceneDepth0 = NDICollisionQuery_GetSceneDepth(ScreenUV + float2(View.BufferSizeAndInvSize.z, 0.0));
		float SceneDepth1 = NDICollisionQuery_GetSceneDepth(ScreenUV + float2(0.0, View.BufferSizeAndInvSize.w));
		// When using the forward shading, the normal of the pixel is approximated by the derivative of the world position
		// of the pixel. But in on the visible edge this derivative can become very high, making CollisionPlane almost
		// perpendicular to the view plane. In these case the particle may collide the visible edges of the diferent meshes
		// in the view frustum. To avoid this, we disable the collision test if one of the derivate is above a threshold.
		if (max(abs(SceneDepth - SceneDepth0), abs(SceneDepth - SceneDepth1)) > CollisionDepthBounds)
		{
			return;
		}

		float3 WorldPosition0 = WorldPositionFromSceneDepth(ScreenPosition.xy + float2(2 * View.ViewSizeAndInvSize.z, 0.0), SceneDepth0);
		float3 WorldPosition1 = WorldPositionFromSceneDepth(ScreenPosition.xy - float2(0.0, 2 * View.ViewSizeAndInvSize.w), SceneDepth1);
		float3 WorldNormal = normalize(cross(WorldPosition0 - WorldPosition, WorldPosition1 - WorldPosition));
#endif

		// Set outputs
		Out_SceneDepth = SceneDepth;
		Out_WorldPos = WorldPosition;
		Out_WorldNormal = WorldNormal;
	}
	else
	{
		Out_IsInsideView = false;
	}
}

void NDICollisionQuery_QueryCustomDepthGPU(in float3 In_SamplePos, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
	Out_SceneDepth = -1;
	Out_WorldPos = float3(0.0, 0.0, 0.0);
	Out_WorldNormal = float3(0.0, 0.0, 1.0);
	Out_IsInsideView = true;
	Out_CameraPosWorld.xyz = View.WorldCameraOrigin.xyz;

	float4 SamplePosition = float4(In_SamplePos + View.PreViewTranslation, 1);
	float4 ClipPosition = mul(SamplePosition, View.TranslatedWorldToClip);
	float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

	// Check if the sample is inside the view.
	if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
	{
		// Sample the depth buffer to get a world position near the sample position.
		float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float SceneDepth = NDICollisionQuery_GetCustomSceneDepth(ScreenUV);
		float3 WorldPosition = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

#if NDICOLLISIONQUERY_USE_GBUFFER_NORMAL
		float3 WorldNormal = Texture2DSampleLevel(SceneTexturesStruct.GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
#else
		float CollisionDepthBounds = 500.0f;
		float SceneDepth0 = NDICollisionQuery_GetCustomSceneDepth(ScreenUV + float2(View.BufferSizeAndInvSize.z, 0.0));
		float SceneDepth1 = NDICollisionQuery_GetCustomSceneDepth(ScreenUV + float2(0.0, View.BufferSizeAndInvSize.w));
		// When using the forward shading, the normal of the pixel is approximated by the derivative of the world position
		// of the pixel. But in on the visible edge this derivative can become very high, making CollisionPlane almost
		// perpendicular to the view plane. In these case the particle may collide the visible edges of the diferent meshes
		// in the view frustum. To avoid this, we disable the collision test if one of the derivate is above a threshold.
		if (max(abs(SceneDepth - SceneDepth0), abs(SceneDepth - SceneDepth1)) > CollisionDepthBounds)
		{
			return;
		}

		float3 WorldPosition0 = WorldPositionFromSceneDepth(ScreenPosition.xy + float2(2 * View.ViewSizeAndInvSize.z, 0.0), SceneDepth0);
		float3 WorldPosition1 = WorldPositionFromSceneDepth(ScreenPosition.xy - float2(0.0, 2 * View.ViewSizeAndInvSize.w), SceneDepth1);
		float3 WorldNormal = normalize(cross(WorldPosition0 - WorldPosition, WorldPosition1 - WorldPosition));
#endif
	}
	else
	{
		Out_IsInsideView = false;
	}
}

void NDICollisionQuery_QueryMeshDistanceFieldGPU(in float3 In_SamplePos, out float Out_DistanceToNearestSurface, out float3 Out_FieldGradient, out bool Out_IsDistanceFieldValid)
{
#if PLATFORM_SUPPORTS_DISTANCE_FIELDS && (FEATURE_LEVEL >= FEATURE_LEVEL_SM5)
	Out_DistanceToNearestSurface = GetDistanceToNearestSurfaceGlobal(In_SamplePos);
	Out_FieldGradient = GetDistanceFieldGradientGlobal(In_SamplePos);
	Out_IsDistanceFieldValid = MaxGlobalDFAOConeDistance > 0 && !(Out_DistanceToNearestSurface > 0 && all(Out_FieldGradient == float3(0,0,0)));
#else
	Out_DistanceToNearestSurface = 0;
	Out_FieldGradient = (float3)0;
	Out_IsDistanceFieldValid = false;
#endif
}

#if NIAGARA_USE_RAYTRACING

uint BuildRayTraceMask(int TraceChannel)
{
	// for now we'll ignore the TraceChannel till we can mark up the environment
	return 0xFF;
}

void NDICollisionQuery_IssueAsyncRayTrace(uint MaxRayTraceCount, RWStructuredBuffer<FBasicRayData> RWRayRequests, RWBuffer<uint> RWRayTraceCounts, int In_QueryID, float3 In_TraceStart, float3 In_TraceEnd, int In_TraceChannel, out bool Out_IsQueryValid)
{
	Out_IsQueryValid = false;

	if (In_QueryID >= 0 && uint(In_QueryID) < MaxRayTraceCount)
	{
		float3 Trace = In_TraceEnd - In_TraceStart;
		float TraceLength = length(Trace);

		RWRayRequests[In_QueryID].Origin = In_TraceStart;
		RWRayRequests[In_QueryID].Mask = BuildRayTraceMask(In_TraceChannel);
		RWRayRequests[In_QueryID].Direction = normalize(Trace);
		RWRayRequests[In_QueryID].TFar = TraceLength;
		Out_IsQueryValid = true;

		// we want to keep track of the maximum index used
		InterlockedMax(RWRayTraceCounts[0], In_QueryID + 1);
		RWRayTraceCounts[1] = 1;
		RWRayTraceCounts[2] = 1;
	}
}

void NDICollisionQuery_ReserveRayTraceIndex(uint MaxRayTraceCount, RWBuffer<uint> RWRayTraceCounts, int In_TraceCount, out int Out_StartQueryID, out bool Out_IndicesValid)
{
	Out_IndicesValid = false;

	if ((In_TraceCount + RWRayTraceCounts[0]) < MaxRayTraceCount)
	{
		uint RequestIndex = 0;
		InterlockedAdd(RWRayTraceCounts[0], In_TraceCount, RequestIndex);
		RWRayTraceCounts[1] = 1;
		RWRayTraceCounts[2] = 1;

		if ((In_TraceCount + RequestIndex) <= MaxRayTraceCount)
		{
			Out_StartQueryID = int(RequestIndex);
			Out_IndicesValid = true;
		}
		else
		{
			InterlockedMax(RWRayTraceCounts[0], MaxRayTraceCount);
		}
	}
}

void NDICollisionQuery_CreateAsyncRayTrace(uint MaxRayTraceCount, RWStructuredBuffer<FBasicRayData> RWRayRequests, RWBuffer<uint> RWRayTraceCounts, float3 In_TraceStart, float3 In_TraceEnd, int In_TraceChannel, out int Out_QueryID, out bool Out_IsQueryValid)
{
	Out_IsQueryValid = false;

	NDICollisionQuery_ReserveRayTraceIndex(MaxRayTraceCount, RWRayTraceCounts, 1, Out_QueryID, Out_IsQueryValid);

	if (Out_IsQueryValid)
	{
		float3 Trace = In_TraceEnd - In_TraceStart;
		float TraceLength = length(Trace);

		RWRayRequests[Out_QueryID].Origin = In_TraceStart;
		RWRayRequests[Out_QueryID].Mask = BuildRayTraceMask(In_TraceChannel);
		RWRayRequests[Out_QueryID].Direction = normalize(Trace);
		RWRayRequests[Out_QueryID].TFar = TraceLength;
	}
}

void NDICollisionQuery_ReadAsyncRayTrace(uint MaxRayTraceCount, StructuredBuffer<FNiagaraRayTracingPayload> IntersectionResults, int In_PreviousFrameQueryID, out bool Out_CollisionValid, out float Out_CollisionDistance, out float3 Out_CollisionPosWorld, out float3 Out_CollisionNormal)
{
	Out_CollisionValid = false;
	Out_CollisionDistance = 0.0f;
	Out_CollisionPosWorld = float3(0.0f, 0.0f, 0.0f);
	Out_CollisionNormal = float3(0.0f, 0.0f, 0.0f);

	if (In_PreviousFrameQueryID >= 0 && uint(In_PreviousFrameQueryID) < MaxRayTraceCount)
	{
		FNiagaraRayTracingPayload HitResult = IntersectionResults[In_PreviousFrameQueryID];

		Out_CollisionValid = HitResult.IsHit();
		if (Out_CollisionValid)
		{
			Out_CollisionDistance = HitResult.HitT;
			Out_CollisionPosWorld = HitResult.WorldPosition;
			Out_CollisionNormal = HitResult.WorldNormal;
		}
	}
}

#endif