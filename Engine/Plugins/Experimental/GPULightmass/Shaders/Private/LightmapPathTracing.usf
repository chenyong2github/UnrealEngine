// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingRayGenShader.usf: Reference path tracing
===============================================================================================*/

#define SIMPLIFIED_MATERIAL_SHADER 1
#define RANDSEQ_UNROLL_SOBOL 0
#define USE_PATH_TRACING_LIGHT_GRID 1

// Needs to be defined before the uniform buffer struct header is included, very unfortunately
struct FIrradianceCacheRecord
{
	float4 WorldPosition;
	float4 WorldNormal;
	uint4 Irradiance;
};

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/PostProcessCommon.ush"
#include "/Engine/Private/RectLight.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"

#include "/Engine/Private/PathTracing/PathTracingCommon.ush"
#include "/Engine/Private/PathTracing/Light/PathTracingLightGrid.ush"
#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"

#include "BatchedTiles.ush"
#include "/Engine/Private/PathTracing/Material/FirstBounceRayGuidingCommon.ush"

int NumRayGuidingTrialSamples;
RWTexture2D<uint> RayGuidingLuminance;
Texture2D<float> RayGuidingCDFX;
Texture2D<float> RayGuidingCDFY;

#include "/Engine/Private/ShadingModels.ush"
#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "/Engine/Private/PathTracing/Light/PathTracingLightSampling.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingMaterialSampling.ush"

#include "IrradianceCachingCommon.ush"

#include "LightmapEncoding.ush"

int LastInvalidationFrame;
int NumTotalSamples;

Texture2D<float4> GBufferWorldPosition;
Texture2D<float4> GBufferWorldNormal;
Texture2D<float4> GBufferShadingNormal;
RWTexture2D<float4> IrradianceAndSampleCount;
RWTexture2D<float4> SHDirectionality;
RWTexture2D<float4> SHCorrectionAndStationarySkyLightBentNormal;

RWTexture2D<float4> OutputTileAtlas;

void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	inout RandomSequence RandSequence,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float3 TangentDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
	// Draw random variable
	float2 BufferSize = View.BufferSizeAndInvSize.xy;
	float2 RandSample = RandomSequence_GenerateSample2D(RandSequence);

	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	TangentDirection = Direction_Tangent;
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = 1e20;
	RayPdf = 1.0f;
}

struct FThreeBandSHVectorFloat
{
	float4 V0;
	float4 V1;
	float V2;
};

struct FThreeBandSHVectorRGBFloat
{
	FThreeBandSHVectorFloat R;
	FThreeBandSHVectorFloat G;
	FThreeBandSHVectorFloat B;
};

FThreeBandSHVectorFloat SHBasisFunction3Float(float3 InputVector)
{
	FThreeBandSHVectorFloat Result;
	// These are derived from simplifying SHBasisFunction in C++
	Result.V0.x = 0.282095f; 
	Result.V0.y = -0.488603f * InputVector.y;
	Result.V0.z = 0.488603f * InputVector.z;
	Result.V0.w = -0.488603f * InputVector.x;

	half3 VectorSquared = InputVector * InputVector;
	Result.V1.x = 1.092548f * InputVector.x * InputVector.y;
	Result.V1.y = -1.092548f * InputVector.y * InputVector.z;
	Result.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
	Result.V1.w = -1.092548f * InputVector.x * InputVector.z;
	Result.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);

	return Result;
}

#define WorldPositionScalar 0.00001f

#ifndef USE_IRRADIANCE_CACHING
	#define USE_IRRADIANCE_CACHING 0
#endif

static const uint MaxBounces = 32;

// 0: only Material sampling
// 1: only Light sampling
// 2: both Material and Light
static const uint MISMode = 2;

static const uint ApproximateCaustics = 1;
static const uint EnableCameraBackfaceCulling = 0;
static const uint EnableDirectLighting = 1;
static const uint EnableEmissive = 1;
static const float MaxNormalBias = 0.1;

RaytracingAccelerationStructure TLAS;
uint SceneVisibleLightCount;

void AccumulateRadiance(inout float3 TotalRadiance, float3 PathRadiance)
{
	float MaxPathIntensity = 0;
	if (MaxPathIntensity > 0)
	{
		// User asked for path contributions to be clamped to reduce fireflies.
		// Depending on how aggressive this value is, the image could be quite biased
		TotalRadiance += min(PathRadiance, MaxPathIntensity);
	}
	else
	{
		// Just average values directly
		TotalRadiance += PathRadiance;
	}
}

FMaterialClosestHitPayload TraceTransparentRay(RayDesc Ray, FRayCone RayCone, bool IsCameraRay, bool LastBounce, bool IncludeEmission, uint2 LaunchIndex, uint NumLights, inout RandomSequence RandSequence, inout float3 PathThroughput, inout float3 Radiance)
{
	const uint RayFlags = IsCameraRay && EnableCameraBackfaceCulling ? RAY_FLAG_CULL_BACK_FACING_TRIANGLES : 0;
	const uint MissShaderIndex = 0;
	float SelectionWeightSum = 0;
	float3 PayloadThroughput = PathThroughput;
	FMaterialClosestHitPayload Payload;
	if (!IncludeEmission && LastBounce)
	{
		Payload.SetMiss();
		PathThroughput = 0;
		return Payload;
	}
	for (;;)
	{
		FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;
		// Set payload inputs
		PackedPayload.SetRayCone(RayCone);
		PackedPayload.SetPixelCoord(LaunchIndex);
		if (!IsCameraRay)
		{
			// avoid double counting what was captured by the skylight
			// also avoid noise from hot spots (they can be properly
			// importance sampled if a capturing skylight is added)
			PackedPayload.SetIgnoreSkyMaterials();
		}
		// Trace the ray
		TraceRay(
			TLAS,
			RayFlags,
			RAY_TRACING_MASK_ALL,
			RAY_TRACING_SHADER_SLOT_MATERIAL,
			RAY_TRACING_NUM_SHADER_SLOTS,
			MissShaderIndex,
			Ray,
			PackedPayload);

		// Loop over lights to capture their contribution
		// #dxr_todo: if we have lots of lights, having some hierarchical structure would be better ....
		for (uint LightId = 0; LightId < NumLights; ++LightId)
		{
			RayDesc LightRay = Ray;
			LightRay.TMax = PackedPayload.IsMiss() ? Ray.TMax : PackedPayload.HitT;
			float3 LightRadiance = TraceLight(LightRay, LightId).Radiance;
			AccumulateRadiance(Radiance, PathThroughput * LightRadiance);
		}

		if (PackedPayload.IsMiss())
		{
			// Ray didn't hit any real geometry, so nothing left to do
			break;
		}

		// Unpack the payload
		FMaterialClosestHitPayload HitPayload = UnpackPathTracingPayload(PackedPayload, Ray);

		if (HitPayload.BlendingMode == RAY_TRACING_BLEND_MODE_ADDITIVE ||
			HitPayload.BlendingMode == RAY_TRACING_BLEND_MODE_TRANSLUCENT)
		{
			// emission needs to be pre-multiplied by the opacity
			HitPayload.Radiance *= HitPayload.Opacity;
		}

		// add in surface emission (except for modulate blend mode which uses Radiance as the transparency multiplier)
		if (IncludeEmission && HitPayload.BlendingMode != RAY_TRACING_BLEND_MODE_MODULATE)
		{
			AccumulateRadiance(Radiance, PathThroughput * HitPayload.Radiance);
		}

		float3 Transparency = GetMaterialTransparency(HitPayload, Ray.Direction);

		if (!LastBounce)
		{
			float3 Contrib = PathThroughput * EstimateMaterialAlbedo(HitPayload);

			float SelectionWeight = max3(Contrib.x, Contrib.y, Contrib.z);
			SelectionWeightSum += SelectionWeight;
			bool AcceptHit = false;

			// weighted reservoir sampling
			if (SelectionWeight > 0)
			{
				if (SelectionWeight < SelectionWeightSum)
				{
					// the acceptance probability is not 1.0
					// generate a random number to see if we should accept this hit
					float RandValue = RandomSequence_GenerateSample1D(RandSequence);
					AcceptHit = RandValue * SelectionWeightSum < SelectionWeight;
				}
				else
				{
					// accept automatically on the first hit
					AcceptHit = true;
				}
			}

			if (AcceptHit)
			{
				// stash this hit for next time
				Payload = HitPayload;
				PayloadThroughput = PathThroughput / SelectionWeight;
			}
		}

		// prepare next step around the loop
		// retrace the exact same ray with TMin one ulp past the hit we just found
		PathThroughput *= Transparency;
		Ray.TMin = asfloat(asuint(HitPayload.HitT) + 1);

		if (all(PathThroughput == 0))
		{
			break;
		}
	}

	if (SelectionWeightSum > 0)
	{
		// if we stored a valid hit in the payload, reset the path throughput to this point
		PathThroughput = PayloadThroughput * SelectionWeightSum;
	}
	else
	{
		PathThroughput = 0;
		Payload.SetMiss();
	}
	return Payload;
}

float3 TraceTransparentVisibilityRay(RayDesc Ray, uint2 PixelCoord, float PathRoughness)
{
	const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
	const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_SHADOW;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;

	// Signal to the Any hit shader we want to evaluate the opacity
	// The payload is used to carry the path throughput (for transparent shadows)
	// and current path roughness (for approximate caustics)
	PackedPayload.SetPathTracingVisibilityRay();
	PackedPayload.SetRayThroughput(1.0);
	PackedPayload.SetPathRoughness(PathRoughness);
	PackedPayload.SetPixelCoord(PixelCoord);

	// Trace the ray
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray,
		PackedPayload);

	if (PackedPayload.IsMiss())
	{
		// we didn't hit any geo - just return whatever throughput is left
		return PackedPayload.GetRayThroughput();
	}

	// we registered a hit -- assumed to be fully opaque
	return 0;
}

void PathTracingKernel(
	in uint RenderPassIndex,
	float3 WorldPosition,
	float3 ShadingNormal,
	inout RandomSequence RandSequence,
	inout uint SampleIndex,
	inout bool bIsValidSample,
	inout float3 RadianceValue,
	inout float3 RadianceDirection,
	inout float3 DirectLightingNEERadianceValue,
	inout float3 DirectLightingNEERadianceDirection,
	inout float4 PrimaryRandSample)
{
	uint2 LaunchIndex = uint2(0, 0);
	
#if USE_IRRADIANCE_CACHING
	bool bShouldEmitGeometryHitPoint = false;
	
	FIrradianceCacheRecord IrradianceCachePrimaryGIHitPoint = (FIrradianceCacheRecord)0;	
	float RadianceProbe_Pdf = 1.0f / (2 * PI);
	
	uint NewEntrySize = 32;
	int NearestCacheEntryID = -1;
#endif

	float3 Radiance = 0;
	
	// GPULightmass's SampleEmitter(): generate a fake camera ray hitting the texel
	RayDesc Ray;
	Ray.Origin = WorldPosition + ShadingNormal;
	Ray.Direction = -ShadingNormal;
	Ray.TMin = -0.01f;
	Ray.TMax = 1.01f;
	
	// This array will hold a CDF for light picking
	// Seed the array with a uniform CDF at first so that we always have a valid CDF
	float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM];
	
	Ray.Direction = normalize(Ray.Direction);

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;
	
	// path state variables (these cary information between bounces)
	float3 PathThroughput = 1.0;
	float PathRoughness = 0;

	// number of directly visible lights for the first bounce
	uint NumVisibleLights = SceneVisibleLightCount;
	
	for (int Bounce = 0; Bounce <= MaxBounces; Bounce++)
	{		
		const bool bIsCameraRay = Bounce == 0;
		const bool bIsLastBounce = Bounce == MaxBounces;
		const bool bIncludeEmissive = (EnableDirectLighting != 0 || Bounce > 1) &&
									  (EnableEmissive       != 0 || bIsCameraRay);
		FMaterialClosestHitPayload Payload = (FMaterialClosestHitPayload)0;
		
		if (bIsCameraRay)
		{
			// GPULightmass fakes a 'camera' ray that hits the lightmap texel perpendicularly
			Payload.RayCone = (FRayCone)0;
			Payload.WorldPos = WorldPosition;
			Payload.WorldNormal = ShadingNormal;
			Payload.Radiance = float3(0, 0, 0);
			Payload.BaseColor = float3(1, 1, 1);
			Payload.DiffuseColor = float3(1, 1, 1);
			Payload.SpecularColor = float3(0, 0, 0);
			Payload.Specular = 0;
			Payload.Roughness = 1;
			Payload.Metallic = 0;
			Payload.Ior = 1;
			Payload.CustomData = float4(0, 0, 0, 0);
			Payload.Opacity = 1;
			Payload.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
			Payload.BlendingMode = RAY_TRACING_BLEND_MODE_OPAQUE;
			Payload.PrimitiveLightingChannelMask = 0b111;
			Payload.HitT = 1.0f;
			Payload.SetFrontFace();
		}
		else
		{
			Payload = TraceTransparentRay(Ray, RayCone, false , bIsLastBounce, bIncludeEmissive, LaunchIndex, NumVisibleLights, RandSequence, PathThroughput, Radiance);
		}
		
		if (Payload.IsMiss())
		{
			// we didn't hit anything selectable for further shading, we are done
			break;
		}
		
		if (!Payload.IsFrontFace() && !IsMaterialTransmissive(Payload))
		{
			bIsValidSample = false;
			break;
		}

	#if USE_IRRADIANCE_CACHING
		uint CoarseLevelSpacing = IrradianceCachingParameters.Spacing;
		uint DetailLevelSpacing = IrradianceCachingParameters.Spacing;
		
		if (NearestCacheEntryID == -1 && Bounce >= 1 && Payload.HitT >= DetailLevelSpacing * IrradianceCachingParameters.CornerRejection)
		{
			bool bIrradianceQuerySuccessful = false;
			bool bGeometryQuerySuccessful = false;
			
			uint NearestRecordIndex = 0;
			float3 RecordIrradiance;
			float3 RecordWorldNormal;
			
			uint3 Key = EncodeVoxelKey(floor(Payload.WorldPos / (Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing)));
			uint NormalDirectionBits = EncodeNormalBits(Payload.WorldNormal);			
			uint HashKey = 0;
			HashKey = MurmurAdd( HashKey, Key.x );
			HashKey = MurmurAdd( HashKey, Key.y );
			HashKey = MurmurAdd( HashKey, Key.z );
			HashKey = MurmurAdd( HashKey, NormalDirectionBits );
			HashKey = MurmurAdd( HashKey, Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing );
			uint Index;
			if (ICHashTableFind(HashKey, Index))
			{
				uint RecordIndex = IrradianceCachingParameters.RWHashToIndex[Index];
				FIrradianceCacheRecord Record = IrradianceCachingParameters.IrradianceCacheRecords[RecordIndex];
				if (Record.Irradiance.w > IrradianceCachingParameters.Quality)
				{
					bIrradianceQuerySuccessful = true;
					
					RecordIrradiance = asfloat(Record.Irradiance.xyz) / Record.Irradiance.w;
				}
				
				bGeometryQuerySuccessful = true;
				RecordWorldNormal = Record.WorldNormal.xyz;
				NearestRecordIndex = RecordIndex;
			}
	
			if (bIrradianceQuerySuccessful)
			{
				// Successful query. Terminate path immediately. Can happen when accumulating for IC entries.
				Radiance += RecordIrradiance * PathThroughput;
				break;
			}
			else
			{
				// Failed query.
				if (Bounce == 1)
				{
					if (!bGeometryQuerySuccessful)
					{
						bShouldEmitGeometryHitPoint = true;
						IrradianceCachePrimaryGIHitPoint.WorldPosition.xyz = Payload.WorldPos;
						IrradianceCachePrimaryGIHitPoint.WorldNormal.xyz = Payload.WorldNormal;
						NewEntrySize = Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing;
					}
					else
					{
						NearestCacheEntryID = NearestRecordIndex;
					}
				}
			}
		}
	#endif
		
		// As soon as the path is blurry enough, we can get away with diffuse sampling only
		const bool bSimplifySSS = PathRoughness >= 0.15;

		if (ApproximateCaustics)
		{
			// modify the payload roughness to minimize difficult caustics
			// This is inspired by a trick used in the Arnold renderer:
			//   https://cgg.mff.cuni.cz/~jaroslav/gicourse2010/giai2010-02-marcos_fajardo-slides.pdf (slide 39)
			//   https://www.arnoldrenderer.com/research/Arnold_TOG2018.pdf (section 4.2)
			AdjustMaterialRoughness(Payload, PathRoughness);
		}
		
		FLightLoopCount LightLoopCount = LightGridLookup(Payload.WorldPos);

		// Choose a random number for both Light sampling and BxDF sampling
		float4 RandSample = RandomSequence_GenerateSample4D(RandSequence);

		// Does this material require NEE? (will be false if MaterialPdf is always +inf)
		const bool bIsNeeValid = IsNeeValidMaterial(Payload);

		const bool bDoLightLoop = EnableDirectLighting != 0 || Bounce > 0;

		float LightPickingCdfSum = 0;

		// If we are using Light sampling and the material can use it ...
		if (MISMode != 0 && bIsNeeValid && SceneLightCount > 0 && bDoLightLoop)
		{
			// Choose a light and sample it
			float3 WorldPos = Payload.WorldPos;
			float3 WorldNormal = Payload.WorldNormal;
			uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;

			bool IsTransmissiveMaterial = ENABLE_TRANSMISSION && IsMaterialTransmissive(Payload);

			for (uint Index = 0, Num = LightLoopCount.NumLights; Index < Num; ++Index)
			{
				uint LightIndex = GetLightId(Index, LightLoopCount);
				LightPickingCdfSum += EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial);
				LightPickingCdf[Index] = LightPickingCdfSum;
			}

			if (LightPickingCdfSum > 0)
			{
				// init worked
				int LightId;
				float LightPickPdf = 0;

				SelectLight(RandSample.x * LightPickingCdfSum, LightLoopCount.NumLights, LightPickingCdf, LightId, LightPickPdf);
				LightPickPdf /= LightPickingCdfSum;

				LightId = GetLightId(LightId, LightLoopCount);
				FLightSample LightSample = SampleLight(LightId, RandSample.yz, WorldPos, WorldNormal);

				LightSample.RadianceOverPdf /= LightPickPdf;
				LightSample.Pdf *= LightPickPdf;
				if (LightSample.Pdf > 0)
				{
					if (CastsShadow(LightId))
					{
						// for transmissive materials, bias the position to the other side of the surface if the light is coming from behind
						const float SignedPositionBias = IsTransmissiveMaterial ? sign(dot(Payload.WorldNormal, LightSample.Direction)) : 1.0;

						RayDesc LightRay;
						LightRay.Origin = WorldPos;
						LightRay.TMin = 0;
						LightRay.Direction = LightSample.Direction;
						LightRay.TMax = LightSample.Distance;
						ApplyPositionBias(LightRay, SignedPositionBias * Payload.WorldNormal, MaxNormalBias);

						float AvgRoughness = ApproximateCaustics ? GetAverageRoughness(Payload) : 0.0;

						LightSample.RadianceOverPdf *= TraceTransparentVisibilityRay(LightRay, LaunchIndex, AvgRoughness);
					}

					// #dxr_todo: Is it cheaper to fire the ray first? Or eval the material first?
					if (any(LightSample.RadianceOverPdf > 0))
					{
						// Evaluate material
						FMaterialEval MaterialEval = EvalMaterial(Ray.Direction, LightSample.Direction, Payload, Bounce == 0);

						// Record the contribution
						float3 LightContrib = PathThroughput * LightSample.RadianceOverPdf * MaterialEval.Weight * MaterialEval.Pdf;
						if (MISMode == 2)
						{
							LightContrib *= MISWeightRobust(LightSample.Pdf, MaterialEval.Pdf);
						}

						// Record the contribution
						if (Bounce > 0)
						{
							AccumulateRadiance(Radiance, LightContrib);
						}
						else
						{
							// GPULightmass records contribution of direct lighting separately, and only for static lights
							if (!IsStationary(LightId))
							{
								DirectLightingNEERadianceValue += LightContrib;
								DirectLightingNEERadianceDirection = LightSample.Direction;
							}
						}
					}
				}
			}
		}
	
		// Sample material
		FMaterialSample MaterialSample = SampleMaterial(Ray.Direction, Payload, RandSample, Bounce == 0);

		if (MaterialSample.Pdf < 0 || asuint(MaterialSample.Pdf) > 0x7F800000)
		{
			// Pdf became invalid (either negative or NaN)
			Radiance = float3(1, 0, 1);
			break;
		}

		if (!(MaterialSample.Pdf > 0))
		{
			// No valid direction -- we are done
			break;
		}

		float3 NextPathThroughput = PathThroughput * MaterialSample.Weight;
		if (!any(NextPathThroughput > 0))
		{
			// no energy left in this path
			break;
		}

		// Russian roulette:
		//   The probability of keeping the path should be roughly proportional to the weight at the current shade point,
		//  but just using MaterialWeight would miss out on cases where the path throughput changes color (like in a cornell
		//  box when bouncing between walls of different colors). So use the ratio of the brightest color channel in the
		//  previous and next throughput.
		//   The second tweak is to add a sqrt() around the probability to soften the termination probability (paths will last
		//  a little longer). This allows paths to go a bit deeper than the naive heuristic while still allowing them to terminate
		//  early. This makes RR effective from the very first bounce without needing to delay it.
		float ContinuationProb = sqrt(saturate(max(NextPathThroughput.x, max(NextPathThroughput.y, NextPathThroughput.z)) / max(PathThroughput.x, max(PathThroughput.y, PathThroughput.z))));
		if (ContinuationProb < 1)
		{
			// If there is some chance we should terminate the ray, draw an extra random value
			float RussianRouletteRand = RandSample.w; // SampleMaterial does not use this value at the moment
			//RussianRouletteRand = RandomSequence_GenerateSample1D(RandSequence);
			if (RussianRouletteRand >= ContinuationProb)
			{
				// stochastically terminate the path
				break;
			}
			PathThroughput = NextPathThroughput / ContinuationProb;
		}
		else
		{
			PathThroughput = NextPathThroughput;
		}

		// Update ray according to material sample
		Ray.Origin = Payload.WorldPos;
		Ray.Direction = MaterialSample.Direction;
		Ray.TMin = 0;
		Ray.TMax = POSITIVE_INFINITY;
		ApplyPositionBias(Ray, MaterialSample.PositionBiasSign * Payload.WorldNormal, MaxNormalBias);

		if (ApproximateCaustics)
		{
			// enlarge roughness based on the chosen lobe roughness
			PathRoughness = max(PathRoughness, MaterialSample.Roughness);
		}
		
		if (Bounce == 0)
		{
			RadianceDirection = Ray.Direction;
		#if USE_IRRADIANCE_CACHING
			RadianceProbe_Pdf = MaterialSample.Pdf;
		#endif
			PrimaryRandSample = RandSample;
		}
		
		// If we are using Material sampling for lights
		if (MISMode != 1 && bDoLightLoop)
		{
			// Check which lights can be seen by the material ray and trace a dedicated shadow ray
			// While it would be possible to just loop around and use the indirect ray to do this, it would prevent the application
			// of shadow ray specific logic for transparent shadows or various per light tricks like shadow casting
			const bool bUseMIS = MISMode == 2 && LightPickingCdfSum > 0;
			for (uint Index = 0, Num = LightLoopCount.NumMISLights; Index < Num; ++Index)
			{
				uint LightId = GetLightId(Index, LightLoopCount);
				if ((Payload.PrimitiveLightingChannelMask & GetLightingChannelMask(LightId)) == 0)
				{
					// light does not affect the current ray
					continue;
				}

				FLightHit LightResult = TraceLight(Ray, LightId);

				if (LightResult.IsMiss())
				{
					continue;
				}

				float3 LightContrib = PathThroughput * LightResult.Radiance;
				if (bUseMIS)
				{
					float PreviousCdfValue = Index > 0 ? LightPickingCdf[Index - 1] : 0.0;
					float LightPickPdf = (LightPickingCdf[Index] - PreviousCdfValue) / LightPickingCdfSum;

					LightContrib *= MISWeightRobust(MaterialSample.Pdf, LightResult.Pdf * LightPickPdf);
				}

				if (any(LightContrib > 0))
				{
					if (CastsShadow(LightId))
					{
						RayDesc LightRay = Ray;
						LightRay.TMax = LightResult.HitT;
						LightContrib *= TraceTransparentVisibilityRay(LightRay, LaunchIndex, PathRoughness);
					}
					// the light made some contribution, and there was nothing along the shadow ray
					AccumulateRadiance(Radiance, LightContrib);
				}
			}
			
		}

		// from this point on, we don't need to include lights in the trace call
		// because NEE handled it for us
		NumVisibleLights = 0;
		
		// update ray cone for the next bounce
		RayCone = Payload.GetRayCone();
	}
	
#if USE_IRRADIANCE_CACHING
	if(bIsValidSample)
	{
		if(bShouldEmitGeometryHitPoint)
		{
			EmitGeometryHitPoint(IrradianceCachePrimaryGIHitPoint, NewEntrySize);
		}
		
		if(NearestCacheEntryID != -1)
		{
			float3 IrradianceToAccumulate = Radiance * RadianceProbe_Pdf; // Revert the radiance probe pdf as we're caching the first bounce outgoing radiance
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.r, IrradianceToAccumulate.r);
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.g, IrradianceToAccumulate.g);
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.b, IrradianceToAccumulate.b);
			InterlockedAdd(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.a, 1);
		}
	}
#endif
	
	RadianceValue = Radiance;
}

[shader("raygeneration")]
void LightmapPathTracingMainRG()
{
	uint2 BatchedLaunchIndex = DispatchRaysIndex().xy;

	uint2 LaunchIndex = uint2(BatchedLaunchIndex.x % GPreviewLightmapPhysicalTileSize, BatchedLaunchIndex.y);
	int TileIndex = BatchedLaunchIndex.x / GPreviewLightmapPhysicalTileSize;
	uint2 TexelIndexInPool = LaunchIndex + BatchedTiles[TileIndex].WorkingSetPosition;
	uint2 TexelIndexInScratch = LaunchIndex + BatchedTiles[TileIndex].ScratchPosition;

	float3 WorldPosition = GBufferWorldPosition[TexelIndexInScratch].xyz / WorldPositionScalar;
	float3 WorldNormal = GBufferWorldNormal[TexelIndexInScratch].xyz;
	float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz;

	bool bIsValidSample = true;
	
	if (GBufferWorldPosition[TexelIndexInScratch].w == 0.0f) bIsValidSample = false;
	
	if (NumTotalSamples <= 0 || (NumTotalSamples > 0 && BatchedTiles[TileIndex].RenderPassIndex < NumTotalSamples - 1))
	{
		if (bIsValidSample)
		{			
			// Needs a seed that is only related to position in virtual space to avoid seams due to per-tile calculation
			uint2 VirtualTextureSpacePosition = BatchedTiles[TileIndex].VirtualTilePosition + LaunchIndex - uint2(2, 2);
			uint Seed = VirtualTextureSpacePosition.y * BatchedTiles[TileIndex].LightmapSize.x + VirtualTextureSpacePosition.x;
					
			float4 PrimaryRandSample = float4(-1, -1, -1, -1);
			
			{
				RandomSequence RandSequence;
				RandomSequence_Initialize(RandSequence, Seed, 
				#if USE_FIRST_BOUNCE_RAY_GUIDING
					BatchedTiles[TileIndex].RenderPassIndex >= NumRayGuidingTrialSamples ? 
						(BatchedTiles[TileIndex].RenderPassIndex - NumRayGuidingTrialSamples) : 
				#endif
						(BatchedTiles[TileIndex].RenderPassIndex)
				);
				
				uint SampleIndex = 2;

				float3 RadianceValue = 0;
				float3 RadianceDirection = 0;				
				float3 DirectLightingNEERadianceValue = 0;
				float3 DirectLightingNEERadianceDirection = 0;
				
				if (bIsValidSample)
				{
					PathTracingKernel(
						BatchedTiles[TileIndex].RenderPassIndex,
						WorldPosition,
						WorldNormal,
						RandSequence,
						SampleIndex,
						bIsValidSample,
						RadianceValue,
						RadianceDirection,
						DirectLightingNEERadianceValue,
						DirectLightingNEERadianceDirection,
						PrimaryRandSample
					);
				}
				
				if (any(isnan(RadianceValue)) || any(RadianceValue < 0) || any(isinf(RadianceValue)))
				{
					bIsValidSample = false;
				}
				
				if (bIsValidSample)
				{
					#if USE_FIRST_BOUNCE_RAY_GUIDING						
						if (BatchedTiles[TileIndex].RenderPassIndex < NumRayGuidingTrialSamples)
						{
							int2 ClusterPosition = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) / TEXEL_CLUSTER_SIZE;
							float2 JitteredBin = PrimaryRandSample * DIRECTIONAL_BINS_ONE_DIM;// - float2(0.5f, 0.5f) + PrimaryRandSample.zw;
							int2 PositionInBin = clamp(JitteredBin, float2(0, 0), float2(DIRECTIONAL_BINS_ONE_DIM - 1, DIRECTIONAL_BINS_ONE_DIM - 1));
							int2 FinalPosition = ClusterPosition * DIRECTIONAL_BINS_ONE_DIM + PositionInBin;
							float Illuminance = Luminance(RadianceValue) * saturate(dot(RadianceDirection, ShadingNormal));
							// For positive floats we can cast them to uint and use atomic max directly
							InterlockedMax(RayGuidingLuminance[BatchedTiles[TileIndex].WorkingSetPosition / GPreviewLightmapPhysicalTileSize * CDF_TILE_SIZE + FinalPosition], asuint(max(Illuminance, 0)));
						}
					
						if (BatchedTiles[TileIndex].RenderPassIndex == NumRayGuidingTrialSamples) 
						{
							IrradianceAndSampleCount[TexelIndexInPool]= float4(0, 0, 0, 0);
							SHDirectionality[TexelIndexInPool] = float4(0, 0, 0, 0);
							SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 0;
						}
					#endif
					
					{
						FL2SHAndCorrection SH = (FL2SHAndCorrection)0;
						
						float TangentZ = saturate(dot(RadianceDirection, ShadingNormal));
						SH.AddIncomingRadiance(Luminance(RadianceValue), RadianceDirection, TangentZ);
						
						IrradianceAndSampleCount[TexelIndexInPool].rgb += float3(RadianceValue * TangentZ / PI);
						SHDirectionality[TexelIndexInPool] += SH.L2SHCoefficients;					
						SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x += SH.Correction;
					}
					
					{
						FL2SHAndCorrection SH = (FL2SHAndCorrection)0;
						
						float TangentZ = saturate(dot(DirectLightingNEERadianceDirection, ShadingNormal));
						SH.AddIncomingRadiance(Luminance(DirectLightingNEERadianceValue), DirectLightingNEERadianceDirection, TangentZ);
						
						IrradianceAndSampleCount[TexelIndexInPool].rgb += float3(DirectLightingNEERadianceValue * TangentZ / PI);
						SHDirectionality[TexelIndexInPool] += SH.L2SHCoefficients;					
						SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x += SH.Correction;
					}
				}
			}
		}

		uint SampleCount = asuint(IrradianceAndSampleCount[TexelIndexInPool].w);

#if 0 // Smooth invalidation. This path is currently disabled to avoid inconsistency when saving baked results.
		if (BatchedTiles[TileIndex].FrameIndex < LastInvalidationFrame)
		{
			if (SampleCount > 0)
			{
				float L = Luminance(IrradianceAndSampleCount[TexelIndexInPool].rgb / SampleCount);
				int HistoryWeight = 2.0f / (1.0f + L * L);
				IrradianceAndSampleCount[TexelIndexInPool].rgb = IrradianceAndSampleCount[TexelIndexInPool].rgb / SampleCount * HistoryWeight;
				SHDirectionality[TexelIndexInPool] = SHDirectionality[TexelIndexInPool] / SampleCount * HistoryWeight;
				SampleCount = HistoryWeight;
			}
		}
#endif
		
		if (bIsValidSample)
			SampleCount++;
		
		IrradianceAndSampleCount[TexelIndexInPool].a = asfloat(SampleCount);
	}
			
	#if 0 // Debug: Ray guiding PDF visualization
		{
			int2 ClusterPosition = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) / TEXEL_CLUSTER_SIZE;
			int2 PositionInBin = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) % DIRECTIONAL_BINS_ONE_DIM;
			int2 FinalPosition = ClusterPosition * DIRECTIONAL_BINS_ONE_DIM + PositionInBin;

			IrradianceAndSampleCount[TexelIndexInPool].rgb = (
				asfloat(RayGuidingCDF[BatchedTiles[TileIndex].WorkingSetPosition / GPreviewLightmapPhysicalTileSize * CDF_TILE_SIZE + LaunchIndex]).xxx / (1 + asuint(IrradianceAndSampleCount[TexelIndexInPool].a))
			);
			
			SHDirectionality[TexelIndexInPool] = float4(1, 0, 0, 0);					
			SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 1;
		}
	#endif

#if 0 // Debug: GBuffer shading normal visualization	
	{
		const half LogBlackPoint = 0.01858136;
	
		float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz * 0.5f + 0.5f;
		
		IrradianceAndSampleCount[TexelIndexInPool].rgb = ShadingNormal;
		IrradianceAndSampleCount[TexelIndexInPool].a = asfloat(1);
		
		SHDirectionality[TexelIndexInPool] = float4(1, 0, 0, 0);					
		SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 1;
	}
#endif
}

#include "BrickAllocationDefs.ush"

uint FrameNumber;
float4 VolumeMin;
float4 VolumeSize;
int3 IndirectionTextureDim;
Texture3D<uint4> IndirectionTexture;
Buffer<uint4> BrickRequests;
int NumTotalBricks;
int BrickBatchOffset;

RWTexture3D<float4> AmbientVector;
RWTexture3D<float4> SHCoefficients0R;
RWTexture3D<float4> SHCoefficients1R;
RWTexture3D<float4> SHCoefficients0G;
RWTexture3D<float4> SHCoefficients1G;
RWTexture3D<float4> SHCoefficients0B;
RWTexture3D<float4> SHCoefficients1B;
RWTexture3D<UNORM float> DirectionalLightShadowing;

uint MortonEncode3(uint3 Pixel)
{
	uint Morton = MortonCode3(Pixel.x & 0xFF) | (MortonCode3(Pixel.y & 0xFF) << 1) | (MortonCode3(Pixel.z & 0xFF) << 1);
	return Morton;
}

// Must match C++
struct FLightShaderConstants
{
	float3 Position;
	float  InvRadius;
	float3 Color;
	float  FalloffExponent;
	float3 Direction;
	float  SpecularScale;
	float3 Tangent;
	float  SourceRadius;
	float2 SpotAngles;
	float  SoftSourceRadius;
	float  SourceLength;
	float  RectLightBarnCosAngle;
	float  RectLightBarnLength;
	
	void FillLightShaderParameters(inout FLightShaderParameters LightShaderParameters)
	{
		LightShaderParameters.Position = Position;
		LightShaderParameters.InvRadius = InvRadius;
		LightShaderParameters.Color = Color;
		LightShaderParameters.FalloffExponent = FalloffExponent;
		LightShaderParameters.Direction = Direction;
		LightShaderParameters.SpecularScale = SpecularScale;
		LightShaderParameters.Tangent = Tangent;
		LightShaderParameters.SourceRadius = SourceRadius;
		LightShaderParameters.SpotAngles = SpotAngles;
		LightShaderParameters.SoftSourceRadius = SoftSourceRadius;
		LightShaderParameters.SourceLength = SourceLength;
		LightShaderParameters.RectLightBarnCosAngle = RectLightBarnCosAngle;
		LightShaderParameters.RectLightBarnLength = RectLightBarnLength;
	}
};

#define LIGHT_TYPE_DIRECTIONAL		0 
#define LIGHT_TYPE_POINT			1 
#define LIGHT_TYPE_SPOT				2 
#define LIGHT_TYPE_RECT				3 
#define LIGHT_TYPE_MAX				4 

bool GenerateOcclusionRay(
	int LightType,
	FLightShaderParameters LightParameters,
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	inout float3 RayOrigin,
	inout float3 RayDirection,
	inout float RayTMin,
	inout float RayTMax
)
{
	if (LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		GenerateDirectionalLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax);
	}
	else if (LightType == LIGHT_TYPE_POINT)
	{
		if (LightParameters.SourceRadius == 0)
		{
			return GeneratePointLightOcclusionRay(
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ RayOrigin,
				/* out */ RayDirection,
				/* out */ RayTMin,
				/* out */ RayTMax);
		}
		else
		{
			float RayPdf;
			return GenerateSphereLightOcclusionRayWithSolidAngleSampling(
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ RayOrigin,
				/* out */ RayDirection,
				/* out */ RayTMin,
				/* out */ RayTMax,
				/* out */ RayPdf);
		}
	}
	else if (LightType == LIGHT_TYPE_SPOT)
	{
		return GenerateSpotLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax);
	}
	else if (LightType == LIGHT_TYPE_RECT)
	{
		float RayPdf = 0.0;
		return GenerateRectLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax,
			/* out */ RayPdf);
	}

	return true;
}

StructuredBuffer<FLightShaderConstants> LightShaderParametersArray;

[shader("raygeneration")]
void VolumetricLightmapPathTracingMainRG()
{
	uint BrickVolumeSize = 5 * 5 * 5;
	uint BrickIndex = DispatchRaysIndex().x / BrickVolumeSize + BrickBatchOffset;
	if (BrickIndex >= NumTotalBricks) return;
	uint CellIndex = DispatchRaysIndex().x % BrickVolumeSize;
	uint3 CellPosInBrick = ComputeBrickLayoutPosition(CellIndex, uint3(5, 5, 5));
	
	bool bIsValidSample = true;	
	
	int3 CellPosInVLM = (BrickRequests[BrickIndex].xyz * 4 + CellPosInBrick) * BrickRequests[BrickIndex].w;	
	uint Seed = ComputeBrickLinearAddress(CellPosInVLM, IndirectionTextureDim * 4);
	
	#if 0
		float3 Jitter = RandomSequence_GenerateSample3D(RandSequence);
	#else
		float3 RandSample = float3(
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 2), 
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 3),
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 5)
		);
		float3 Jitter = RandSample;
	#endif		
	
	float3 JitteredCellPosInVLM = (BrickRequests[BrickIndex].xyz * 4 + CellPosInBrick + Jitter - float3(0.5, 0.5, 0.5)) * BrickRequests[BrickIndex].w;	
	float DetailCellSize = VolumeSize.xyz / IndirectionTextureDim / 4;
	float3 WorldPosition = VolumeMin + DetailCellSize * JitteredCellPosInVLM;
	float3 ShadingNormal = float3(0, 0, (FrameNumber % 2 == 0) ? 1 : -1);

	float3 RadianceValue = 0;
	float3 RadianceDirection = 0;				
	float3 DirectLightingNEERadianceValue = 0;
	float3 DirectLightingNEERadianceDirection = 0;
	float4 PrimaryRandSample;

	if (bIsValidSample)
	{
		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, Seed, FrameNumber / 2);	
		uint SampleIndex = 4;
		
		PathTracingKernel(
			FrameNumber,
			WorldPosition,
			ShadingNormal,
			RandSequence,
			SampleIndex,
			bIsValidSample,
			RadianceValue,
			RadianceDirection,
			DirectLightingNEERadianceValue,
			DirectLightingNEERadianceDirection,
			PrimaryRandSample);
	}
	
	// Every even sample is upper hemisphere, odd sample is lower hemisphere
	// SampleCount stored is twice as the actual full sphere sample count
	RadianceValue *= 2;
	DirectLightingNEERadianceValue *= 2;

	if (any(isnan(RadianceValue)) || any(RadianceValue < 0))
	{
		bIsValidSample = false;
	}

	uint PaddedBrickSize = 4 + 1;
	uint3 VoxelPos = ComputeBrickLayoutPosition(BrickIndex, uint3(256, 256, 256)) * PaddedBrickSize + CellPosInBrick;

	if (FrameNumber == 0)
	{
		AmbientVector[VoxelPos] = float4(0, 0, 0, 0);
		
		SHCoefficients0R[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1R[VoxelPos] = float4(0, 0, 0, 0);
		
		SHCoefficients0G[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1G[VoxelPos] = float4(0, 0, 0, 0);		
		
		SHCoefficients0B[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1B[VoxelPos] = float4(0, 0, 0, 0);
	}
	
	if (bIsValidSample)
	{
		uint SampleCount = asuint(AmbientVector[VoxelPos].w);
		
		{
			FThreeBandSHVectorRGBFloat SH;
			SH.R.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.r;
			SH.R.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.r;
			SH.R.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.r;
			SH.G.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.g;
			SH.G.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.g;
			SH.G.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.g;
			SH.B.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.b;
			SH.B.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.b;
			SH.B.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.b;
			
			AmbientVector[VoxelPos].x += SH.R.V0.x;
			AmbientVector[VoxelPos].y += SH.G.V0.x;
			AmbientVector[VoxelPos].z += SH.B.V0.x;
			
			SHCoefficients0R[VoxelPos] += float4(SH.R.V0.yzw, SH.R.V1.x);
			SHCoefficients1R[VoxelPos] += float4(SH.R.V1.yzw, SH.R.V2);
			
			SHCoefficients0G[VoxelPos] += float4(SH.G.V0.yzw, SH.G.V1.x);
			SHCoefficients1G[VoxelPos] += float4(SH.G.V1.yzw, SH.G.V2);		
			
			SHCoefficients0B[VoxelPos] += float4(SH.B.V0.yzw, SH.B.V1.x);
			SHCoefficients1B[VoxelPos] += float4(SH.B.V1.yzw, SH.B.V2);
		}
		
		{
			FThreeBandSHVectorRGBFloat SH;
			SH.R.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.r;
			SH.R.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.r;
			SH.R.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.r;
			SH.G.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.g;
			SH.G.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.g;
			SH.G.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.g;
			SH.B.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.b;
			SH.B.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.b;
			SH.B.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.b;
			
			AmbientVector[VoxelPos].x += SH.R.V0.x;
			AmbientVector[VoxelPos].y += SH.G.V0.x;
			AmbientVector[VoxelPos].z += SH.B.V0.x;
			
			SHCoefficients0R[VoxelPos] += float4(SH.R.V0.yzw, SH.R.V1.x);
			SHCoefficients1R[VoxelPos] += float4(SH.R.V1.yzw, SH.R.V2);
			
			SHCoefficients0G[VoxelPos] += float4(SH.G.V0.yzw, SH.G.V1.x);
			SHCoefficients1G[VoxelPos] += float4(SH.G.V1.yzw, SH.G.V2);		
			
			SHCoefficients0B[VoxelPos] += float4(SH.B.V0.yzw, SH.B.V1.x);
			SHCoefficients1B[VoxelPos] += float4(SH.B.V1.yzw, SH.B.V2);
		}
		
		AmbientVector[VoxelPos].w = asfloat(SampleCount + 1);
	}
	
	// 32 samples for single sample stationary directional light shadowing
	if (FrameNumber < 32 && length(LightShaderParametersArray[0].Direction) > 0)
	{
		FLightShaderParameters LightParameters;
		LightShaderParametersArray[0].FillLightShaderParameters(LightParameters);

		float2 RandSample = float2(
			Halton(StrongIntegerHash(Seed) + FrameNumber, 5), 
			Halton(StrongIntegerHash(Seed) + FrameNumber, 7)
		);
		
		RayDesc Ray;
		bool bIsValidRay = GenerateOcclusionRay(
			LIGHT_TYPE_DIRECTIONAL,
			LightParameters,
			WorldPosition, ShadingNormal,
			RandSample,
			/* out */ Ray.Origin,
			/* out */ Ray.Direction,
			/* out */ Ray.TMin,
			/* out */ Ray.TMax);
			
		Ray.Origin += Ray.Direction * 0.01f;
			
		if (bIsValidRay)
		{
			uint RayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
	
			FMinimalPayload MinimalPayload = TraceVisibilityRay(
				TLAS,
				RayFlags,
				RAY_TRACING_MASK_SHADOW,
				uint2(0, 0),
				Ray);
			
			DirectionalLightShadowing[VoxelPos] += (MinimalPayload.IsMiss() ? 1 : 0) / 32.0f;
		}
	}
}

Buffer<int> LightTypeArray;
Buffer<int> ChannelIndexArray;
Buffer<int> LightSampleIndexArray;
RWTexture2D<float4> ShadowMask;
RWTexture2D<float4> ShadowMaskSampleCount;

[shader("raygeneration")]
void StationaryLightShadowTracingMainRG()
{
	uint2 BatchedLaunchIndex = DispatchRaysIndex().xy;

	uint2 LaunchIndex = uint2(BatchedLaunchIndex.x % GPreviewLightmapPhysicalTileSize, BatchedLaunchIndex.y);
	int TileIndex = BatchedLaunchIndex.x / GPreviewLightmapPhysicalTileSize;
	uint2 TexelIndexInPool = LaunchIndex + BatchedTiles[TileIndex].WorkingSetPosition;
	uint2 TexelIndexInScratch = LaunchIndex + BatchedTiles[TileIndex].ScratchPosition;

	int ChannelIndex = ChannelIndexArray[TileIndex];

	bool bIsValidSample = true;
	
	float3 WorldPosition = GBufferWorldPosition[TexelIndexInScratch].xyz / WorldPositionScalar;	
	if (GBufferWorldPosition[TexelIndexInScratch].w == 0.0f)
	{
		bIsValidSample = false;
	}
	
	if (bIsValidSample)
	{
		float3 WorldNormal = GBufferWorldNormal[TexelIndexInScratch].xyz;
		float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz;
		
		// Needs a seed that is only related to position in virtual space to avoid seams due to per-tile calculation
		uint2 VirtualTextureSpacePosition = BatchedTiles[TileIndex].VirtualTilePosition + LaunchIndex - uint2(2, 2);
		uint Seed = VirtualTextureSpacePosition.y * BatchedTiles[TileIndex].LightmapSize.x + VirtualTextureSpacePosition.x;
		
		int LightType = LightTypeArray[TileIndex];
		FLightShaderParameters LightParameters;
		LightShaderParametersArray[TileIndex].FillLightShaderParameters(LightParameters);
		
		{
			float2 RandSample = float2(
				Halton(StrongIntegerHash(Seed) + LightSampleIndexArray[TileIndex], 5), 
				Halton(StrongIntegerHash(Seed) + LightSampleIndexArray[TileIndex], 7)
			);
			
			RayDesc Ray;
			bIsValidSample &= GenerateOcclusionRay(
				LightType,
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ Ray.Origin,
				/* out */ Ray.Direction,
				/* out */ Ray.TMin,
				/* out */ Ray.TMax);
				
			Ray.Origin += Ray.Direction * 0.01f;
				
			if (bIsValidSample)
			{
				uint RayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;

				FMinimalPayload MinimalPayload = TraceVisibilityRay(
					TLAS,
					RayFlags,
					RAY_TRACING_MASK_SHADOW,
					uint2(0, 0),
					Ray);
				
				uint Visibility = asuint(ShadowMask[TexelIndexInPool][ChannelIndex]);
				uint SampleCount = asuint(ShadowMaskSampleCount[TexelIndexInPool][ChannelIndex]);
				Visibility += MinimalPayload.IsMiss() ? 1 : 0;
				SampleCount++;
				ShadowMask[TexelIndexInPool][ChannelIndex] = asfloat(Visibility);
				ShadowMaskSampleCount[TexelIndexInPool][ChannelIndex] = asfloat(SampleCount);
			}
		}
	}
}
