// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingRayGenShader.usf: Reference path tracing
===============================================================================================*/

#define FORCE_ALL_MATERIALS_DIFFUSE 1

// Needs to be defined before the uniform buffer struct header is included, very unfortunately
struct FIrradianceCacheRecord
{
	float4 WorldPosition;
	float4 WorldNormal;
	uint4 Irradiance;
};

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/PostProcessCommon.ush"
#include "/Engine/Private/RectLight.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"

#include "/Engine/Private/PathTracing/PathTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"

#include "BatchedTiles.ush"
#include "/Engine/Private/PathTracing/Material/FirstBounceRayGuidingCommon.ush"
#include "/Engine/Private/QuasiRandom.ush"

int NumRayGuidingTrialSamples;
RWTexture2D<uint> RayGuidingLuminance;
Texture2D<float> RayGuidingCDFX;
Texture2D<float> RayGuidingCDFY;

#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "/Engine/Private/PathTracing/Light/PathTracingLightSampling.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingMaterialSampling.ush"

#include "IrradianceCachingCommon.ush"

#include "LightmapEncoding.ush"

int LastInvalidationFrame;
int NumTotalSamples;

RaytracingAccelerationStructure TLAS;

Texture2D<float4> GBufferWorldPosition;
Texture2D<float4> GBufferWorldNormal;
Texture2D<float4> GBufferShadingNormal;
RWTexture2D<float4> IrradianceAndSampleCount;
RWTexture2D<float4> SHDirectionality;
RWTexture2D<float4> SHCorrectionAndStationarySkyLightBentNormal;

RWTexture2D<float4> OutputTileAtlas;

void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	inout RandomSequence RandSequence,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float3 TangentDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
	// Draw random variable
	float2 BufferSize = View.BufferSizeAndInvSize.xy;
	float2 RandSample = RandomSequence_GenerateSample2D(RandSequence);

	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	TangentDirection = Direction_Tangent;
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = 1e20;
	RayPdf = 1.0f;
}

struct FThreeBandSHVectorFloat
{
	float4 V0;
	float4 V1;
	float V2;
};

struct FThreeBandSHVectorRGBFloat
{
	FThreeBandSHVectorFloat R;
	FThreeBandSHVectorFloat G;
	FThreeBandSHVectorFloat B;
};

FThreeBandSHVectorFloat SHBasisFunction3Float(float3 InputVector)
{
	FThreeBandSHVectorFloat Result;
	// These are derived from simplifying SHBasisFunction in C++
	Result.V0.x = 0.282095f; 
	Result.V0.y = -0.488603f * InputVector.y;
	Result.V0.z = 0.488603f * InputVector.z;
	Result.V0.w = -0.488603f * InputVector.x;

	half3 VectorSquared = InputVector * InputVector;
	Result.V1.x = 1.092548f * InputVector.x * InputVector.y;
	Result.V1.y = -1.092548f * InputVector.y * InputVector.z;
	Result.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
	Result.V1.w = -1.092548f * InputVector.x * InputVector.z;
	Result.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);

	return Result;
}

#define WorldPositionScalar 0.00001f

#ifndef USE_IRRADIANCE_CACHING
	#define USE_IRRADIANCE_CACHING 0
#endif

void AccumulateRadiance(inout float3 TotalRadiance, float3 PathRadiance)
{
	float MaxPathIntensity = 0;
	if (MaxPathIntensity > 0)
	{
		// User asked for path contributions to be clamped to reduce fireflies.
		// Depending on how aggressive this value is, the image could be quite biased
		TotalRadiance += min(PathRadiance, MaxPathIntensity);
	}
	else
	{
		// Just average values directly
		TotalRadiance += PathRadiance;
	}
}

void PathTracingKernel(
	in uint RenderPassIndex,
	float3 WorldPosition,
	float3 ShadingNormal,
	inout RandomSequence RandSequence,
	inout uint SampleIndex,
	inout bool bIsValidSample,
	inout float3 RadianceValue,
	inout float3 RadianceDirection,
	inout float3 DirectLightingNEERadianceValue,
	inout float3 DirectLightingNEERadianceDirection,
	inout float4 PrimaryRandSample)
{
	bool IsUnidirectionalEnabled = true;
	bool IsNextEventEstimationEnabled = true;
	
#if USE_IRRADIANCE_CACHING
	bool bShouldEmitGeometryHitPoint = false;
	bool bShouldAccumulateToCacheRecord = false;
	
	FIrradianceCacheRecord IrradianceCachePrimaryGIHitPoint = (FIrradianceCacheRecord)0;	
	float RadianceProbe_Pdf = 1.0f / (2 * PI);
	
	uint NewEntrySize = 32;
	int NearestCacheEntryID = -1;
#endif

	float3 Radiance = 0;
	
	// GPULightmass's SampleEmitter(): generate a fake camera ray hitting the texel
	RayDesc Ray;
	Ray.Origin = WorldPosition + ShadingNormal;
	Ray.Direction = -ShadingNormal;
	Ray.TMin = -0.01f;
	Ray.TMax = 1.01f;
	
	// This array will hold a CDF for light picking
	// Seed the array with a uniform CDF at first so that we always have a valid CDF
	float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM];

	InitLightPickingCdf(LightPickingCdf);
	
	FRayCone RayCone = (FRayCone)0;
	
	// Cast ray
	const uint InitialRayFlags = 0;
	const bool bInitialDisableSkyLightContribution = false;
	const bool bIgnoreTranslucentMaterials = true;

	// path state variables (these cary information between bounces)
	float3 PathThroughput = 1.0;

	// We don't want the camera ray to have any MIS contribution against direct light sampling so we pretend that it came from
	// a singular Material scattering event.
	float PrevMaterialPdf = POSITIVE_INFINITY;

	// 0: only Material sampling
	// 1: only Light sampling
	// 2: both Material and Light
	const int MISMode = 2; //PathTracingData.MISMode;
	
	for (int Bounce = 0; Bounce <= 32; Bounce++)
	{
		FMaterialClosestHitPayload Payload = (FMaterialClosestHitPayload)0;
		
		if (Bounce == 0)
		{
			// GPULightmass fakes a hit result on the texel
			Payload.RayCone = (FRayCone)0;
			Payload.WorldPos = WorldPosition;
			Payload.WorldNormal = ShadingNormal;
			Payload.Radiance = float3(0, 0, 0);
			Payload.BaseColor = float3(1, 1, 1);
			Payload.DiffuseColor = float3(1, 1, 1);
			Payload.SpecularColor = float3(0, 0, 0);
			Payload.Specular = 0;
			Payload.Roughness = 1;
			Payload.Metallic = 0;
			Payload.Ior = 1;
			Payload.CustomData = float4(0, 0, 0, 0);
			Payload.Opacity = 1;
			Payload.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
			Payload.BlendingMode = RAY_TRACING_BLEND_MODE_OPAQUE;
			Payload.PrimitiveLightingChannelMask = 0b111;
			Payload.HitT = 1.0f;
			Payload.SetFrontFace();
		}
		else
		{
			Ray.TMin = 0.01;
			Ray.TMax = 1e20;
		
			Payload = TraceMaterialRay(
				TLAS,
				InitialRayFlags,
				RAY_TRACING_MASK_ALL,
				Ray,
				RayCone,
				uint2(0, 0),
				bInitialDisableSkyLightContribution,
				bIgnoreTranslucentMaterials);
		}
		
		if (MISMode != 1 && Bounce != 0) // In GPULightmass it is not possible to hit any light on its first fake ray
		{
			float HitT = Payload.IsMiss() ? Ray.TMax : Payload.HitT;
			// Loop over lights to capture their contribution
			// #dxr_todo: if we have lots of lights, having some hierarchical structure would be better ....
			float PreviousCdfValue = 0.0;
			for (uint LightId = 0; LightId < SceneLightsData.Count; ++LightId)
			{
				// Camera rays should only do the rest of the loop if we have visible lights OR if
				// we have a skydome (which are always visible)
				if (Bounce == 0 && !IsEnvironmentLight(LightId))
					continue;

				float4 LightResult = TraceLight(Ray, LightId, HitT);
				float3 LightRadiance = LightResult.xyz;
				float LightPdf = LightResult.w;

				float LightPickPdf = LightPickingCdf[LightId] - PreviousCdfValue;
				PreviousCdfValue = LightPickingCdf[LightId];

				// GPULightmass records direct contribution for only static lights
				if (Bounce > 1 || (Bounce == 1 && SceneLightsData.Mobility[LightId] == 0))
				{
					AccumulateRadiance(Radiance, PathThroughput * LightRadiance * MISWeightRobust(PrevMaterialPdf, LightPdf * LightPickPdf));
				}
			}
		}
		
		if (Payload.IsMiss())
		{
			// Ray didn't hit any real geometry, so nothing left to do
			break;
		}
		
		if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
		{
			bIsValidSample = false;
			break;
		}
	
		// add in surface emission
		AccumulateRadiance(Radiance, PathThroughput * Payload.Radiance);
		
	#if USE_IRRADIANCE_CACHING
		uint CoarseLevelSpacing = IrradianceCachingParameters.Spacing;
		uint DetailLevelSpacing = IrradianceCachingParameters.Spacing;
		
		if (Bounce >= 1 && Payload.HitT >= DetailLevelSpacing * IrradianceCachingParameters.CornerRejection && !bShouldAccumulateToCacheRecord)
		{
			bool bIrradianceQuerySuccessful = false;
			bool bGeometryQuerySuccessful = false;
			
			uint NearestRecordIndex = 0;
			float3 RecordIrradiance;
			float3 RecordWorldNormal;
			
			uint3 Key = EncodeVoxelKey(floor((Ray.Origin + Ray.Direction * Payload.HitT) / (Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing)));
			uint NormalDirectionBits = EncodeNormalBits(Payload.WorldNormal);			
			uint HashKey = 0;
			HashKey = MurmurAdd( HashKey, Key.x );
			HashKey = MurmurAdd( HashKey, Key.y );
			HashKey = MurmurAdd( HashKey, Key.z );
			HashKey = MurmurAdd( HashKey, NormalDirectionBits );
			HashKey = MurmurAdd( HashKey, Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing );
			uint Index;
			if (ICHashTableFind(HashKey, Index))
			{
				uint RecordIndex = IrradianceCachingParameters.RWHashToIndex[Index];
				FIrradianceCacheRecord Record = IrradianceCachingParameters.IrradianceCacheRecords[RecordIndex];
				if (Record.Irradiance.w > IrradianceCachingParameters.Quality)
				{
					bIrradianceQuerySuccessful = true;
					
					RecordIrradiance = asfloat(Record.Irradiance.xyz) / Record.Irradiance.w;
				}
				
				bGeometryQuerySuccessful = true;
				RecordWorldNormal = Record.WorldNormal.xyz;
				NearestRecordIndex = RecordIndex;
			}
	
			if (bIrradianceQuerySuccessful)
			{
				// Successful query. Terminate path immediately. Can happen when accumulating for IC entries.
				Radiance += RecordIrradiance * PathThroughput;
				break;
			}
			else
			{
				// Failed query.
				if (Bounce == 1)
				{
					if (!bGeometryQuerySuccessful)
					{
						bShouldEmitGeometryHitPoint = true;
						IrradianceCachePrimaryGIHitPoint.WorldPosition.xyz = Ray.Origin + Ray.Direction * Payload.HitT;
						IrradianceCachePrimaryGIHitPoint.WorldNormal.xyz = Payload.WorldNormal;
						NewEntrySize = Payload.HitT >= CoarseLevelSpacing ? CoarseLevelSpacing : DetailLevelSpacing;
					}
					else
					{
						bShouldAccumulateToCacheRecord = true;
						NearestCacheEntryID = NearestRecordIndex;
					}
				}
			}
		}
	#endif
	
		// Update origin
		Ray.Origin = Payload.WorldPos;

		// Make sure the surface normal points toward the viewer
		if (dot(Ray.Direction, Payload.WorldNormal) > 0.0)
		{
			bIsValidSample = false;
			break;
		}

		// Choose a random number for both Light sampling and BxDF sampling
		float4 RandSample = RandomSequence_GenerateSample4D(RandSequence);

		// Does this material require NEE?
		bool bIsNeeValid = IsNeeValidMaterial(Payload);
		
		// If we are using Light sampling and we are not on the last bounce ....
		if (MISMode != 0 && Bounce < 32 && bIsNeeValid && SceneLightsData.Count > 0)
		{
			// Choose a light and sample it

			float3 WorldPos = Payload.WorldPos;
			float3 WorldNormal = Payload.WorldNormal;
			uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;

			bool IsTransmissiveMaterial = false; // ENABLE_TRANSMISSION && IsMaterialTransmissive(Payload);
			
			if (InitLightPickingCdf(WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial, LightPickingCdf))
			{
				// init worked
				int LightId;
				float LightPickPdf = 0;

				SelectLight(RandSample.x, LightPickingCdf, LightId, LightPickPdf);

				RayDesc LightRay;
				LightRay.Origin = WorldPos;
				LightRay.TMin = 0;
				float3 RadianceOverPdf;
				float LightPdf;
				SampleLight(LightId, RandSample, WorldPos, WorldNormal,
					LightRay.Direction,
					LightRay.TMax,
					RadianceOverPdf,
					LightPdf);
				RadianceOverPdf /= LightPickPdf;
				LightPdf *= LightPickPdf;

				if (LightPdf > 0)
				{
					float SignedPositionBias = 1.0;
					if (ENABLE_TRANSMISSION && IsMaterialTransmissive(Payload))
					{
						// for transmissive materials, bias the position to the other side of the surface if the light is coming from behind
						float NoL = dot(Payload.WorldNormal, LightRay.Direction);
						SignedPositionBias = sign(NoL);
					}
					ApplyPositionBias(LightRay, SignedPositionBias * Payload.WorldNormal, 0.01f);


					const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint InstanceInclusionMask = RAY_TRACING_MASK_ALL;

					FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;

					TraceVisibilityRayPacked(PackedPayload, TLAS, RayFlags, InstanceInclusionMask, uint2(0, 0), LightRay);

					// #dxr_todo: Is it cheaper to fire the ray first? Or eval the material first?
					if (PackedPayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialWeight;
						float MaterialPdf = 0.0;
						EvalMaterial(Ray.Direction, LightRay.Direction, Payload, Bounce == 0, MaterialWeight, MaterialPdf);

						float3 MaterialEval = MaterialWeight * MaterialPdf;

						float MISWeight = MISMode == 2 ? MISWeightRobust(LightPdf, MaterialPdf) : 1.0;

						// Record the contribution
						if (Bounce > 0)
						{
							AccumulateRadiance(Radiance, MISWeight * PathThroughput * RadianceOverPdf * MaterialEval);
						}
						else
						{
							// GPULightmass records contribution of direct lighting separately, and only for static lights
							if (SceneLightsData.Mobility[LightId] == 0)
							{
								DirectLightingNEERadianceValue += MISWeight * PathThroughput * RadianceOverPdf * MaterialEval;
								DirectLightingNEERadianceDirection = LightRay.Direction;
							}
						}
					}
				}
			}
		}

		if (Bounce == 32)
		{
			// we've arrived at the last bounce, don't bother trying to sample a direction
			break;
		}
	
		// Sample material
		float3 Direction;
		float3 MaterialWeight;
		float SignedPositionBias;
		float MaterialSamplePdf;
		SampleMaterial(Ray.Direction, Payload, RandSample, Bounce == 0, Direction, MaterialWeight, MaterialSamplePdf, SignedPositionBias);

		if (MaterialSamplePdf < 0 || asuint(MaterialSamplePdf) > 0x7F800000)
		{
			// Pdf became invalid (either negative or NaN)
			bIsValidSample = false;
			break;
		}

		if (!(MaterialSamplePdf > 0))
		{
			// No valid direction -- we are done
			break;
		}

		float3 NextPathThroughput = PathThroughput * MaterialWeight;
		if (!any(NextPathThroughput > 0))
		{
			// no energy left in this path
			break;
		}

		// Russian roulette:
		//   The probability of keeping the path should be roughly proportional to the weight at the current shade point,
		//  but just using MaterialWeight would miss out on cases where the path throughput changes color (like in a cornell
		//  box when bouncing between walls of different colors). So use the ratio of the brightest color channel in the
		//  previous and next throughput.
		//   The second tweak is to add a sqrt() around the probability to soften the termination probability (paths will last
		//  a little longer). This allows paths to go a bit deeper than the naive heuristic while still allowing them to terminate
		//  early. This makes RR effective from the very first bounce without needing to delay it.
		float ContinuationProb = sqrt(saturate(max(NextPathThroughput.x, max(NextPathThroughput.y, NextPathThroughput.z)) / max(PathThroughput.x, max(PathThroughput.y, PathThroughput.z))));
		if (ContinuationProb < 1)
		{
			// If there is some chance we should terminate the ray, draw an extra random value
			float RussianRouletteRand = RandSample.w; // SampleMaterial does not use this value at the moment
			//RussianRouletteRand = RandomSequence_GenerateSample1D(RandSequence);
			if (RussianRouletteRand >= ContinuationProb)
			{
				// stochastically terminate the path
				break;
			}
			PathThroughput = NextPathThroughput / ContinuationProb;
		}
		else
		{
			PathThroughput = NextPathThroughput;
		}

		if (MISMode == 2)
		{
			// If we are doing MIS, the Material ray on the next loop through will need to know the Pdf
			PrevMaterialPdf = MaterialSamplePdf;
		}

		// Update ray and loop back around to trace again
		Ray.Direction = Direction;
		Ray.TMin = 0;
		ApplyPositionBias(Ray, SignedPositionBias* Payload.WorldNormal, 0.01f);
		
		if (Bounce == 0)
		{
			RadianceDirection = Ray.Direction;
		#if USE_IRRADIANCE_CACHING
			RadianceProbe_Pdf = MaterialSamplePdf;
		#endif
			PrimaryRandSample = RandSample;
		}
	}

#if USE_IRRADIANCE_CACHING
	if(bIsValidSample)
	{
		if(bShouldEmitGeometryHitPoint)
		{
			EmitGeometryHitPoint(IrradianceCachePrimaryGIHitPoint, NewEntrySize);
		}
		
		if(bShouldAccumulateToCacheRecord)
		{
			float3 IrradianceToAccumulate = Radiance * RadianceProbe_Pdf; // Revert the radiance probe pdf as we're caching the first bounce outgoing radiance
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.r, IrradianceToAccumulate.r);
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.g, IrradianceToAccumulate.g);
			ATOMIC_ADD_FLOAT(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.b, IrradianceToAccumulate.b);
			InterlockedAdd(IrradianceCachingParameters.IrradianceCacheRecords[NearestCacheEntryID].Irradiance.a, 1);
		}
	}
#endif
	
	RadianceValue = Radiance;
}

[shader("raygeneration")]
void LightmapPathTracingMainRG()
{
	uint2 BatchedLaunchIndex = DispatchRaysIndex().xy;

	uint2 LaunchIndex = uint2(BatchedLaunchIndex.x % GPreviewLightmapPhysicalTileSize, BatchedLaunchIndex.y);
	int TileIndex = BatchedLaunchIndex.x / GPreviewLightmapPhysicalTileSize;
	uint2 TexelIndexInPool = LaunchIndex + BatchedTiles[TileIndex].WorkingSetPosition;
	uint2 TexelIndexInScratch = LaunchIndex + BatchedTiles[TileIndex].ScratchPosition;

	float3 WorldPosition = GBufferWorldPosition[TexelIndexInScratch].xyz / WorldPositionScalar;
	float3 WorldNormal = GBufferWorldNormal[TexelIndexInScratch].xyz;
	float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz;

	bool bIsValidSample = true;
	
	if (GBufferWorldPosition[TexelIndexInScratch].w == 0.0f) bIsValidSample = false;
	
	if (NumTotalSamples <= 0 || (NumTotalSamples > 0 && BatchedTiles[TileIndex].RenderPassIndex < NumTotalSamples - 1))
	{
		if (bIsValidSample)
		{			
			// Needs a seed that is only related to position in virtual space to avoid seams due to per-tile calculation
			uint2 VirtualTextureSpacePosition = BatchedTiles[TileIndex].VirtualTilePosition + LaunchIndex - uint2(2, 2);
			uint Seed = VirtualTextureSpacePosition.y * BatchedTiles[TileIndex].LightmapSize.x + VirtualTextureSpacePosition.x;
					
			float4 PrimaryRandSample = float4(-1, -1, -1, -1);
			
			{
				RandomSequence RandSequence;
				RandomSequence_Initialize(RandSequence, Seed, 
				#if USE_FIRST_BOUNCE_RAY_GUIDING
					BatchedTiles[TileIndex].RenderPassIndex >= NumRayGuidingTrialSamples ? 
						(BatchedTiles[TileIndex].RenderPassIndex - NumRayGuidingTrialSamples) : 
				#endif
						(BatchedTiles[TileIndex].RenderPassIndex)
				);
				
				uint SampleIndex = 2;

				float3 RadianceValue = 0;
				float3 RadianceDirection = 0;				
				float3 DirectLightingNEERadianceValue = 0;
				float3 DirectLightingNEERadianceDirection = 0;
				
				if (bIsValidSample)
				{
					PathTracingKernel(
						BatchedTiles[TileIndex].RenderPassIndex,
						WorldPosition,
						WorldNormal,
						RandSequence,
						SampleIndex,
						bIsValidSample,
						RadianceValue,
						RadianceDirection,
						DirectLightingNEERadianceValue,
						DirectLightingNEERadianceDirection,
						PrimaryRandSample
					);
				}
				
				if (any(isnan(RadianceValue)) || any(RadianceValue < 0) || any(isinf(RadianceValue)))
				{
					bIsValidSample = false;
				}
				
				if (bIsValidSample)
				{
					#if USE_FIRST_BOUNCE_RAY_GUIDING						
						if (BatchedTiles[TileIndex].RenderPassIndex < NumRayGuidingTrialSamples)
						{
							int2 ClusterPosition = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) / TEXEL_CLUSTER_SIZE;
							float2 JitteredBin = PrimaryRandSample * DIRECTIONAL_BINS_ONE_DIM;// - float2(0.5f, 0.5f) + PrimaryRandSample.zw;
							int2 PositionInBin = clamp(JitteredBin, float2(0, 0), float2(DIRECTIONAL_BINS_ONE_DIM - 1, DIRECTIONAL_BINS_ONE_DIM - 1));
							int2 FinalPosition = ClusterPosition * DIRECTIONAL_BINS_ONE_DIM + PositionInBin;
							float Illuminance = Luminance(RadianceValue) * saturate(dot(RadianceDirection, ShadingNormal));
							// For positive floats we can cast them to uint and use atomic max directly
							InterlockedMax(RayGuidingLuminance[BatchedTiles[TileIndex].WorkingSetPosition / GPreviewLightmapPhysicalTileSize * CDF_TILE_SIZE + FinalPosition], asuint(max(Illuminance, 0)));
						}
					
						if (BatchedTiles[TileIndex].RenderPassIndex == NumRayGuidingTrialSamples) 
						{
							IrradianceAndSampleCount[TexelIndexInPool]= float4(0, 0, 0, 0);
							SHDirectionality[TexelIndexInPool] = float4(0, 0, 0, 0);
							SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 0;
						}
					#endif
					
					{
						FL2SHAndCorrection SH = (FL2SHAndCorrection)0;
						
						float TangentZ = saturate(dot(RadianceDirection, ShadingNormal));
						SH.AddIncomingRadiance(Luminance(RadianceValue), RadianceDirection, TangentZ);
						
						IrradianceAndSampleCount[TexelIndexInPool].rgb += float3(RadianceValue * TangentZ / PI);
						SHDirectionality[TexelIndexInPool] += SH.L2SHCoefficients;					
						SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x += SH.Correction;
					}
					
					{
						FL2SHAndCorrection SH = (FL2SHAndCorrection)0;
						
						float TangentZ = saturate(dot(DirectLightingNEERadianceDirection, ShadingNormal));
						SH.AddIncomingRadiance(Luminance(DirectLightingNEERadianceValue), DirectLightingNEERadianceDirection, TangentZ);
						
						IrradianceAndSampleCount[TexelIndexInPool].rgb += float3(DirectLightingNEERadianceValue * TangentZ / PI);
						SHDirectionality[TexelIndexInPool] += SH.L2SHCoefficients;					
						SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x += SH.Correction;
					}
				}
			}
		}

		uint SampleCount = asuint(IrradianceAndSampleCount[TexelIndexInPool].w);

#if 0 // Smooth invalidation. This path is currently disabled to avoid inconsistency when saving baked results.
		if (BatchedTiles[TileIndex].FrameIndex < LastInvalidationFrame)
		{
			if (SampleCount > 0)
			{
				float L = Luminance(IrradianceAndSampleCount[TexelIndexInPool].rgb / SampleCount);
				int HistoryWeight = 2.0f / (1.0f + L * L);
				IrradianceAndSampleCount[TexelIndexInPool].rgb = IrradianceAndSampleCount[TexelIndexInPool].rgb / SampleCount * HistoryWeight;
				SHDirectionality[TexelIndexInPool] = SHDirectionality[TexelIndexInPool] / SampleCount * HistoryWeight;
				SampleCount = HistoryWeight;
			}
		}
#endif
		
		if (bIsValidSample)
			SampleCount++;
		
		IrradianceAndSampleCount[TexelIndexInPool].a = asfloat(SampleCount);
	}
			
	#if 0 // Debug: Ray guiding PDF visualization
		{
			int2 ClusterPosition = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) / TEXEL_CLUSTER_SIZE;
			int2 PositionInBin = clamp((int2)LaunchIndex - int2(2, 2), int2(0, 0), int2(63, 63)) % DIRECTIONAL_BINS_ONE_DIM;
			int2 FinalPosition = ClusterPosition * DIRECTIONAL_BINS_ONE_DIM + PositionInBin;

			IrradianceAndSampleCount[TexelIndexInPool].rgb = (
				asfloat(RayGuidingCDF[BatchedTiles[TileIndex].WorkingSetPosition / GPreviewLightmapPhysicalTileSize * CDF_TILE_SIZE + LaunchIndex]).xxx / (1 + asuint(IrradianceAndSampleCount[TexelIndexInPool].a))
			);
			
			SHDirectionality[TexelIndexInPool] = float4(1, 0, 0, 0);					
			SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 1;
		}
	#endif

#if 0 // Debug: GBuffer shading normal visualization	
	{
		const half LogBlackPoint = 0.01858136;
	
		float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz * 0.5f + 0.5f;
		
		IrradianceAndSampleCount[TexelIndexInPool].rgb = ShadingNormal;
		IrradianceAndSampleCount[TexelIndexInPool].a = asfloat(1);
		
		SHDirectionality[TexelIndexInPool] = float4(1, 0, 0, 0);					
		SHCorrectionAndStationarySkyLightBentNormal[TexelIndexInPool].x = 1;
	}
#endif
}

#include "BrickAllocationDefs.ush"

uint FrameNumber;
float4 VolumeMin;
float4 VolumeSize;
int3 IndirectionTextureDim;
Texture3D<uint4> IndirectionTexture;
Buffer<uint4> BrickRequests;
int NumTotalBricks;
int BrickBatchOffset;

RWTexture3D<float4> AmbientVector;
RWTexture3D<float4> SHCoefficients0R;
RWTexture3D<float4> SHCoefficients1R;
RWTexture3D<float4> SHCoefficients0G;
RWTexture3D<float4> SHCoefficients1G;
RWTexture3D<float4> SHCoefficients0B;
RWTexture3D<float4> SHCoefficients1B;

uint MortonEncode3(uint3 Pixel)
{
	uint Morton = MortonCode3(Pixel.x & 0xFF) | (MortonCode3(Pixel.y & 0xFF) << 1) | (MortonCode3(Pixel.z & 0xFF) << 1);
	return Morton;
}

[shader("raygeneration")]
void VolumetricLightmapPathTracingMainRG()
{
	uint BrickVolumeSize = 5 * 5 * 5;
	uint BrickIndex = DispatchRaysIndex().x / BrickVolumeSize + BrickBatchOffset;
	if (BrickIndex >= NumTotalBricks) return;
	uint CellIndex = DispatchRaysIndex().x % BrickVolumeSize;
	uint3 CellPosInBrick = ComputeBrickLayoutPosition(CellIndex, uint3(5, 5, 5));
	
	bool bIsValidSample = true;	
	
	int3 CellPosInVLM = (BrickRequests[BrickIndex].xyz * 4 + CellPosInBrick) * BrickRequests[BrickIndex].w;	
	uint Seed = ComputeBrickLinearAddress(CellPosInVLM, IndirectionTextureDim * 4);
	
	#if 0
		float3 Jitter = RandomSequence_GenerateSample3D(RandSequence);
	#else
		float3 RandSample = float3(
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 2), 
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 3),
			Halton(MortonEncode3(CellPosInVLM) + FrameNumber / 2, 5)
		);
		float3 Jitter = RandSample;
	#endif		
	
	float3 JitteredCellPosInVLM = (BrickRequests[BrickIndex].xyz * 4 + CellPosInBrick + Jitter - float3(0.5, 0.5, 0.5)) * BrickRequests[BrickIndex].w;	
	float DetailCellSize = VolumeSize.xyz / IndirectionTextureDim / 4;
	float3 WorldPosition = VolumeMin + DetailCellSize * JitteredCellPosInVLM;
	float3 ShadingNormal = float3(0, 0, (FrameNumber % 2 == 0) ? 1 : -1);

	float3 RadianceValue = 0;
	float3 RadianceDirection = 0;				
	float3 DirectLightingNEERadianceValue = 0;
	float3 DirectLightingNEERadianceDirection = 0;
	float4 PrimaryRandSample;

	if (bIsValidSample)
	{
		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, Seed, FrameNumber / 2);	
		uint SampleIndex = 4;
		
		PathTracingKernel(
			FrameNumber,
			WorldPosition,
			ShadingNormal,
			RandSequence,
			SampleIndex,
			bIsValidSample,
			RadianceValue,
			RadianceDirection,
			DirectLightingNEERadianceValue,
			DirectLightingNEERadianceDirection,
			PrimaryRandSample);
	}
	
	// Every even sample is upper hemisphere, odd sample is lower hemisphere
	// SampleCount stored is twice as the actual full sphere sample count
	RadianceValue *= 2;
	DirectLightingNEERadianceValue *= 2;

	if (any(isnan(RadianceValue)) || any(RadianceValue < 0))
	{
		bIsValidSample = false;
	}

	uint PaddedBrickSize = 4 + 1;
	uint3 VoxelPos = ComputeBrickLayoutPosition(BrickIndex, uint3(256, 256, 256)) * PaddedBrickSize + CellPosInBrick;

	if (FrameNumber == 0)
	{
		AmbientVector[VoxelPos] = float4(0, 0, 0, 0);
		
		SHCoefficients0R[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1R[VoxelPos] = float4(0, 0, 0, 0);
		
		SHCoefficients0G[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1G[VoxelPos] = float4(0, 0, 0, 0);		
		
		SHCoefficients0B[VoxelPos] = float4(0, 0, 0, 0);
		SHCoefficients1B[VoxelPos] = float4(0, 0, 0, 0);
	}
	
	if (bIsValidSample)
	{
		uint SampleCount = asuint(AmbientVector[VoxelPos].w);
		
		{
			FThreeBandSHVectorRGBFloat SH;
			SH.R.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.r;
			SH.R.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.r;
			SH.R.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.r;
			SH.G.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.g;
			SH.G.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.g;
			SH.G.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.g;
			SH.B.V0 = SHBasisFunction3Float(RadianceDirection).V0 * RadianceValue.b;
			SH.B.V1 = SHBasisFunction3Float(RadianceDirection).V1 * RadianceValue.b;
			SH.B.V2 = SHBasisFunction3Float(RadianceDirection).V2 * RadianceValue.b;
			
			AmbientVector[VoxelPos].x += SH.R.V0.x;
			AmbientVector[VoxelPos].y += SH.G.V0.x;
			AmbientVector[VoxelPos].z += SH.B.V0.x;
			
			SHCoefficients0R[VoxelPos] += float4(SH.R.V0.yzw, SH.R.V1.x);
			SHCoefficients1R[VoxelPos] += float4(SH.R.V1.yzw, SH.R.V2);
			
			SHCoefficients0G[VoxelPos] += float4(SH.G.V0.yzw, SH.G.V1.x);
			SHCoefficients1G[VoxelPos] += float4(SH.G.V1.yzw, SH.G.V2);		
			
			SHCoefficients0B[VoxelPos] += float4(SH.B.V0.yzw, SH.B.V1.x);
			SHCoefficients1B[VoxelPos] += float4(SH.B.V1.yzw, SH.B.V2);
		}
		
		{
			FThreeBandSHVectorRGBFloat SH;
			SH.R.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.r;
			SH.R.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.r;
			SH.R.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.r;
			SH.G.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.g;
			SH.G.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.g;
			SH.G.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.g;
			SH.B.V0 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V0 * DirectLightingNEERadianceValue.b;
			SH.B.V1 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V1 * DirectLightingNEERadianceValue.b;
			SH.B.V2 = SHBasisFunction3Float(DirectLightingNEERadianceDirection).V2 * DirectLightingNEERadianceValue.b;
			
			AmbientVector[VoxelPos].x += SH.R.V0.x;
			AmbientVector[VoxelPos].y += SH.G.V0.x;
			AmbientVector[VoxelPos].z += SH.B.V0.x;
			
			SHCoefficients0R[VoxelPos] += float4(SH.R.V0.yzw, SH.R.V1.x);
			SHCoefficients1R[VoxelPos] += float4(SH.R.V1.yzw, SH.R.V2);
			
			SHCoefficients0G[VoxelPos] += float4(SH.G.V0.yzw, SH.G.V1.x);
			SHCoefficients1G[VoxelPos] += float4(SH.G.V1.yzw, SH.G.V2);		
			
			SHCoefficients0B[VoxelPos] += float4(SH.B.V0.yzw, SH.B.V1.x);
			SHCoefficients1B[VoxelPos] += float4(SH.B.V1.yzw, SH.B.V2);
		}
		
		AmbientVector[VoxelPos].w = asfloat(SampleCount + 1);
	}
}

// Must match C++
struct FLightShaderConstants
{
	float3 Position;
	float  InvRadius;
	float3 Color;
	float  FalloffExponent;
	float3 Direction;
	float  SpecularScale;
	float3 Tangent;
	float  SourceRadius;
	float2 SpotAngles;
	float  SoftSourceRadius;
	float  SourceLength;
	float  RectLightBarnCosAngle;
	float  RectLightBarnLength;
	
	void FillLightShaderParameters(inout FLightShaderParameters LightShaderParameters)
	{
		LightShaderParameters.Position = Position;
		LightShaderParameters.InvRadius = InvRadius;
		LightShaderParameters.Color = Color;
		LightShaderParameters.FalloffExponent = FalloffExponent;
		LightShaderParameters.Direction = Direction;
		LightShaderParameters.SpecularScale = SpecularScale;
		LightShaderParameters.Tangent = Tangent;
		LightShaderParameters.SourceRadius = SourceRadius;
		LightShaderParameters.SpotAngles = SpotAngles;
		LightShaderParameters.SoftSourceRadius = SoftSourceRadius;
		LightShaderParameters.SourceLength = SourceLength;
		LightShaderParameters.RectLightBarnCosAngle = RectLightBarnCosAngle;
		LightShaderParameters.RectLightBarnLength = RectLightBarnLength;
	}
};

Buffer<int> LightTypeArray;
Buffer<int> ChannelIndexArray;
Buffer<int> LightSampleIndexArray;
StructuredBuffer<FLightShaderConstants> LightShaderParametersArray;
RWTexture2D<float4> ShadowMask;
RWTexture2D<float4> ShadowMaskSampleCount;

#define LIGHT_TYPE_DIRECTIONAL		0 
#define LIGHT_TYPE_POINT			1 
#define LIGHT_TYPE_SPOT				2 
#define LIGHT_TYPE_RECT				3 
#define LIGHT_TYPE_MAX				4 

bool GenerateOcclusionRay(
	int LightType,
	FLightShaderParameters LightParameters,
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	inout float3 RayOrigin,
	inout float3 RayDirection,
	inout float RayTMin,
	inout float RayTMax
)
{
	if (LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		GenerateDirectionalLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax);
	}
	else if (LightType == LIGHT_TYPE_POINT)
	{
		if (LightParameters.SourceRadius == 0)
		{
			return GeneratePointLightOcclusionRay(
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ RayOrigin,
				/* out */ RayDirection,
				/* out */ RayTMin,
				/* out */ RayTMax);
		}
		else
		{
			float RayPdf;
			return GenerateSphereLightOcclusionRayWithSolidAngleSampling(
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ RayOrigin,
				/* out */ RayDirection,
				/* out */ RayTMin,
				/* out */ RayTMax,
				/* out */ RayPdf);
		}
	}
	else if (LightType == LIGHT_TYPE_SPOT)
	{
		return GenerateSpotLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax);
	}
	else if (LightType == LIGHT_TYPE_RECT)
	{
		float RayPdf = 0.0;
		return GenerateRectLightOcclusionRay(
			LightParameters,
			WorldPosition, WorldNormal,
			RandSample,
			/* out */ RayOrigin,
			/* out */ RayDirection,
			/* out */ RayTMin,
			/* out */ RayTMax,
			/* out */ RayPdf);
	}

	return true;
}

[shader("raygeneration")]
void StationaryLightShadowTracingMainRG()
{
	uint2 BatchedLaunchIndex = DispatchRaysIndex().xy;

	uint2 LaunchIndex = uint2(BatchedLaunchIndex.x % GPreviewLightmapPhysicalTileSize, BatchedLaunchIndex.y);
	int TileIndex = BatchedLaunchIndex.x / GPreviewLightmapPhysicalTileSize;
	uint2 TexelIndexInPool = LaunchIndex + BatchedTiles[TileIndex].WorkingSetPosition;
	uint2 TexelIndexInScratch = LaunchIndex + BatchedTiles[TileIndex].ScratchPosition;

	int ChannelIndex = ChannelIndexArray[TileIndex];

	bool bIsValidSample = true;
	
	float3 WorldPosition = GBufferWorldPosition[TexelIndexInScratch].xyz / WorldPositionScalar;	
	if (GBufferWorldPosition[TexelIndexInScratch].w == 0.0f)
	{
		bIsValidSample = false;
	}
	
	if (bIsValidSample)
	{
		float3 WorldNormal = GBufferWorldNormal[TexelIndexInScratch].xyz;
		float3 ShadingNormal = GBufferShadingNormal[TexelIndexInScratch].xyz;
		
		// Needs a seed that is only related to position in virtual space to avoid seams due to per-tile calculation
		uint2 VirtualTextureSpacePosition = BatchedTiles[TileIndex].VirtualTilePosition + LaunchIndex - uint2(2, 2);
		uint Seed = VirtualTextureSpacePosition.y * BatchedTiles[TileIndex].LightmapSize.x + VirtualTextureSpacePosition.x;
		
		int LightType = LightTypeArray[TileIndex];
		FLightShaderParameters LightParameters;
		LightShaderParametersArray[TileIndex].FillLightShaderParameters(LightParameters);
		
		{
			float2 RandSample = float2(
				Halton(IntegerHash(Seed) + LightSampleIndexArray[TileIndex], 5), 
				Halton(IntegerHash(Seed) + LightSampleIndexArray[TileIndex], 7)
			);
			
			RayDesc Ray;
			bIsValidSample &= GenerateOcclusionRay(
				LightType,
				LightParameters,
				WorldPosition, WorldNormal,
				RandSample,
				/* out */ Ray.Origin,
				/* out */ Ray.Direction,
				/* out */ Ray.TMin,
				/* out */ Ray.TMax);
				
			Ray.Origin += Ray.Direction * 0.01f;
				
			if (bIsValidSample)
			{
				uint RayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;

				FMinimalPayload MinimalPayload = TraceVisibilityRay(
					TLAS,
					RayFlags,
					RAY_TRACING_MASK_SHADOW,
					uint2(0, 0),
					Ray);
				
				uint Visibility = asuint(ShadowMask[TexelIndexInPool][ChannelIndex]);
				uint SampleCount = asuint(ShadowMaskSampleCount[TexelIndexInPool][ChannelIndex]);
				Visibility += MinimalPayload.IsMiss() ? 1 : 0;
				SampleCount++;
				ShadowMask[TexelIndexInPool][ChannelIndex] = asfloat(Visibility);
				ShadowMaskSampleCount[TexelIndexInPool][ChannelIndex] = asfloat(SampleCount);
			}
		}
	}
}
