// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "StaticMeshComponentBuilder.h"
#include "Engine/StaticMesh.h"
#include "Engine/StaticMeshActor.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/CollisionProfile.h"
#include "PhysicsEngine/BodySetup.h"
#include "MeshDescription.h"


/**
 * FStaticMeshComponentBuilder is a utility class that can build a
 * proper UStaticMeshComponent.
 */
class FStaticMeshComponentBuilder
{
public:
	/** We will create this UStaticMesh */
	UStaticMesh* NewStaticMesh = nullptr;

	/** This MeshDescription will be generated by calling NewStaticMesh->CreateMeshDescription(0) */
	FMeshDescription* MeshDescription = nullptr;

	/** We will create this component and set NewStaticMesh as it's mesh */
	UStaticMeshComponent* NewMeshComponent = nullptr;


	/**
	 * Call this to create and configure NewStaticMesh and MeshDescription
	 * @param AssetPackage The asset package that the UStaticMesh will be saved into
	 * @param MeshName the name of the mesh asset
	 * @param NumMaterialSlots the number of material slots to create on the static mesh -- if the staticmesh does not have enough slots, corresponding override materials on the staticmeshcomponent will be discarded
	 */
	inline void Initialize(UPackage* AssetPackage, FName MeshName, int NumMaterialSlots = 1)
	{
		// create new UStaticMesh object
		EObjectFlags flags = EObjectFlags::RF_Public | EObjectFlags::RF_Standalone;
		this->NewStaticMesh = NewObject<UStaticMesh>(AssetPackage, MeshName, flags);

		// initialize the LOD 0 MeshDescription
		NewStaticMesh->SetNumSourceModels(1);
		NewStaticMesh->GetSourceModel(0).BuildSettings.bRecomputeNormals = false;
		NewStaticMesh->GetSourceModel(0).BuildSettings.bRecomputeTangents = true;
		this->MeshDescription = NewStaticMesh->CreateMeshDescription(0);

		if (NewStaticMesh->GetBodySetup() == nullptr)
		{
			NewStaticMesh->CreateBodySetup();
		}
		if (NewStaticMesh->GetBodySetup() != nullptr)
		{
			// enable complex as simple collision to use mesh directly
			NewStaticMesh->GetBodySetup()->CollisionTraceFlag = ECollisionTraceFlag::CTF_UseComplexAsSimple;
		}

		// add a material slot. Must always have one material slot.
		int AddMaterialCount = FMath::Max(1, NumMaterialSlots);
		for (int MatIdx = 0; MatIdx < AddMaterialCount; MatIdx++)
		{
			NewStaticMesh->GetStaticMaterials().Add(FStaticMaterial());
		}
	}




	// 3) Create NewMeshComponent and add to Actor
	/**
	 * Create/Locate NewMeshComponent and assign NewStaticMesh to it, and then add it to the Actor.
	 * If Actor is a AStaticMeshActor instance, then NewMeshComponent will be it's existing StaticMeshComponent, and we will assign NewStaticMesh to it.
	 * Otherwise, we create new StaticMeshComponent, assign NewStaticMesh, and set it as the Root Component of the Actor
	 */
	inline void CreateAndSetAsRootComponent(AActor* Actor)
	{
		// assuming we have updated the LOD 0 MeshDescription, tell UStaticMesh about this
		NewStaticMesh->CommitMeshDescription(0);

		// if we have a StaticMeshActor we already have a StaticMeshComponent, otherwise we 
		// need to make a new one. Note that if we make a new one it will not be editable in the 
		// Editor because it is not a UPROPERTY...
		AStaticMeshActor* StaticMeshActor = Cast<AStaticMeshActor>(Actor);
		if (StaticMeshActor != nullptr)
		{
			NewMeshComponent = StaticMeshActor->GetStaticMeshComponent();
		}
		else
		{
			// create component
			NewMeshComponent = NewObject<UStaticMeshComponent>(Actor);
			Actor->SetRootComponent(NewMeshComponent);
		}

		// this disconnects the component from various events
		NewMeshComponent->UnregisterComponent();

		// Configure flags of the component. Is this necessary?
		NewMeshComponent->SetMobility(EComponentMobility::Movable);
		NewMeshComponent->bSelectable = true;

		// replace the UStaticMesh in the component
		NewMeshComponent->SetStaticMesh(NewStaticMesh);

		// UActorFactoryBasicShape::PostSpawnActor does this...what for??
		//NewMeshComponent->StaticMeshDerivedDataKey = StaticMesh->RenderData->DerivedDataKey;

		// call this to set a different default material. WorldMaterial shows UV so is more useful...
		//UMaterialInterface* Material = LoadObject<UMaterial>(nullptr, TEXT("/Engine/BasicShapes/BasicShapeMaterial.BasicShapeMaterial"));
		//check(Material != nullptr);
		//NewMeshComponent->SetMaterial(0, Material);

		// re-connect the component (?)
		NewMeshComponent->RegisterComponent();

		// not sure what this does...marks things dirty? updates stuff after modification??
		NewStaticMesh->PostEditChange();

		// do we need to do this?
		//NewMeshComponent->PostEditChange();

		// do we need to do any of these? or is default collision profile sufficient?
		//NewStaticMesh->BodySetup->DefaultInstance.SetCollisionProfileName(UCollisionProfile::BlockAll_ProfileName);
		//NewMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
		//NewMeshComponent->SetCollisionProfileName(UCollisionProfile::BlockAll_ProfileName);

		// if we don't do this, world traces don't hit the mesh
		NewMeshComponent->RecreatePhysicsState();
	}
};
