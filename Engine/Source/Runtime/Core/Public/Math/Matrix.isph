// Copyright Epic Games, Inc. All Rights Reserved.

#ifndef __MATRIX_ISPH__
#define __MATRIX_ISPH__

#include "Math/Vector.isph"

#ifndef EXPLICIT_MATRIX
#define EXPLICIT_MATRIX 0
#endif

struct FMatrix
{
#if EXPLICIT_MATRIX == 0
	float M[16];
#else
	float<16> M;
#endif
};

#ifndef EXPLICIT_MATRIX3x4
#define EXPLICIT_MATRIX3x4 0
#endif

struct FMatrix3x4
{
#if EXPLICIT_MATRIX3x4 == 0
	float M[12];
#else
	float<12> M;
#endif
};

static const uniform struct FMatrix MatrixIdentity = {{ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}};

inline uniform FMatrix SetMatrix(const uniform FVector4 &R0, const uniform FVector4 &R1, const uniform FVector4 &R2, const uniform FVector4 &R3)
{
	const uniform FMatrix Result = {{ R0.V[0], R0.V[1], R0.V[2], R0.V[3],
									R1.V[0], R1.V[1], R1.V[2], R1.V[3],
									R2.V[0], R2.V[1], R2.V[2], R2.V[3],
									R3.V[0], R3.V[1], R3.V[2], R3.V[3] }};
	return Result;
}

inline uniform FMatrix operator*(const uniform FMatrix &Matrix1, const uniform FMatrix &Matrix2)
{
	uniform FVector4 R[4];

	const uniform FVector4 *uniform A	= (const uniform FVector4 *uniform) &Matrix1;
	const uniform FVector4 *uniform B	= (const uniform FVector4 *uniform) &Matrix2;

	for (uniform unsigned int i = 0; i < 4; i++)
	{
		R[i] = VectorReplicate( A[i], 0 ) * B[0] +
				VectorReplicate( A[i], 2 ) * B[2] +
				VectorReplicate( A[i], 1 ) * B[1] +
				VectorReplicate( A[i], 3 ) * B[3];
	}

	return SetMatrix(R[0], R[1], R[2], R[3]);
}

inline FMatrix operator*(const FMatrix &A, const FMatrix &B)
{
	FMatrix Result;

	for (uniform unsigned int m = 0; m < 4; m++) 
	{
		varying float Sum;
		for (uniform unsigned int k = 0; k < 4; k++) 
		{
			Sum = 0.0f;
			for (uniform unsigned int n = 0; n < 4; n++) 
			{
				Sum += A.M[m * 4 + n] * B.M[n * 4 + k];
			}
			
			Result.M[m * 4 + k] = Sum;
		}
	}

	return Result;
}

inline FMatrix operator*(const FMatrix &A, const uniform FMatrix &B)
{
	FMatrix Result;

	for (uniform unsigned int m = 0; m < 4; m++) 
	{
		varying float Sum;
		for (uniform unsigned int k = 0; k < 4; k++) 
		{
			Sum = 0.0f;
			for (uniform unsigned int n = 0; n < 4; n++) 
			{
				Sum += A.M[m * 4 + n] * B.M[n * 4 + k];
			}
			
			Result.M[m * 4 + k] = Sum;
		}
	}

	return Result;
}

// Remove any scaling from this matrix (ie magnitude of each row is 1)
inline void MatrixRemoveScaling(uniform FMatrix &M)
{
	// For each row, find magnitude, and if its non-zero re-scale so its unit length.
	varying float S0, S1, S2, SquareSum = 0.0f;
	*((uniform FVector *uniform)&S0) = *((uniform FVector *uniform)&M.M[0]);
	*((uniform FVector *uniform)&S1) = *((uniform FVector *uniform)&M.M[4]);
	*((uniform FVector *uniform)&S2) = *((uniform FVector *uniform)&M.M[8]);

#if EXPLICIT_VECTOR == 1
	// Using explicit vector aligns to 16 bytes. Save the 4th components when pulling from Matrix type
	const uniform float SavedS0 = extract(S0, 3);
	S0 = insert(S0, 3, 0.0f);
	const uniform float SavedS1 = extract(S1, 3);
	S1 = insert(S1, 3, 0.0f);
	const uniform float SavedS2 = extract(S2, 3);
	S2 = insert(S2, 3, 0.0f);
#endif

	const uniform FVector VSquareSum = SetVector(reduce_add(S0 * S0), reduce_add(S1 * S1), reduce_add(S2 * S2));
	*((uniform FVector *uniform)&SquareSum) = *((uniform FVector *uniform)&VSquareSum);

	const varying float Scale = select( SquareSum - SMALL_NUMBER >= 0.f, InvSqrt(SquareSum), 1.0f );
	const uniform FVector VScale = *((uniform FVector *uniform)&Scale);

	S0 = S0 * VScale.V[0];
	S1 = S1 * VScale.V[1];
	S2 = S2 * VScale.V[2];

#if EXPLICIT_VECTOR == 1
	// Reintroduce 4th components here
	S0 = insert(S0, 3, SavedS0);
	S1 = insert(S1, 3, SavedS1);
	S2 = insert(S2, 3, SavedS2);
#endif

	*((uniform FVector *uniform)&M.M[0]) = *((uniform FVector *uniform)&S0);
	*((uniform FVector *uniform)&M.M[4]) = *((uniform FVector *uniform)&S1);
	*((uniform FVector *uniform)&M.M[8]) = *((uniform FVector *uniform)&S2);
}

inline uniform FVector MatrixGetOrigin(const uniform FMatrix &M)
{
	return SetVector(M.M[12], M.M[13], M.M[14]);
}

inline void MatrixGetScaledAxes(const uniform FMatrix &M, uniform FVector &X, uniform FVector &Y, uniform FVector &Z)
{
	X = SetVector(M.M[0], M.M[1], M.M[2]);
	Y = SetVector(M.M[4], M.M[5], M.M[6]);
	Z = SetVector(M.M[8], M.M[9], M.M[10]);
}

inline void MatrixScaleAxis(uniform FMatrix &M, const uniform int Axis, const uniform float ScalingFactor)
{
	varying float S0;
	*((uniform FVector *uniform)&S0) = *((uniform FVector *uniform)&M.M[(4*Axis)]);

#if EXPLICIT_VECTOR == 1
	// Using explicit vector aligns to 16 bytes. Save the 4th component when pulling from Matrix type
	const uniform float Saved = extract(S0, 3);
	S0 = insert(S0, 3, 0.0f);
#endif

	S0 = S0 * ScalingFactor;

#if EXPLICIT_VECTOR == 1
	// Reintroduce 4th component here
	S0 = insert(S0, 3, Saved);
#endif

	*((uniform FVector *uniform)&M.M[(4*Axis)]) = *((uniform FVector *uniform)&S0);
}

inline uniform bool IsAnyMatrixScaledAxesNearlyZero(const uniform FMatrix &M, const uniform float Tolerance)
{
	uniform FVector X, Y, Z;
	MatrixGetScaledAxes(M, X, Y, Z);

	if(VectorIsAnyNearlyZero(X, Tolerance) || VectorIsAnyNearlyZero(Y, Tolerance) || VectorIsAnyNearlyZero(Z, Tolerance))
	{
		return true;
	}

	return false;
}

inline uniform bool IsAllMatrixScaledAxesNearlyZero(const uniform FMatrix &M, const uniform float Tolerance)
{
	uniform FVector X, Y, Z;
	MatrixGetScaledAxes(M, X, Y, Z);

	if(VectorIsAllNearlyZero(X, Tolerance) && VectorIsAllNearlyZero(Y, Tolerance) && VectorIsAllNearlyZero(Z, Tolerance))
	{
		return true;
	}

	return false;
}

inline uniform FMatrix MatrixTranspose(const uniform FMatrix& M)
{
	uniform FMatrix Result;

	const uniform FVector4 R1 = *((uniform FVector4 *uniform)&M.M[0]);
	const uniform FVector4 R2 = *((uniform FVector4 *uniform)&M.M[4]);
	const uniform FVector4 R3 = *((uniform FVector4 *uniform)&M.M[8]);
	const uniform FVector4 R4 = *((uniform FVector4 *uniform)&M.M[12]);

	*((uniform FVector4 *uniform)&Result.M[0]) = SetVector4(R1.V[0], R2.V[0], R3.V[0], R4.V[0]);
	*((uniform FVector4 *uniform)&Result.M[4]) = SetVector4(R1.V[1], R2.V[1], R3.V[1], R4.V[1]);
	*((uniform FVector4 *uniform)&Result.M[8]) = SetVector4(R1.V[2], R2.V[2], R3.V[2], R4.V[2]);
	*((uniform FVector4 *uniform)&Result.M[12]) = SetVector4(R1.V[3], R2.V[3], R3.V[3], R4.V[3]);

	return Result;
}

// for row major matrix
// we use __m128 to represent 2x2 matrix as A = | A0  A1 |
//                                              | A2  A3 |
// 2x2 row major Matrix multiply A*B
static inline uniform FVector4 Mat2Mul(const uniform FVector4& vec1, const uniform FVector4& vec2)
{
	return
		VectorAdd(VectorMultiply( vec1, VectorSwizzle(vec2, 0,3,0,3)),
			VectorMultiply(VectorSwizzle(vec1, 1,0,3,2), VectorSwizzle(vec2, 2,1,2,1)));
}
// 2x2 row major Matrix adjugate multiply (A#)*B
static inline uniform FVector4 Mat2AdjMul(const uniform FVector4& vec1, const uniform FVector4& vec2)
{
	return
		VectorSubtract(VectorMultiply(VectorSwizzle(vec1, 3,3,0,0), vec2),
			VectorMultiply(VectorSwizzle(vec1, 1,1,2,2), VectorSwizzle(vec2, 2,3,0,1)));

}
// 2x2 row major Matrix multiply adjugate A*(B#)
static inline uniform FVector4 Mat2MulAdj(const uniform FVector4& vec1, const uniform FVector4& vec2)
{
	return
		VectorSubtract(VectorMultiply( vec1, VectorSwizzle(vec2, 3,0,3,0)),
			VectorMultiply(VectorSwizzle(vec1, 1,0,3,2), VectorSwizzle(vec2, 2,1,2,1)));
}

inline uniform float MatrixDeterminant(const uniform FMatrix& M)
{
	const uniform FVector4 *uniform MVec = (const uniform FVector4 *uniform) &M;

	// sub matrices
	const uniform FVector4 A = VectorShuffle(MVec[0], MVec[1], 0,1,0,1);
	const uniform FVector4 B = VectorShuffle(MVec[0], MVec[1], 2,3,2,3);
	const uniform FVector4 C = VectorShuffle(MVec[2], MVec[3], 0,1,0,1);
	const uniform FVector4 D = VectorShuffle(MVec[2], MVec[3], 2,3,2,3);

	// determinant as (|A| |B| |C| |D|)
	const uniform FVector4 detSub = VectorSubtract(
		VectorMultiply(VectorShuffle(MVec[0], MVec[2], 0,2,0,2), VectorShuffle(MVec[1], MVec[3], 1,3,1,3)),
		VectorMultiply(VectorShuffle(MVec[0], MVec[2], 1,3,1,3), VectorShuffle(MVec[1], MVec[3], 0,2,0,2))
	);

	// D#C
	const uniform FVector4 D_C = Mat2AdjMul(D, C);
	// A#B
	const uniform FVector4 A_B = Mat2AdjMul(A, B);

	// |M| = |A|*|D| + |B|*|C|
	uniform float detM = (detSub.V[0] * detSub.V[3]) + (detSub.V[1] * detSub.V[2]);

	// tr((A#B)(D#C))
	uniform FVector4 tr = VectorMultiply(A_B, VectorSwizzle(D_C, 0,2,1,3));
	tr = tr + VectorSwizzle(tr, 2,3,0,1);
	tr = tr + VectorSwizzle(tr, 1,2,3,0);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C)
	detM = detM - tr.V[0];

	return detM;
}

inline uniform FMatrix VectorMatrixInverse(const uniform FMatrix& M)
{
	// use block matrix method
	// A is a matrix, then i(A) or iA means inverse of A, A# (or A_ in code) means adjugate of A, |A| (or detA in code) is determinant, tr(A) is trace
	const uniform FVector4 *uniform MVec = (const uniform FVector4 *uniform) &M;

	// sub matrices
	const uniform FVector4 A = VectorShuffle(MVec[0], MVec[1], 0,1,0,1);
	const uniform FVector4 B = VectorShuffle(MVec[0], MVec[1], 2,3,2,3);
	const uniform FVector4 C = VectorShuffle(MVec[2], MVec[3], 0,1,0,1);
	const uniform FVector4 D = VectorShuffle(MVec[2], MVec[3], 2,3,2,3);

	// determinant as (|A| |B| |C| |D|)
	const uniform FVector4 detSub = VectorSubtract(
		VectorMultiply(VectorShuffle(MVec[0], MVec[2], 0,2,0,2), VectorShuffle(MVec[1], MVec[3], 1,3,1,3)),
		VectorMultiply(VectorShuffle(MVec[0], MVec[2], 1,3,1,3), VectorShuffle(MVec[1], MVec[3], 0,2,0,2))
	);

	const uniform FVector4 detA = VectorSwizzle(detSub, 0,0,0,0);
	const uniform FVector4 detB = VectorSwizzle(detSub, 1,1,1,1);
	const uniform FVector4 detC = VectorSwizzle(detSub, 2,2,2,2);
	const uniform FVector4 detD = VectorSwizzle(detSub, 3,3,3,3);

	// let iM = 1/|M| * | X  Y |
	//                  | Z  W |

	// D#C
	const uniform FVector4 D_C = Mat2AdjMul(D, C);
	// A#B
	const uniform FVector4 A_B = Mat2AdjMul(A, B);
	// X# = |D|A - B(D#C)
	uniform FVector4 X_ = VectorSubtract(VectorMultiply(detD, A), Mat2Mul(B, D_C));
	// W# = |A|D - C(A#B)
	uniform FVector4 W_ = VectorSubtract(VectorMultiply(detA, D), Mat2Mul(C, A_B));

	// |M| = |A|*|D| + ... (continue later)
	uniform FVector4 detM = VectorMultiply(detA, detD);

	// Y# = |B|C - D(A#B)#
	uniform FVector4 Y_ = VectorSubtract(VectorMultiply(detB, C), Mat2MulAdj(D, A_B));
	// Z# = |C|B - A(D#C)#
	uniform FVector4 Z_ = VectorSubtract(VectorMultiply(detC, B), Mat2MulAdj(A, D_C));

	// |M| = |A|*|D| + |B|*|C| ... (continue later)
	detM = VectorAdd(detM, VectorMultiply(detB, detC));

	// tr((A#B)(D#C))
	uniform FVector4 tr = VectorMultiply(A_B, VectorSwizzle(D_C, 0,2,1,3));
	tr = tr + VectorSwizzle(tr, 2,3,0,1);
	tr = tr + VectorSwizzle(tr, 1,2,3,0);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C)
	detM = VectorSubtract(detM, tr);

	uniform FMatrix R = MatrixIdentity;

	if(detM.V[0] != 0.0f)
	{
		const uniform FVector4 adjSignMask = SetVector4(1.f, -1.f, -1.f, 1.f);
		// (1/|M|, -1/|M|, -1/|M|, 1/|M|)
		const uniform FVector4 rDetM = VectorDivide(adjSignMask, detM);

		X_ = VectorMultiply(X_, rDetM);
		Y_ = VectorMultiply(Y_, rDetM);
		Z_ = VectorMultiply(Z_, rDetM);
		W_ = VectorMultiply(W_, rDetM);

		uniform FVector4 *uniform RVec = (uniform FVector4 *uniform) &R;

		// apply adjugate and store, here we combine adjugate shuffle and store shuffle
		RVec[0] = VectorShuffle(X_, Y_, 3,1,3,1);
		RVec[1] = VectorShuffle(X_, Y_, 2,0,2,0);
		RVec[2] = VectorShuffle(Z_, W_, 3,1,3,1);
		RVec[3] = VectorShuffle(Z_, W_, 2,0,2,0);	
	}

	return R;
}

inline uniform FMatrix MatrixInverse(const uniform FMatrix& M)
{
	uniform FMatrix Result;

	// Check for zero scale matrix to invert
	if(	IsAllMatrixScaledAxesNearlyZero(M, SMALL_NUMBER) ) 
	{
		// just set to zero - avoids unsafe inverse of zero and duplicates what QNANs were resulting in before (scaling away all children)
		Result = MatrixIdentity;
	}
	else
	{
		Result = VectorMatrixInverse(M);
	}

	return Result;
}

#endif
