// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Chaos/ParticleHandle.h"
#include "Chaos/PBDCollisionConstraints.h"
#include "Chaos/PBDRigidsSOAs.h"

namespace Chaos
{
	/**
	 * Consumes lists of contacts generated by an FCollisionDetector (which may be on a separate thread) and
	 * then adds the contacts to the CollisionConstraints in a thread-safe way.
	 */
	class FAsyncCollisionReceiver
	{
	public:
		using FCollisionConstraints = TPBDCollisionConstraints<FReal, 3>;

		FAsyncCollisionReceiver(FCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions.
		 */
		void ReceiveCollisions(const FCollisionConstraintsArray& Constraints)
		{
			for (const TRigidBodyPointContactConstraint<FReal, 3>& Constraint : Constraints.SinglePointConstraints)
			{
				SinglePointQueue.Enqueue(Constraint);
			}
			for (const TRigidBodyMultiPointContactConstraint<FReal, 3>& Constraint : Constraints.MultiPointConstraints)
			{
				MultiPointQueue.Enqueue(Constraint);
			}
		}

		/**
		 * Add received collisions to the container (on physics thread)
		 */
		void ProcessCollisions()
		{
			// @todo(chaos) : Collision Constraints
			//    This needs to be moved within the MidPhase (which does not exist yet). The 
			//    NarrowPhase is creating temporary constraints for all interacting bodies 
			//    even though we might already have those bodies within the constraint.
			//    So there is a bunch of wasted computation when the CreateConstraints is called. 
			TRigidBodyPointContactConstraint<FReal, 3> SinglePointConstraint;
			while (SinglePointQueue.Dequeue(SinglePointConstraint))
			{
				if (!CollisionConstraints.Contains(&SinglePointConstraint))
				{
					CollisionConstraints.AddConstraint(SinglePointConstraint);
				}
			}
			TRigidBodyMultiPointContactConstraint<FReal, 3> MultiPointConstraint;
			while (MultiPointQueue.Dequeue(MultiPointConstraint))
			{
				if (!CollisionConstraints.Contains(&MultiPointConstraint))
				{
					CollisionConstraints.AddConstraint(MultiPointConstraint);
				}
			}
		}

	private:
		//todo(ocohen): use per thread buffer instead, need better support than ParallelFor for this
		TQueue<TRigidBodyPointContactConstraint<FReal, 3>, EQueueMode::Mpsc> SinglePointQueue;
		TQueue<TRigidBodyMultiPointContactConstraint<FReal, 3>, EQueueMode::Mpsc> MultiPointQueue;
		FCollisionConstraints& CollisionConstraints;
	};


	/**
	 * A synchronous collision receiver. This immediately adds collisions to the container as they are received. 
	 * /see FAsyncCollisionReceiver
	 */
	class FSyncCollisionReceiver
	{
	public:
		using FCollisionConstraints = TPBDCollisionConstraints<FReal, 3>;

		FSyncCollisionReceiver(FCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions.
		 */
		void ReceiveCollisions(const FCollisionConstraintsArray& Constraints)
		{
			for (const TRigidBodyPointContactConstraint<FReal, 3>& Constraint : Constraints.SinglePointConstraints)
			{
				CollisionConstraints.AddConstraint(Constraint);
			}
			for (const TRigidBodyMultiPointContactConstraint<FReal, 3>& Constraint : Constraints.MultiPointConstraints)
			{
				CollisionConstraints.AddConstraint(Constraint);
			}
		}

		/**
		 * No-op
		 */
		void ProcessCollisions()
		{
		}

	private:
		FCollisionConstraints& CollisionConstraints;
	};
}