// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Chaos/ParticleHandle.h"
#include "Chaos/PBDCollisionConstraints.h"
#include "Chaos/PBDRigidsSOAs.h"

namespace Chaos
{
	/**
	 * Consumes lists of contacts generated by an FCollisionDetector (which may be on a separate thread) and
	 * then adds the contacts to the CollisionConstraints in a thread-safe way.
	 */
	class FAsyncCollisionReceiver
	{
	public:
		FAsyncCollisionReceiver(FPBDCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions.
		 */
		void ReceiveCollisions(const FCollisionConstraintsArray& Constraints)
		{
			for (const FRigidBodyPointContactConstraint& Constraint : Constraints.SinglePointConstraints)
			{
				SinglePointQueue.Enqueue(Constraint);
			}
			for (const FRigidBodySweptPointContactConstraint& Constraint : Constraints.SinglePointSweptConstraints)
			{
				SingleSweptPointQueue.Enqueue(Constraint);
			}

			for (const FRigidBodyMultiPointContactConstraint& Constraint : Constraints.MultiPointConstraints)
			{
				MultiPointQueue.Enqueue(Constraint);
			}
		}

		/**
		 * Add received collisions to the container (on physics thread)
		 */
		void ProcessCollisions()
		{
			// @todo(chaos) : Collision Constraints
			//    This needs to be moved within the MidPhase (which does not exist yet). The 
			//    NarrowPhase is creating temporary constraints for all interacting bodies 
			//    even though we might already have those bodies within the constraint.
			//    So there is a bunch of wasted computation when the CreateConstraints is called. 
			FRigidBodyPointContactConstraint SinglePointConstraint;
			while (SinglePointQueue.Dequeue(SinglePointConstraint))
			{
				if (!CollisionConstraints.Contains(&SinglePointConstraint))
				{
					CollisionConstraints.AddConstraint(SinglePointConstraint);
				}
			}
			FRigidBodySweptPointContactConstraint SinglePointSweptConstraint;
			while (SingleSweptPointQueue.Dequeue(SinglePointSweptConstraint))
			{
				if (!CollisionConstraints.Contains(&SinglePointSweptConstraint))
				{
					CollisionConstraints.AddConstraint(SinglePointSweptConstraint);
				}
			}

			FRigidBodyMultiPointContactConstraint MultiPointConstraint;
			while (MultiPointQueue.Dequeue(MultiPointConstraint))
			{
				if (!CollisionConstraints.Contains(&MultiPointConstraint))
				{
					CollisionConstraints.AddConstraint(MultiPointConstraint);
				}
			}
		}

	private:
		//todo(ocohen): use per thread buffer instead, need better support than ParallelFor for this
		TQueue<FRigidBodyPointContactConstraint, EQueueMode::Mpsc> SinglePointQueue;
		TQueue<FRigidBodySweptPointContactConstraint, EQueueMode::Mpsc> SingleSweptPointQueue;
		TQueue<FRigidBodyMultiPointContactConstraint, EQueueMode::Mpsc> MultiPointQueue;
		FPBDCollisionConstraints& CollisionConstraints;
	};


	/**
	 * A synchronous collision receiver. This immediately adds collisions to the container as they are received. 
	 * /see FAsyncCollisionReceiver
	 */
	class FSyncCollisionReceiver
	{
	public:
		FSyncCollisionReceiver(FPBDCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		FCollisionConstraintsArray& GetConstraintsArray()
		{
			return CollisionConstraints.GetConstraintsArray();
		}

		/**
		 * Does nothing - we write directly into the Constraints Container
		 */
		void ReceiveCollisions(const FCollisionConstraintsArray& Constraints)
		{
		}

		/**
		 * Does nothing - we write directly into the Constraints Container
		 */
		void ProcessCollisions()
		{
		}

	private:
		FPBDCollisionConstraints& CollisionConstraints;
	};
}