// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Features/IModularFeature.h"

class AActor;
class UStaticMesh;
class UMaterial;
class UMaterialInterface;
class UTexture2D;


/**
 * IGeometryProcessing_ApproximateActors is a generic high-level interface to a function/system that
 * outputs a set of new Mesh assets that approximate a set of input Actors.
 * This can be used to provide LOD-generation implementations for systems like ProxyLOD and HLOD.
 * 
 * This is an IModularFeature, and so clients can query/enumerate the available ApproximateActors implementations 
 * based on the ::GetModularFeatureName(). However, the preferred way is to use code like the following:
 * 
 *     IGeometryProcessingInterfacesModule& GeomProcInterfaces = FModuleManager::Get().LoadModuleChecked<IGeometryProcessingInterfacesModule>("GeometryProcessingInterfaces");
 *     IGeometryProcessing_ApproximateActors* ApproxActorsAPI = GeomProcInterfaces.GetApproximateActorsImplementation();
 * 
 * This will automatically determine which available implementation to use (based on any applicable config settings/etc),
 * and cache the result of that decision.
 */
class IGeometryProcessing_ApproximateActors : public IModularFeature
{
public:
	virtual ~IGeometryProcessing_ApproximateActors() {}

	enum class EApproximationPolicy
	{
		MeshAndGeneratedMaterial,
		CollisionMesh
	};

	enum class EBaseCappingPolicy
	{
		NoBaseCapping = 0,
		ConvexPolygon = 1,
		ConvexSolid = 2
	};

	enum class EOcclusionPolicy : uint8
	{
		None = 0,
		VisibilityBased = 1
	};

	enum class ESimplificationPolicy
	{
		FixedTriangleCount = 0,
		TrianglesPerUnitSqMeter = 1,
		GeometricTolerance = 2
	};


	/**
	 * Input options to Actor Approximation process
	 */
	struct FOptions
	{
		// Base path for generated assets. Names will be generated by appending strings to this path.
		FString BasePackagePath;

		// high-level control of the overall approximation process
		EApproximationPolicy BasePolicy = EApproximationPolicy::MeshAndGeneratedMaterial;

		//
		// Mesh Preprocessing settings
		//
		bool bAutoThickenThinParts = false;
		double AutoThickenThicknessMeters = 0.1;

		EBaseCappingPolicy BaseCappingPolicy = EBaseCappingPolicy::NoBaseCapping;
		double BaseThicknessOverrideMeters = 0.0;		// use this thickness for Solid. If zero, use AutoThickenThickness if bAutoThickenThinParts=true, otherwise use WorldSpaceApproximationAccuracyMeters
		double BaseHeightOverrideMeters = 0.0;		// consider this height from MinZ as "base" region. If zero, use 2.0*WorldSpaceApproximationAccuracyMeters

		//
		// Shape Approximation settings
		//

		// Meshing settings (ie for voxelization)
		double WorldSpaceApproximationAccuracyMeters = 1.0;
		int32 ClampVoxelDimension = 1024;

		double WindingThreshold = 0.5;

		bool bApplyMorphology = false;
		double MorphologyDistanceMeters = 0.1;

		EOcclusionPolicy OcclusionPolicy = EOcclusionPolicy::VisibilityBased;
		ESimplificationPolicy MeshSimplificationPolicy = ESimplificationPolicy::FixedTriangleCount;
		int32 FixedTriangleCount = 5000;
		double SimplificationTargetMetric = 0.1;		// interpretation varies depending on MeshSimplificationPolicy

		//
		// Material approximation settings
		//
		int32 RenderCaptureImageSize = 1024;

		// render capture parameters
		double FieldOfViewDegrees = 45.0;
		double NearPlaneDist = 1.0;


		//
		// Material output settings
		//

		// A new MIC derived from this material will be created and assigned to the generated mesh
		UMaterialInterface* BakeMaterial = nullptr;		// if null, will use /MeshModelingToolset/Materials/FullMaterialBakePreviewMaterial instead
		FName BaseColorTexParamName = FName("BaseColor");
		bool bBakeBaseColor = true;
		FName RoughnessTexParamName = FName("Roughness");
		bool bBakeRoughness = true;
		FName MetallicTexParamName = FName("Metallic");
		bool bBakeMetallic = true;
		FName SpecularTexParamName = FName("Specular");
		bool bBakeSpecular = true;
		FName EmissiveTexParamName = FName("Emissive");
		bool bBakeEmissive = true;
		FName NormalTexParamName = FName("NormalMap");
		bool bBakeNormalMap = true;

		// output texture options
		int32 TextureImageSize = 1024;

		// supersampling parameter
		int32 AntiAliasMultiSampling = 0;


		//
		// Debug settings
		//

		// print useful information to the Output Log 
		bool bVerbose = false;

		// create a flattened (ie non-instanced) mesh and save it with _DEBUG suffix. Warning often absolutely enormous!
		bool bWriteDebugMesh = false;


		// todo
		//   - which texture types to generate (BaseColor, Specular, WorldNormal, etc)
		//   - per-texture resolution, and channel/compression settings
		//   - which material to use as input, whether to make new UMaterial or a MIC
		//   - custom Generated-Texture to Material Parameter Name mapping
	};

	enum class EResultCode
	{
		Success,
		MeshGenerationFailed,
		UnknownError
	};

	/**
	 * Outputs of an Actor Approximation process
	 */
	struct FResults
	{
		EResultCode ResultCode = EResultCode::UnknownError;

		TArray<UStaticMesh*> NewMeshAssets;

		TArray<UMaterialInterface*> NewMaterials;
		
		TArray<UTexture2D*> NewTextures;

		// todo
	};

	/**
	 * Top-level driver function that clients call to generate the approximation for a set of input Actors.
	 */
	virtual void ApproximateActors(const TArray<AActor*>& Actors, const FOptions& Options, FResults& ResultsOut) 
	{
		check(false);		// not implemented in base class
	}


	// Modular feature name to register for retrieval during runtime
	static const FName GetModularFeatureName()
	{
		return TEXT("GeometryProcessing_ApproximateActors");
	}


	// delegates to pass back info?
	DECLARE_DELEGATE_OneParam(FApproximateActorsCompleteDelegate, FResults&);
	FApproximateActorsCompleteDelegate CompleteDelegate;

};