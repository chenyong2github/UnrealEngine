//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: build/bazel/remote/execution/v2/remote_execution.proto
// Original file comments:
// Copyright 2018 The Bazel Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_build_2fbazel_2fremote_2fexecution_2fv2_2fremote_5fexecution_2eproto__INCLUDED
#define GRPC_build_2fbazel_2fremote_2fexecution_2fv2_2fremote_5fexecution_2eproto__INCLUDED

#include "build/bazel/remote/execution/v2/remote_execution.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace build {
namespace bazel {
namespace remote {
namespace execution {
namespace v2 {

// The Remote Execution API is used to execute an
// [Action][build.bazel.remote.execution.v2.Action] on the remote
// workers.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class Execution final {
 public:
  static constexpr char const* service_full_name() {
    return "build.bazel.remote.execution.v2.Execution";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Execute an action remotely.
    //
    // In order to execute an action, the client must first upload all of the
    // inputs, the
    // [Command][build.bazel.remote.execution.v2.Command] to run, and the
    // [Action][build.bazel.remote.execution.v2.Action] into the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
    // It then calls `Execute` with an `action_digest` referring to them. The
    // server will run the action and eventually return the result.
    //
    // The input `Action`'s fields MUST meet the various canonicalization
    // requirements specified in the documentation for their types so that it has
    // the same digest as other logically equivalent `Action`s. The server MAY
    // enforce the requirements and return errors if a non-canonical input is
    // received. It MAY also proceed without verifying some or all of the
    // requirements, such as for performance reasons. If the server does not
    // verify the requirement, then it will treat the `Action` as distinct from
    // another logically equivalent action if they hash differently.
    //
    // Returns a stream of
    // [google.longrunning.Operation][google.longrunning.Operation] messages
    // describing the resulting execution, with eventual `response`
    // [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
    // `metadata` on the operation is of type
    // [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
    //
    // If the client remains connected after the first response is returned after
    // the server, then updates are streamed as if the client had called
    // [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
    // until the execution completes or the request reaches an error. The
    // operation can also be queried using [Operations
    // API][google.longrunning.Operations.GetOperation].
    //
    // The server NEED NOT implement other methods or functionality of the
    // Operations API.
    //
    // Errors discovered during creation of the `Operation` will be reported
    // as gRPC Status errors, while errors that occurred while running the
    // action will be reported in the `status` field of the `ExecuteResponse`. The
    // server MUST NOT set the `error` field of the `Operation` proto.
    // The possible errors include:
    //
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
    //   action requested, such as a missing input or command or no worker being
    //   available. The client may be able to fix the errors and retry.
    // * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
    //   the action.
    // * `UNAVAILABLE`: Due to a transient condition, such as all workers being
    //   occupied (and the server does not support a queue), the action could not
    //   be started. The client should retry.
    // * `INTERNAL`: An internal error occurred in the execution engine or the
    //   worker.
    // * `DEADLINE_EXCEEDED`: The execution timed out.
    // * `CANCELLED`: The operation was cancelled by the client. This status is
    //   only possible if the server implements the Operations API CancelOperation
    //   method, and it was called for the current execution.
    //
    // In the case of a missing input or command, the server SHOULD additionally
    // send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
    // where, for each requested blob not present in the CAS, there is a
    // `Violation` with a `type` of `MISSING` and a `subject` of
    // `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
    //
    // The server does not need to guarantee that a call to this method leads to
    // at most one execution of the action. The server MAY execute the action
    // multiple times, potentially in parallel. These redundant executions MAY
    // continue to run, even if the operation is completed.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::google::longrunning::Operation>> Execute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::google::longrunning::Operation>>(ExecuteRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>> AsyncExecute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>>(AsyncExecuteRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    // Wait for an execution operation to complete. When the client initially
    // makes the request, the server immediately responds with the current status
    // of the execution. The server will leave the request stream open until the
    // operation completes, and then respond with the completed operation. The
    // server MAY choose to stream additional updates as execution progresses,
    // such as to provide an update as to the state of the execution.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::google::longrunning::Operation>> WaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::google::longrunning::Operation>>(WaitExecutionRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>> AsyncWaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>>(AsyncWaitExecutionRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>> PrepareAsyncWaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>>(PrepareAsyncWaitExecutionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Execute an action remotely.
      //
      // In order to execute an action, the client must first upload all of the
      // inputs, the
      // [Command][build.bazel.remote.execution.v2.Command] to run, and the
      // [Action][build.bazel.remote.execution.v2.Action] into the
      // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
      // It then calls `Execute` with an `action_digest` referring to them. The
      // server will run the action and eventually return the result.
      //
      // The input `Action`'s fields MUST meet the various canonicalization
      // requirements specified in the documentation for their types so that it has
      // the same digest as other logically equivalent `Action`s. The server MAY
      // enforce the requirements and return errors if a non-canonical input is
      // received. It MAY also proceed without verifying some or all of the
      // requirements, such as for performance reasons. If the server does not
      // verify the requirement, then it will treat the `Action` as distinct from
      // another logically equivalent action if they hash differently.
      //
      // Returns a stream of
      // [google.longrunning.Operation][google.longrunning.Operation] messages
      // describing the resulting execution, with eventual `response`
      // [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
      // `metadata` on the operation is of type
      // [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
      //
      // If the client remains connected after the first response is returned after
      // the server, then updates are streamed as if the client had called
      // [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
      // until the execution completes or the request reaches an error. The
      // operation can also be queried using [Operations
      // API][google.longrunning.Operations.GetOperation].
      //
      // The server NEED NOT implement other methods or functionality of the
      // Operations API.
      //
      // Errors discovered during creation of the `Operation` will be reported
      // as gRPC Status errors, while errors that occurred while running the
      // action will be reported in the `status` field of the `ExecuteResponse`. The
      // server MUST NOT set the `error` field of the `Operation` proto.
      // The possible errors include:
      //
      // * `INVALID_ARGUMENT`: One or more arguments are invalid.
      // * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
      //   action requested, such as a missing input or command or no worker being
      //   available. The client may be able to fix the errors and retry.
      // * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
      //   the action.
      // * `UNAVAILABLE`: Due to a transient condition, such as all workers being
      //   occupied (and the server does not support a queue), the action could not
      //   be started. The client should retry.
      // * `INTERNAL`: An internal error occurred in the execution engine or the
      //   worker.
      // * `DEADLINE_EXCEEDED`: The execution timed out.
      // * `CANCELLED`: The operation was cancelled by the client. This status is
      //   only possible if the server implements the Operations API CancelOperation
      //   method, and it was called for the current execution.
      //
      // In the case of a missing input or command, the server SHOULD additionally
      // send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
      // where, for each requested blob not present in the CAS, there is a
      // `Violation` with a `type` of `MISSING` and a `subject` of
      // `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
      //
      // The server does not need to guarantee that a call to this method leads to
      // at most one execution of the action. The server MAY execute the action
      // multiple times, potentially in parallel. These redundant executions MAY
      // continue to run, even if the operation is completed.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Execute(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::ClientReadReactor< ::google::longrunning::Operation>* reactor) = 0;
      #else
      virtual void Execute(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) = 0;
      #endif
      // Wait for an execution operation to complete. When the client initially
      // makes the request, the server immediately responds with the current status
      // of the execution. The server will leave the request stream open until the
      // operation completes, and then respond with the completed operation. The
      // server MAY choose to stream additional updates as execution progresses,
      // such as to provide an update as to the state of the execution.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WaitExecution(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::ClientReadReactor< ::google::longrunning::Operation>* reactor) = 0;
      #else
      virtual void WaitExecution(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::google::longrunning::Operation>* ExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::google::longrunning::Operation>* WaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>* AsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::google::longrunning::Operation>* PrepareAsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::google::longrunning::Operation>> Execute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::google::longrunning::Operation>>(ExecuteRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>> AsyncExecute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>>(AsyncExecuteRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::google::longrunning::Operation>> WaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::google::longrunning::Operation>>(WaitExecutionRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>> AsyncWaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>>(AsyncWaitExecutionRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>> PrepareAsyncWaitExecution(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::google::longrunning::Operation>>(PrepareAsyncWaitExecutionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Execute(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::ClientReadReactor< ::google::longrunning::Operation>* reactor) override;
      #else
      void Execute(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WaitExecution(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::ClientReadReactor< ::google::longrunning::Operation>* reactor) override;
      #else
      void WaitExecution(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::google::longrunning::Operation>* ExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request) override;
    ::grpc::ClientAsyncReader< ::google::longrunning::Operation>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::google::longrunning::Operation>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::google::longrunning::Operation>* WaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request) override;
    ::grpc::ClientAsyncReader< ::google::longrunning::Operation>* AsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::google::longrunning::Operation>* PrepareAsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Execute_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitExecution_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Execute an action remotely.
    //
    // In order to execute an action, the client must first upload all of the
    // inputs, the
    // [Command][build.bazel.remote.execution.v2.Command] to run, and the
    // [Action][build.bazel.remote.execution.v2.Action] into the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
    // It then calls `Execute` with an `action_digest` referring to them. The
    // server will run the action and eventually return the result.
    //
    // The input `Action`'s fields MUST meet the various canonicalization
    // requirements specified in the documentation for their types so that it has
    // the same digest as other logically equivalent `Action`s. The server MAY
    // enforce the requirements and return errors if a non-canonical input is
    // received. It MAY also proceed without verifying some or all of the
    // requirements, such as for performance reasons. If the server does not
    // verify the requirement, then it will treat the `Action` as distinct from
    // another logically equivalent action if they hash differently.
    //
    // Returns a stream of
    // [google.longrunning.Operation][google.longrunning.Operation] messages
    // describing the resulting execution, with eventual `response`
    // [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
    // `metadata` on the operation is of type
    // [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
    //
    // If the client remains connected after the first response is returned after
    // the server, then updates are streamed as if the client had called
    // [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
    // until the execution completes or the request reaches an error. The
    // operation can also be queried using [Operations
    // API][google.longrunning.Operations.GetOperation].
    //
    // The server NEED NOT implement other methods or functionality of the
    // Operations API.
    //
    // Errors discovered during creation of the `Operation` will be reported
    // as gRPC Status errors, while errors that occurred while running the
    // action will be reported in the `status` field of the `ExecuteResponse`. The
    // server MUST NOT set the `error` field of the `Operation` proto.
    // The possible errors include:
    //
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
    //   action requested, such as a missing input or command or no worker being
    //   available. The client may be able to fix the errors and retry.
    // * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
    //   the action.
    // * `UNAVAILABLE`: Due to a transient condition, such as all workers being
    //   occupied (and the server does not support a queue), the action could not
    //   be started. The client should retry.
    // * `INTERNAL`: An internal error occurred in the execution engine or the
    //   worker.
    // * `DEADLINE_EXCEEDED`: The execution timed out.
    // * `CANCELLED`: The operation was cancelled by the client. This status is
    //   only possible if the server implements the Operations API CancelOperation
    //   method, and it was called for the current execution.
    //
    // In the case of a missing input or command, the server SHOULD additionally
    // send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
    // where, for each requested blob not present in the CAS, there is a
    // `Violation` with a `type` of `MISSING` and a `subject` of
    // `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
    //
    // The server does not need to guarantee that a call to this method leads to
    // at most one execution of the action. The server MAY execute the action
    // multiple times, potentially in parallel. These redundant executions MAY
    // continue to run, even if the operation is completed.
    virtual ::grpc::Status Execute(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::ServerWriter< ::google::longrunning::Operation>* writer);
    // Wait for an execution operation to complete. When the client initially
    // makes the request, the server immediately responds with the current status
    // of the execution. The server will leave the request stream open until the
    // operation completes, and then respond with the completed operation. The
    // server MAY choose to stream additional updates as execution progresses,
    // such as to provide an update as to the state of the execution.
    virtual ::grpc::Status WaitExecution(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::ServerWriter< ::google::longrunning::Operation>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Execute() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::ServerAsyncWriter< ::google::longrunning::Operation>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitExecution() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitExecution(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::ServerAsyncWriter< ::google::longrunning::Operation>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Execute<WithAsyncMethod_WaitExecution<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Execute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::build::bazel::remote::execution::v2::ExecuteRequest, ::google::longrunning::Operation>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::ExecuteRequest* request) { return this->Execute(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::google::longrunning::Operation>* Execute(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::google::longrunning::Operation>* Execute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WaitExecution() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::build::bazel::remote::execution::v2::WaitExecutionRequest, ::google::longrunning::Operation>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* request) { return this->WaitExecution(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::google::longrunning::Operation>* WaitExecution(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::google::longrunning::Operation>* WaitExecution(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Execute<ExperimentalWithCallbackMethod_WaitExecution<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Execute<ExperimentalWithCallbackMethod_WaitExecution<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Execute() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitExecution() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Execute() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitExecution() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Execute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Execute(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Execute(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Execute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WaitExecution() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WaitExecution(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WaitExecution(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WaitExecution(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Execute() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::build::bazel::remote::execution::v2::ExecuteRequest, ::google::longrunning::Operation>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::build::bazel::remote::execution::v2::ExecuteRequest, ::google::longrunning::Operation>* streamer) {
                       return this->StreamedExecute(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::ExecuteRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedExecute(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::build::bazel::remote::execution::v2::ExecuteRequest,::google::longrunning::Operation>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WaitExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WaitExecution() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::build::bazel::remote::execution::v2::WaitExecutionRequest, ::google::longrunning::Operation>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::build::bazel::remote::execution::v2::WaitExecutionRequest, ::google::longrunning::Operation>* streamer) {
                       return this->StreamedWaitExecution(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WaitExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitExecution(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* /*request*/, ::grpc::ServerWriter< ::google::longrunning::Operation>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWaitExecution(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::build::bazel::remote::execution::v2::WaitExecutionRequest,::google::longrunning::Operation>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Execute<WithSplitStreamingMethod_WaitExecution<Service > > SplitStreamedService;
  typedef WithSplitStreamingMethod_Execute<WithSplitStreamingMethod_WaitExecution<Service > > StreamedService;
};

// The action cache API is used to query whether a given action has already been
// performed and, if so, retrieve its result. Unlike the
// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage],
// which addresses blobs by their own content, the action cache addresses the
// [ActionResult][build.bazel.remote.execution.v2.ActionResult] by a
// digest of the encoded [Action][build.bazel.remote.execution.v2.Action]
// which produced them.
//
// The lifetime of entries in the action cache is implementation-specific, but
// the server SHOULD assume that more recently used entries are more likely to
// be used again.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class ActionCache final {
 public:
  static constexpr char const* service_full_name() {
    return "build.bazel.remote.execution.v2.ActionCache";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Retrieve a cached execution result.
    //
    // Implementations SHOULD ensure that any blobs referenced from the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
    // are available at the time of returning the
    // [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
    // for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
    // if necessary and applicable.
    //
    // Errors:
    //
    // * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
    virtual ::grpc::Status GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>> AsyncGetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>>(AsyncGetActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>> PrepareAsyncGetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>>(PrepareAsyncGetActionResultRaw(context, request, cq));
    }
    // Upload a new execution result.
    //
    // In order to allow the server to perform access control based on the type of
    // action, and to assist with client debugging, the client MUST first upload
    // the [Action][build.bazel.remote.execution.v2.Execution] that produced the
    // result, along with its
    // [Command][build.bazel.remote.execution.v2.Command], into the
    // `ContentAddressableStorage`.
    //
    // Server implementations MAY modify the
    // `UpdateActionResultRequest.action_result` and return an equivalent value.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in updating the
    //   action result, such as a missing command or action.
    // * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
    //   entry to the cache.
    virtual ::grpc::Status UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>> AsyncUpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>>(AsyncUpdateActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>> PrepareAsyncUpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>>(PrepareAsyncUpdateActionResultRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Retrieve a cached execution result.
      //
      // Implementations SHOULD ensure that any blobs referenced from the
      // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
      // are available at the time of returning the
      // [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
      // for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
      // if necessary and applicable.
      //
      // Errors:
      //
      // * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
      virtual void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Upload a new execution result.
      //
      // In order to allow the server to perform access control based on the type of
      // action, and to assist with client debugging, the client MUST first upload
      // the [Action][build.bazel.remote.execution.v2.Execution] that produced the
      // result, along with its
      // [Command][build.bazel.remote.execution.v2.Command], into the
      // `ContentAddressableStorage`.
      //
      // Server implementations MAY modify the
      // `UpdateActionResultRequest.action_result` and return an equivalent value.
      //
      // Errors:
      //
      // * `INVALID_ARGUMENT`: One or more arguments are invalid.
      // * `FAILED_PRECONDITION`: One or more errors occurred in updating the
      //   action result, such as a missing command or action.
      // * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
      //   entry to the cache.
      virtual void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>* AsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>* PrepareAsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>* AsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ActionResult>* PrepareAsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>> AsyncGetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>>(AsyncGetActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>> PrepareAsyncGetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>>(PrepareAsyncGetActionResultRaw(context, request, cq));
    }
    ::grpc::Status UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>> AsyncUpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>>(AsyncUpdateActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>> PrepareAsyncUpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>>(PrepareAsyncUpdateActionResultRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* AsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* PrepareAsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* AsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* PrepareAsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetActionResult_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateActionResult_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Retrieve a cached execution result.
    //
    // Implementations SHOULD ensure that any blobs referenced from the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
    // are available at the time of returning the
    // [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
    // for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
    // if necessary and applicable.
    //
    // Errors:
    //
    // * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
    virtual ::grpc::Status GetActionResult(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response);
    // Upload a new execution result.
    //
    // In order to allow the server to perform access control based on the type of
    // action, and to assist with client debugging, the client MUST first upload
    // the [Action][build.bazel.remote.execution.v2.Execution] that produced the
    // result, along with its
    // [Command][build.bazel.remote.execution.v2.Command], into the
    // `ContentAddressableStorage`.
    //
    // Server implementations MAY modify the
    // `UpdateActionResultRequest.action_result` and return an equivalent value.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in updating the
    //   action result, such as a missing command or action.
    // * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
    //   entry to the cache.
    virtual ::grpc::Status UpdateActionResult(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActionResult() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActionResult(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::ActionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateActionResult(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::ActionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetActionResult<WithAsyncMethod_UpdateActionResult<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetActionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response) { return this->GetActionResult(context, request, response); }));}
    void SetMessageAllocatorFor_GetActionResult(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateActionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response) { return this->UpdateActionResult(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateActionResult(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateActionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateActionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetActionResult<ExperimentalWithCallbackMethod_UpdateActionResult<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetActionResult<ExperimentalWithCallbackMethod_UpdateActionResult<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActionResult() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActionResult() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActionResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateActionResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetActionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActionResult(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateActionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateActionResult(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateActionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateActionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActionResult() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>* streamer) {
                       return this->StreamedGetActionResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::GetActionResultRequest,::build::bazel::remote::execution::v2::ActionResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>* streamer) {
                       return this->StreamedUpdateActionResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* /*request*/, ::build::bazel::remote::execution::v2::ActionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateActionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::UpdateActionResultRequest,::build::bazel::remote::execution::v2::ActionResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetActionResult<WithStreamedUnaryMethod_UpdateActionResult<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetActionResult<WithStreamedUnaryMethod_UpdateActionResult<Service > > StreamedService;
};

// The CAS (content-addressable storage) is used to store the inputs to and
// outputs from the execution service. Each piece of content is addressed by the
// digest of its binary data.
//
// Most of the binary data stored in the CAS is opaque to the execution engine,
// and is only used as a communication medium. In order to build an
// [Action][build.bazel.remote.execution.v2.Action],
// however, the client will need to also upload the
// [Command][build.bazel.remote.execution.v2.Command] and input root
// [Directory][build.bazel.remote.execution.v2.Directory] for the Action.
// The Command and Directory messages must be marshalled to wire format and then
// uploaded under the hash as with any other piece of content. In practice, the
// input root directory is likely to refer to other Directories in its
// hierarchy, which must also each be uploaded on their own.
//
// For small file uploads the client should group them together and call
// [BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
// For large uploads, the client must use the
// [Write method][google.bytestream.ByteStream.Write] of the ByteStream API. The
// `resource_name` is `{instance_name}/uploads/{uuid}/blobs/{hash}/{size}`,
// where `instance_name` is as described in the next paragraph, `uuid` is a
// version 4 UUID generated by the client, and `hash` and `size` are the
// [Digest][build.bazel.remote.execution.v2.Digest] of the blob. The
// `uuid` is used only to avoid collisions when multiple clients try to upload
// the same file (or the same client tries to upload the file multiple times at
// once on different threads), so the client MAY reuse the `uuid` for uploading
// different blobs. The `resource_name` may optionally have a trailing filename
// (or other metadata) for a client to use if it is storing URLs, as in
// `{instance}/uploads/{uuid}/blobs/{hash}/{size}/foo/bar/baz.cc`. Anything
// after the `size` is ignored.
//
// A single server MAY support multiple instances of the execution system, each
// with their own workers, storage, cache, etc. The exact relationship between
// instances is up to the server. If the server does, then the `instance_name`
// is an identifier, possibly containing multiple path segments, used to
// distinguish between the various instances on the server, in a manner defined
// by the server. For servers which do not support multiple instances, then the
// `instance_name` is the empty path and the leading slash is omitted, so that
// the `resource_name` becomes `uploads/{uuid}/blobs/{hash}/{size}`.
// To simplify parsing, a path segment cannot equal any of the following
// keywords: `blobs`, `uploads`, `actions`, `actionResults`, `operations` and
// `capabilities`.
//
// When attempting an upload, if another client has already completed the upload
// (which may occur in the middle of a single upload if another client uploads
// the same blob concurrently), the request will terminate immediately with
// a response whose `committed_size` is the full size of the uploaded file
// (regardless of how much data was transmitted by the client). If the client
// completes the upload but the
// [Digest][build.bazel.remote.execution.v2.Digest] does not match, an
// `INVALID_ARGUMENT` error will be returned. In either case, the client should
// not attempt to retry the upload.
//
// For downloading blobs, the client must use the
// [Read method][google.bytestream.ByteStream.Read] of the ByteStream API, with
// a `resource_name` of `"{instance_name}/blobs/{hash}/{size}"`, where
// `instance_name` is the instance name (see above), and `hash` and `size` are
// the [Digest][build.bazel.remote.execution.v2.Digest] of the blob.
//
// The lifetime of entries in the CAS is implementation specific, but it SHOULD
// be long enough to allow for newly-added and recently looked-up entries to be
// used in subsequent calls (e.g. to
// [Execute][build.bazel.remote.execution.v2.Execution.Execute]).
//
// Servers MUST behave as though empty blobs are always available, even if they
// have not been uploaded. Clients MAY optimize away the uploading or
// downloading of empty blobs.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class ContentAddressableStorage final {
 public:
  static constexpr char const* service_full_name() {
    return "build.bazel.remote.execution.v2.ContentAddressableStorage";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Determine if blobs are present in the CAS.
    //
    // Clients can use this API before uploading blobs to determine which ones are
    // already present in the CAS and do not need to be uploaded again.
    //
    // Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
    // applicable.
    //
    // There are no method-specific errors.
    virtual ::grpc::Status FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>> AsyncFindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>>(AsyncFindMissingBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>> PrepareAsyncFindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>>(PrepareAsyncFindMissingBlobsRaw(context, request, cq));
    }
    // Upload many blobs at once.
    //
    // The server may enforce a limit of the combined total size of blobs
    // to be uploaded using this API. This limit may be obtained using the
    // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
    // Requests exceeding the limit should either be split into smaller
    // chunks or uploaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling a Bytestream `Write` request
    // on each individual blob, in parallel. The requests may succeed or fail
    // independently.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: The client attempted to upload more than the
    //   server supported limit.
    //
    // Individual requests may return the following errors, additionally:
    //
    // * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
    // * `INVALID_ARGUMENT`: The
    // [Digest][build.bazel.remote.execution.v2.Digest] does not match the
    // provided data.
    virtual ::grpc::Status BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>> AsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>>(AsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>> PrepareAsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>>(PrepareAsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    // Download many blobs at once.
    //
    // The server may enforce a limit of the combined total size of blobs
    // to be downloaded using this API. This limit may be obtained using the
    // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
    // Requests exceeding the limit should either be split into smaller
    // chunks or downloaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling a Bytestream `Read` request
    // on each individual blob, in parallel. The requests may succeed or fail
    // independently.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: The client attempted to read more than the
    //   server supported limit.
    //
    // Every error on individual read will be returned in the corresponding digest
    // status.
    virtual ::grpc::Status BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>> AsyncBatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>>(AsyncBatchReadBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>> PrepareAsyncBatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>>(PrepareAsyncBatchReadBlobsRaw(context, request, cq));
    }
    // Fetch the entire directory tree rooted at a node.
    //
    // This request must be targeted at a
    // [Directory][build.bazel.remote.execution.v2.Directory] stored in the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
    // (CAS). The server will enumerate the `Directory` tree recursively and
    // return every node descended from the root.
    //
    // The GetTreeRequest.page_token parameter can be used to skip ahead in
    // the stream (e.g. when retrying a partially completed and aborted request),
    // by setting it to a value taken from GetTreeResponse.next_page_token of the
    // last successfully processed GetTreeResponse).
    //
    // The exact traversal order is unspecified and, unless retrieving subsequent
    // pages from an earlier request, is not guaranteed to be stable across
    // multiple invocations of `GetTree`.
    //
    // If part of the tree is missing from the CAS, the server will return the
    // portion present and omit the rest.
    //
    // Errors:
    //
    // * `NOT_FOUND`: The requested tree root is not present in the CAS.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>> GetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>>(GetTreeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>> AsyncGetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>>(AsyncGetTreeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>> PrepareAsyncGetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>>(PrepareAsyncGetTreeRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Determine if blobs are present in the CAS.
      //
      // Clients can use this API before uploading blobs to determine which ones are
      // already present in the CAS and do not need to be uploaded again.
      //
      // Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
      // applicable.
      //
      // There are no method-specific errors.
      virtual void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Upload many blobs at once.
      //
      // The server may enforce a limit of the combined total size of blobs
      // to be uploaded using this API. This limit may be obtained using the
      // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
      // Requests exceeding the limit should either be split into smaller
      // chunks or uploaded using the
      // [ByteStream API][google.bytestream.ByteStream], as appropriate.
      //
      // This request is equivalent to calling a Bytestream `Write` request
      // on each individual blob, in parallel. The requests may succeed or fail
      // independently.
      //
      // Errors:
      //
      // * `INVALID_ARGUMENT`: The client attempted to upload more than the
      //   server supported limit.
      //
      // Individual requests may return the following errors, additionally:
      //
      // * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
      // * `INVALID_ARGUMENT`: The
      // [Digest][build.bazel.remote.execution.v2.Digest] does not match the
      // provided data.
      virtual void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Download many blobs at once.
      //
      // The server may enforce a limit of the combined total size of blobs
      // to be downloaded using this API. This limit may be obtained using the
      // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
      // Requests exceeding the limit should either be split into smaller
      // chunks or downloaded using the
      // [ByteStream API][google.bytestream.ByteStream], as appropriate.
      //
      // This request is equivalent to calling a Bytestream `Read` request
      // on each individual blob, in parallel. The requests may succeed or fail
      // independently.
      //
      // Errors:
      //
      // * `INVALID_ARGUMENT`: The client attempted to read more than the
      //   server supported limit.
      //
      // Every error on individual read will be returned in the corresponding digest
      // status.
      virtual void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Fetch the entire directory tree rooted at a node.
      //
      // This request must be targeted at a
      // [Directory][build.bazel.remote.execution.v2.Directory] stored in the
      // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
      // (CAS). The server will enumerate the `Directory` tree recursively and
      // return every node descended from the root.
      //
      // The GetTreeRequest.page_token parameter can be used to skip ahead in
      // the stream (e.g. when retrying a partially completed and aborted request),
      // by setting it to a value taken from GetTreeResponse.next_page_token of the
      // last successfully processed GetTreeResponse).
      //
      // The exact traversal order is unspecified and, unless retrieving subsequent
      // pages from an earlier request, is not guaranteed to be stable across
      // multiple invocations of `GetTree`.
      //
      // If part of the tree is missing from the CAS, the server will return the
      // portion present and omit the rest.
      //
      // Errors:
      //
      // * `NOT_FOUND`: The requested tree root is not present in the CAS.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTree(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::ClientReadReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* reactor) = 0;
      #else
      virtual void GetTree(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::experimental::ClientReadReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* AsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* PrepareAsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* AsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* PrepareAsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* AsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* PrepareAsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>* GetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>* AsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::build::bazel::remote::execution::v2::GetTreeResponse>* PrepareAsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>> AsyncFindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>>(AsyncFindMissingBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>> PrepareAsyncFindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>>(PrepareAsyncFindMissingBlobsRaw(context, request, cq));
    }
    ::grpc::Status BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>> AsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>>(AsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>> PrepareAsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>>(PrepareAsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    ::grpc::Status BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>> AsyncBatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>>(AsyncBatchReadBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>> PrepareAsyncBatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>>(PrepareAsyncBatchReadBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::build::bazel::remote::execution::v2::GetTreeResponse>> GetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::build::bazel::remote::execution::v2::GetTreeResponse>>(GetTreeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>> AsyncGetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>>(AsyncGetTreeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>> PrepareAsyncGetTree(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>>(PrepareAsyncGetTreeRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTree(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::ClientReadReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* reactor) override;
      #else
      void GetTree(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::experimental::ClientReadReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* AsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* PrepareAsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* AsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* PrepareAsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* AsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* PrepareAsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* GetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request) override;
    ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* AsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* PrepareAsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FindMissingBlobs_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchUpdateBlobs_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchReadBlobs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTree_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Determine if blobs are present in the CAS.
    //
    // Clients can use this API before uploading blobs to determine which ones are
    // already present in the CAS and do not need to be uploaded again.
    //
    // Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
    // applicable.
    //
    // There are no method-specific errors.
    virtual ::grpc::Status FindMissingBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response);
    // Upload many blobs at once.
    //
    // The server may enforce a limit of the combined total size of blobs
    // to be uploaded using this API. This limit may be obtained using the
    // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
    // Requests exceeding the limit should either be split into smaller
    // chunks or uploaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling a Bytestream `Write` request
    // on each individual blob, in parallel. The requests may succeed or fail
    // independently.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: The client attempted to upload more than the
    //   server supported limit.
    //
    // Individual requests may return the following errors, additionally:
    //
    // * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
    // * `INVALID_ARGUMENT`: The
    // [Digest][build.bazel.remote.execution.v2.Digest] does not match the
    // provided data.
    virtual ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response);
    // Download many blobs at once.
    //
    // The server may enforce a limit of the combined total size of blobs
    // to be downloaded using this API. This limit may be obtained using the
    // [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
    // Requests exceeding the limit should either be split into smaller
    // chunks or downloaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling a Bytestream `Read` request
    // on each individual blob, in parallel. The requests may succeed or fail
    // independently.
    //
    // Errors:
    //
    // * `INVALID_ARGUMENT`: The client attempted to read more than the
    //   server supported limit.
    //
    // Every error on individual read will be returned in the corresponding digest
    // status.
    virtual ::grpc::Status BatchReadBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response);
    // Fetch the entire directory tree rooted at a node.
    //
    // This request must be targeted at a
    // [Directory][build.bazel.remote.execution.v2.Directory] stored in the
    // [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
    // (CAS). The server will enumerate the `Directory` tree recursively and
    // return every node descended from the root.
    //
    // The GetTreeRequest.page_token parameter can be used to skip ahead in
    // the stream (e.g. when retrying a partially completed and aborted request),
    // by setting it to a value taken from GetTreeResponse.next_page_token of the
    // last successfully processed GetTreeResponse).
    //
    // The exact traversal order is unspecified and, unless retrieving subsequent
    // pages from an earlier request, is not guaranteed to be stable across
    // multiple invocations of `GetTree`.
    //
    // If part of the tree is missing from the CAS, the server will return the
    // portion present and omit the rest.
    //
    // Errors:
    //
    // * `NOT_FOUND`: The requested tree root is not present in the CAS.
    virtual ::grpc::Status GetTree(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMissingBlobs(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUpdateBlobs(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchReadBlobs() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchReadBlobs(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTree() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTree(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::ServerAsyncWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FindMissingBlobs<WithAsyncMethod_BatchUpdateBlobs<WithAsyncMethod_BatchReadBlobs<WithAsyncMethod_GetTree<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FindMissingBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response) { return this->FindMissingBlobs(context, request, response); }));}
    void SetMessageAllocatorFor_FindMissingBlobs(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FindMissingBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FindMissingBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BatchUpdateBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response) { return this->BatchUpdateBlobs(context, request, response); }));}
    void SetMessageAllocatorFor_BatchUpdateBlobs(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BatchUpdateBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BatchUpdateBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BatchReadBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response) { return this->BatchReadBlobs(context, request, response); }));}
    void SetMessageAllocatorFor_BatchReadBlobs(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BatchReadBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BatchReadBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::build::bazel::remote::execution::v2::GetTreeRequest, ::build::bazel::remote::execution::v2::GetTreeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::GetTreeRequest* request) { return this->GetTree(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* GetTree(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* GetTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_FindMissingBlobs<ExperimentalWithCallbackMethod_BatchUpdateBlobs<ExperimentalWithCallbackMethod_BatchReadBlobs<ExperimentalWithCallbackMethod_GetTree<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_FindMissingBlobs<ExperimentalWithCallbackMethod_BatchUpdateBlobs<ExperimentalWithCallbackMethod_BatchReadBlobs<ExperimentalWithCallbackMethod_GetTree<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchReadBlobs() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTree() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMissingBlobs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUpdateBlobs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchReadBlobs() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchReadBlobs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTree() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FindMissingBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FindMissingBlobs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FindMissingBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FindMissingBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BatchUpdateBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchUpdateBlobs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BatchUpdateBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BatchUpdateBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BatchReadBlobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchReadBlobs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BatchReadBlobs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BatchReadBlobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetTree(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* streamer) {
                       return this->StreamedFindMissingBlobs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindMissingBlobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::FindMissingBlobsRequest,::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* streamer) {
                       return this->StreamedBatchUpdateBlobs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchUpdateBlobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest,::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchReadBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchReadBlobs() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* streamer) {
                       return this->StreamedBatchReadBlobs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchReadBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchReadBlobs(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* /*request*/, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchReadBlobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::BatchReadBlobsRequest,::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FindMissingBlobs<WithStreamedUnaryMethod_BatchUpdateBlobs<WithStreamedUnaryMethod_BatchReadBlobs<Service > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetTree() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::build::bazel::remote::execution::v2::GetTreeRequest, ::build::bazel::remote::execution::v2::GetTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::build::bazel::remote::execution::v2::GetTreeRequest, ::build::bazel::remote::execution::v2::GetTreeResponse>* streamer) {
                       return this->StreamedGetTree(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetTreeRequest* /*request*/, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetTree(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::build::bazel::remote::execution::v2::GetTreeRequest,::build::bazel::remote::execution::v2::GetTreeResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetTree<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_FindMissingBlobs<WithStreamedUnaryMethod_BatchUpdateBlobs<WithStreamedUnaryMethod_BatchReadBlobs<WithSplitStreamingMethod_GetTree<Service > > > > StreamedService;
};

// The Capabilities service may be used by remote execution clients to query
// various server properties, in order to self-configure or return meaningful
// error messages.
//
// The query may include a particular `instance_name`, in which case the values
// returned will pertain to that instance.
class Capabilities final {
 public:
  static constexpr char const* service_full_name() {
    return "build.bazel.remote.execution.v2.Capabilities";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GetCapabilities returns the server capabilities configuration of the
    // remote endpoint.
    // Only the capabilities of the services supported by the endpoint will
    // be returned:
    // * Execution + CAS + Action Cache endpoints should return both
    //   CacheCapabilities and ExecutionCapabilities.
    // * Execution only endpoints should return ExecutionCapabilities.
    // * CAS + Action Cache only endpoints should return CacheCapabilities.
    virtual ::grpc::Status GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::build::bazel::remote::execution::v2::ServerCapabilities* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>> AsyncGetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>>(AsyncGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>> PrepareAsyncGetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>>(PrepareAsyncGetCapabilitiesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // GetCapabilities returns the server capabilities configuration of the
      // remote endpoint.
      // Only the capabilities of the services supported by the endpoint will
      // be returned:
      // * Execution + CAS + Action Cache endpoints should return both
      //   CacheCapabilities and ExecutionCapabilities.
      // * Execution only endpoints should return ExecutionCapabilities.
      // * CAS + Action Cache only endpoints should return CacheCapabilities.
      virtual void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>* AsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::build::bazel::remote::execution::v2::ServerCapabilities>* PrepareAsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::build::bazel::remote::execution::v2::ServerCapabilities* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>> AsyncGetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>>(AsyncGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>> PrepareAsyncGetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>>(PrepareAsyncGetCapabilitiesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>* AsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>* PrepareAsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetCapabilities_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GetCapabilities returns the server capabilities configuration of the
    // remote endpoint.
    // Only the capabilities of the services supported by the endpoint will
    // be returned:
    // * Execution + CAS + Action Cache endpoints should return both
    //   CacheCapabilities and ExecutionCapabilities.
    // * Execution only endpoints should return ExecutionCapabilities.
    // * CAS + Action Cache only endpoints should return CacheCapabilities.
    virtual ::grpc::Status GetCapabilities(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCapabilities() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCapabilities(::grpc::ServerContext* context, ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::build::bazel::remote::execution::v2::ServerCapabilities>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetCapabilities<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response) { return this->GetCapabilities(context, request, response); }));}
    void SetMessageAllocatorFor_GetCapabilities(
        ::grpc::experimental::MessageAllocator< ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetCapabilities<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetCapabilities<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCapabilities() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCapabilities() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCapabilities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCapabilities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCapabilities() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>* streamer) {
                       return this->StreamedGetCapabilities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCapabilities(::grpc::ServerContext* /*context*/, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* /*request*/, ::build::bazel::remote::execution::v2::ServerCapabilities* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCapabilities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::build::bazel::remote::execution::v2::GetCapabilitiesRequest,::build::bazel::remote::execution::v2::ServerCapabilities>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetCapabilities<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetCapabilities<Service > StreamedService;
};

}  // namespace v2
}  // namespace execution
}  // namespace remote
}  // namespace bazel
}  // namespace build


#endif  // GRPC_build_2fbazel_2fremote_2fexecution_2fv2_2fremote_5fexecution_2eproto__INCLUDED
