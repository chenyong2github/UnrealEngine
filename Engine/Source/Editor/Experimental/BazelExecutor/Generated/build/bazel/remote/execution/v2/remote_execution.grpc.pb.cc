//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//-V::568,590
#include "CoreMinimal.h"
#include "Misc/CoreMiscDefines.h"

THIRD_PARTY_INCLUDES_START
UE_PUSH_MACRO("TEXT")
#undef TEXT

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: build/bazel/remote/execution/v2/remote_execution.proto

#include "build/bazel/remote/execution/v2/remote_execution.pb.h"
#include "build/bazel/remote/execution/v2/remote_execution.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace build {
namespace bazel {
namespace remote {
namespace execution {
namespace v2 {

static const char* Execution_method_names[] = {
  "/build.bazel.remote.execution.v2.Execution/Execute",
  "/build.bazel.remote.execution.v2.Execution/WaitExecution",
};

std::unique_ptr< Execution::Stub> Execution::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Execution::Stub> stub(new Execution::Stub(channel));
  return stub;
}

Execution::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Execute_(Execution_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_WaitExecution_(Execution_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::ClientReader< ::google::longrunning::Operation>* Execution::Stub::ExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request) {
  return ::grpc::internal::ClientReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), rpcmethod_Execute_, context, request);
}

void Execution::Stub::experimental_async::Execute(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::google::longrunning::Operation>::Create(stub_->channel_.get(), stub_->rpcmethod_Execute_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::google::longrunning::Operation>* Execution::Stub::AsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), cq, rpcmethod_Execute_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::google::longrunning::Operation>* Execution::Stub::PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), cq, rpcmethod_Execute_, context, request, false, nullptr);
}

::grpc::ClientReader< ::google::longrunning::Operation>* Execution::Stub::WaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request) {
  return ::grpc::internal::ClientReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), rpcmethod_WaitExecution_, context, request);
}

void Execution::Stub::experimental_async::WaitExecution(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::experimental::ClientReadReactor< ::google::longrunning::Operation>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::google::longrunning::Operation>::Create(stub_->channel_.get(), stub_->rpcmethod_WaitExecution_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::google::longrunning::Operation>* Execution::Stub::AsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), cq, rpcmethod_WaitExecution_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::google::longrunning::Operation>* Execution::Stub::PrepareAsyncWaitExecutionRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::google::longrunning::Operation>::Create(channel_.get(), cq, rpcmethod_WaitExecution_, context, request, false, nullptr);
}

Execution::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Execution_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Execution::Service, ::build::bazel::remote::execution::v2::ExecuteRequest, ::google::longrunning::Operation>(
          [](Execution::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::ExecuteRequest* req,
             ::grpc::ServerWriter<::google::longrunning::Operation>* writer) {
               return service->Execute(ctx, req, writer);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Execution_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Execution::Service, ::build::bazel::remote::execution::v2::WaitExecutionRequest, ::google::longrunning::Operation>(
          [](Execution::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::WaitExecutionRequest* req,
             ::grpc::ServerWriter<::google::longrunning::Operation>* writer) {
               return service->WaitExecution(ctx, req, writer);
             }, this)));
}

Execution::Service::~Service() {
}

::grpc::Status Execution::Service::Execute(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::ExecuteRequest* request, ::grpc::ServerWriter< ::google::longrunning::Operation>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Execution::Service::WaitExecution(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::WaitExecutionRequest* request, ::grpc::ServerWriter< ::google::longrunning::Operation>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* ActionCache_method_names[] = {
  "/build.bazel.remote.execution.v2.ActionCache/GetActionResult",
  "/build.bazel.remote.execution.v2.ActionCache/UpdateActionResult",
};

std::unique_ptr< ActionCache::Stub> ActionCache::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ActionCache::Stub> stub(new ActionCache::Stub(channel));
  return stub;
}

ActionCache::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetActionResult_(ActionCache_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UpdateActionResult_(ActionCache_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status ActionCache::Stub::GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetActionResult_, context, request, response);
}

void ActionCache::Stub::experimental_async::GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetActionResult_, context, request, response, std::move(f));
}

void ActionCache::Stub::experimental_async::GetActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetActionResult_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* ActionCache::Stub::PrepareAsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::ActionResult>::Create(channel_.get(), cq, rpcmethod_GetActionResult_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* ActionCache::Stub::AsyncGetActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetActionResultRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ActionCache::Stub::UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::build::bazel::remote::execution::v2::ActionResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_UpdateActionResult_, context, request, response);
}

void ActionCache::Stub::experimental_async::UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_UpdateActionResult_, context, request, response, std::move(f));
}

void ActionCache::Stub::experimental_async::UpdateActionResult(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_UpdateActionResult_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* ActionCache::Stub::PrepareAsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::ActionResult>::Create(channel_.get(), cq, rpcmethod_UpdateActionResult_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ActionResult>* ActionCache::Stub::AsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncUpdateActionResultRaw(context, request, cq);
  result->StartCall();
  return result;
}

ActionCache::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ActionCache_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ActionCache::Service, ::build::bazel::remote::execution::v2::GetActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
          [](ActionCache::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::GetActionResultRequest* req,
             ::build::bazel::remote::execution::v2::ActionResult* resp) {
               return service->GetActionResult(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ActionCache_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ActionCache::Service, ::build::bazel::remote::execution::v2::UpdateActionResultRequest, ::build::bazel::remote::execution::v2::ActionResult>(
          [](ActionCache::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* req,
             ::build::bazel::remote::execution::v2::ActionResult* resp) {
               return service->UpdateActionResult(ctx, req, resp);
             }, this)));
}

ActionCache::Service::~Service() {
}

::grpc::Status ActionCache::Service::GetActionResult(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ActionCache::Service::UpdateActionResult(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::UpdateActionResultRequest* request, ::build::bazel::remote::execution::v2::ActionResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* ContentAddressableStorage_method_names[] = {
  "/build.bazel.remote.execution.v2.ContentAddressableStorage/FindMissingBlobs",
  "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchUpdateBlobs",
  "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchReadBlobs",
  "/build.bazel.remote.execution.v2.ContentAddressableStorage/GetTree",
};

std::unique_ptr< ContentAddressableStorage::Stub> ContentAddressableStorage::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ContentAddressableStorage::Stub> stub(new ContentAddressableStorage::Stub(channel));
  return stub;
}

ContentAddressableStorage::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_FindMissingBlobs_(ContentAddressableStorage_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_BatchUpdateBlobs_(ContentAddressableStorage_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_BatchReadBlobs_(ContentAddressableStorage_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetTree_(ContentAddressableStorage_method_names[3], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::Status ContentAddressableStorage::Stub::FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_FindMissingBlobs_, context, request, response);
}

void ContentAddressableStorage::Stub::experimental_async::FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FindMissingBlobs_, context, request, response, std::move(f));
}

void ContentAddressableStorage::Stub::experimental_async::FindMissingBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FindMissingBlobs_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* ContentAddressableStorage::Stub::PrepareAsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>::Create(channel_.get(), cq, rpcmethod_FindMissingBlobs_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>* ContentAddressableStorage::Stub::AsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFindMissingBlobsRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ContentAddressableStorage::Stub::BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_BatchUpdateBlobs_, context, request, response);
}

void ContentAddressableStorage::Stub::experimental_async::BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_BatchUpdateBlobs_, context, request, response, std::move(f));
}

void ContentAddressableStorage::Stub::experimental_async::BatchUpdateBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_BatchUpdateBlobs_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* ContentAddressableStorage::Stub::PrepareAsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>::Create(channel_.get(), cq, rpcmethod_BatchUpdateBlobs_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>* ContentAddressableStorage::Stub::AsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBatchUpdateBlobsRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ContentAddressableStorage::Stub::BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_BatchReadBlobs_, context, request, response);
}

void ContentAddressableStorage::Stub::experimental_async::BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_BatchReadBlobs_, context, request, response, std::move(f));
}

void ContentAddressableStorage::Stub::experimental_async::BatchReadBlobs(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_BatchReadBlobs_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* ContentAddressableStorage::Stub::PrepareAsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>::Create(channel_.get(), cq, rpcmethod_BatchReadBlobs_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>* ContentAddressableStorage::Stub::AsyncBatchReadBlobsRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBatchReadBlobsRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::ClientReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* ContentAddressableStorage::Stub::GetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request) {
  return ::grpc::internal::ClientReaderFactory< ::build::bazel::remote::execution::v2::GetTreeResponse>::Create(channel_.get(), rpcmethod_GetTree_, context, request);
}

void ContentAddressableStorage::Stub::experimental_async::GetTree(::grpc::ClientContext* context, ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::experimental::ClientReadReactor< ::build::bazel::remote::execution::v2::GetTreeResponse>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::build::bazel::remote::execution::v2::GetTreeResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_GetTree_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* ContentAddressableStorage::Stub::AsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::build::bazel::remote::execution::v2::GetTreeResponse>::Create(channel_.get(), cq, rpcmethod_GetTree_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::build::bazel::remote::execution::v2::GetTreeResponse>* ContentAddressableStorage::Stub::PrepareAsyncGetTreeRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::build::bazel::remote::execution::v2::GetTreeResponse>::Create(channel_.get(), cq, rpcmethod_GetTree_, context, request, false, nullptr);
}

ContentAddressableStorage::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ContentAddressableStorage_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ContentAddressableStorage::Service, ::build::bazel::remote::execution::v2::FindMissingBlobsRequest, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse>(
          [](ContentAddressableStorage::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* req,
             ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* resp) {
               return service->FindMissingBlobs(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ContentAddressableStorage_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ContentAddressableStorage::Service, ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse>(
          [](ContentAddressableStorage::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* req,
             ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* resp) {
               return service->BatchUpdateBlobs(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ContentAddressableStorage_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ContentAddressableStorage::Service, ::build::bazel::remote::execution::v2::BatchReadBlobsRequest, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse>(
          [](ContentAddressableStorage::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* req,
             ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* resp) {
               return service->BatchReadBlobs(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ContentAddressableStorage_method_names[3],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< ContentAddressableStorage::Service, ::build::bazel::remote::execution::v2::GetTreeRequest, ::build::bazel::remote::execution::v2::GetTreeResponse>(
          [](ContentAddressableStorage::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::GetTreeRequest* req,
             ::grpc::ServerWriter<::build::bazel::remote::execution::v2::GetTreeResponse>* writer) {
               return service->GetTree(ctx, req, writer);
             }, this)));
}

ContentAddressableStorage::Service::~Service() {
}

::grpc::Status ContentAddressableStorage::Service::FindMissingBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, ::build::bazel::remote::execution::v2::FindMissingBlobsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ContentAddressableStorage::Service::BatchUpdateBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ContentAddressableStorage::Service::BatchReadBlobs(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, ::build::bazel::remote::execution::v2::BatchReadBlobsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ContentAddressableStorage::Service::GetTree(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetTreeRequest* request, ::grpc::ServerWriter< ::build::bazel::remote::execution::v2::GetTreeResponse>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Capabilities_method_names[] = {
  "/build.bazel.remote.execution.v2.Capabilities/GetCapabilities",
};

std::unique_ptr< Capabilities::Stub> Capabilities::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Capabilities::Stub> stub(new Capabilities::Stub(channel));
  return stub;
}

Capabilities::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetCapabilities_(Capabilities_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Capabilities::Stub::GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::build::bazel::remote::execution::v2::ServerCapabilities* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetCapabilities_, context, request, response);
}

void Capabilities::Stub::experimental_async::GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetCapabilities_, context, request, response, std::move(f));
}

void Capabilities::Stub::experimental_async::GetCapabilities(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetCapabilities_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>* Capabilities::Stub::PrepareAsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::build::bazel::remote::execution::v2::ServerCapabilities>::Create(channel_.get(), cq, rpcmethod_GetCapabilities_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::build::bazel::remote::execution::v2::ServerCapabilities>* Capabilities::Stub::AsyncGetCapabilitiesRaw(::grpc::ClientContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetCapabilitiesRaw(context, request, cq);
  result->StartCall();
  return result;
}

Capabilities::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Capabilities_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Capabilities::Service, ::build::bazel::remote::execution::v2::GetCapabilitiesRequest, ::build::bazel::remote::execution::v2::ServerCapabilities>(
          [](Capabilities::Service* service,
             ::grpc::ServerContext* ctx,
             const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* req,
             ::build::bazel::remote::execution::v2::ServerCapabilities* resp) {
               return service->GetCapabilities(ctx, req, resp);
             }, this)));
}

Capabilities::Service::~Service() {
}

::grpc::Status Capabilities::Service::GetCapabilities(::grpc::ServerContext* context, const ::build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, ::build::bazel::remote::execution::v2::ServerCapabilities* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace build
}  // namespace bazel
}  // namespace remote
}  // namespace execution
}  // namespace v2


UE_POP_MACRO("TEXT")
THIRD_PARTY_INCLUDES_END
