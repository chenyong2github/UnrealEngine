// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"

#define STRATA_INLINE_SHADING 0
#define STRATA_MICROFACET_MULTIPLESCATTERING 1

#include "StrataMultipleScattering.ush"
#include "StrataEvaluation.ush"

#define STRATA_INTEGRATION_EVALUATE 0
#define STRATA_INTEGRATION_SAMPLING 1
#define STRATA_INTEGRATION_ENV 2

#if SHADER_FURNACE_ANALYTIC

uint SceneType;
uint IntegratorType;
uint NumSamples;

void MainPS(
	float4 SVPos : SV_POSITION,
	out float3 OutColor : SV_Target0)
{
	const float3 InRadiance = 0.5f;
	OutColor = InRadiance;

	const uint2 ViewResolution = View.ViewSizeAndInvSize.xy;
	const uint TileResolution = 128;
	const uint2 TileCount = ViewResolution / TileResolution;

	const uint2 PixelPos = uint2(SVPos.xy);	
	const float2 UV = PixelPos / float2(ViewResolution);
	const float2 TileUV = frac(UV * TileCount);
	const uint2 TileCoord = floor(UV * TileCount);
	const uint2 TilePixelCoord = TileUV * TileResolution;

	float3 V = float3(0, 0, 1);
	float3 N = 0;
	float3 T = 0;
	bool bEvaluate = false;
	{
		const float3 RayO = float3(TileUV, 1);
		const float3 RayD = -V;
		const float4 Sphere = float4(0.5f, 0.5f, 0.f, 0.4f);
		const float2 Hit = RayIntersectSphere(RayO, RayD, Sphere);
		if (Hit.x >= 0)
		{
			const float3 P = RayO + RayD * Hit.x;
			N = normalize(P - Sphere.xyz);
			T = normalize(cross(float3(0,0,1), N));
			bEvaluate = true;
		}
	}

	// Draw a simple 2D grid of spheres 
	if (bEvaluate)
	{
		// Build a single layer BSDF with white albedo
		FStrataBSDF BSDF = (FStrataBSDF)0;
		{
			const float MinRoughness = 0.02;

			float3 BaseColor = 1;
			float3 EdgeColor = 1;
			float Roughness  = 0.5f;
			float Metallic   = 0.0f;
			float Specular   = 0.5f;
			float Anisoptropy = 0.0f;
			float Haziness    = 0.0f;

			const float X = saturate((TileCoord.x) / float(TileCount.x - 1));
			const float Y = saturate((TileCoord.y) / float(TileCount.y - 1));
			if (SceneType == 1)
			{
				//  ------> Roughness
				// |
				// |
				// v
				// Metallic
				Roughness = max(MinRoughness, X);
				Metallic = Y;
			}
			else if (SceneType == 2)
			{
				//  ------> Roughness
				// |
				// |
				// v
				// Anisotropy
				Roughness   = max(MinRoughness, X);
				Anisoptropy = Y * 2 - 1;
				Metallic    = 1.f;
			}
			else if (SceneType == 3)
			{
				//  ------> Roughness
				// |
				// |
				// v
				// Hazizness
				Roughness = max(MinRoughness, X);
				Haziness  = Y;
				Metallic  = 1.f;
			}
			else if (SceneType == 4)
			{
				// All metalic with different roughness & metal type (F0)
				//  ------> Roughness
				//  -> Silver
				//  -> Aluminium
				//  -> Gold
				//  -> Copper
				const float3 Silver      = float3(0.971519,    0.959915,    0.915324);
				const float3 Aluminium   = float3(0.913183,    0.921494,    0.924524);
				const float3 Gold        = float3(1       ,    0.765557,    0.336057);
				const float3 Copper      = float3(0.955008,    0.637427,    0.538163);
				const float3 Chromium    = float3(0.549585,    0.556114,    0.554256);
				const float3 Nickel      = float3(0.659777,    0.608679,    0.525649);
				const float3 Titanium    = float3(0.541931,    0.496791,    0.449419);
				const float3 Cobalt      = float3(0.662124,    0.654864,    0.633732);
				const float3 Platinum    = float3(0.672411,    0.637331,    0.585456);

				Roughness = max(MinRoughness, X);
				Metallic = 1;
				switch (TileCoord.y)
				{
					case 0: BaseColor = Silver; break;
					case 1: BaseColor = Aluminium; break;
					case 2: BaseColor = Gold; break;
					case 3: BaseColor = Copper; break;
					case 4: BaseColor = Chromium; break;
					case 5: BaseColor = Nickel; break;
					case 6: BaseColor = Titanium; break;
					case 7: BaseColor = Cobalt; break;
				}
			}

			BSDF_SETTYPE(BSDF, STRATA_BSDF_TYPE_SLAB);
			BSDF_SETNORMALID(BSDF, 0);
			BSDF_SETANISOTROPY(BSDF, Anisoptropy != 0 ? 1 : 0);
			BSDF_SETISTOPLAYER(BSDF, 1);
			BSDF_SETHASEDGECOLOR(BSDF, 0);
			BSDF_SETHASSSS(BSDF, 0);
			BSDF_SETHASSSSPROFILE(BSDF, 0);
			BSDF_SETHASHAZINESS(BSDF, Haziness != 0 ? 1 : 0);
			BSDF_SETHASTHINFILM(BSDF, 0);
			BSDF.Weight = 1.0f;

			const float2 RoughnessXY = GetAnisotropicRoughness(Roughness, Anisoptropy);

			SLAB_BASECOLOR(BSDF)	= BaseColor;
			SLAB_EDGECOLOR(BSDF)	= EdgeColor;
			SLAB_ROUGHNESSX(BSDF)	= RoughnessXY.x;
			SLAB_ROUGHNESSY(BSDF)	= RoughnessXY.y;
			SLAB_SPECULAR(BSDF)		= Specular;
			SLAB_METALLIC(BSDF)		= Metallic;
			SLAB_HAZINESS(BSDF)		= Haziness;
		}

		// Sample uniformly the upper hemisphere of each pixel
		float3 Acc = 0;
		const FShadowTerms ShadowTerms = { 1.0f, 1.0, 1.0, InitHairTransmittanceData() };
		float3x3 TangentBasis = GetTangentBasis(N);
		if (BSDF_GETANISOTROPY(BSDF))
		{
			TangentBasis = float3x3(T, normalize(cross(N,T)), N);
		}

		if (IntegratorType == STRATA_INTEGRATION_EVALUATE)
		{
			LOOP
			for (uint SampleIt = 0; SampleIt < NumSamples; ++SampleIt)
			{
				const float2 U = Hammersley(SampleIt, NumSamples, 0);

				const float4 S = UniformSampleHemisphere(U);
				const float3 L = mul(S.xyz, TangentBasis);

				const float SatNoL = saturate(dot(L, N));

				FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(TangentBasis, BSDF, V, L);
				FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(BSDFContext, ShadowTerms);

				const float3 DiffusePathWeight  = BSDF.Weight * BSDFEvaluate.DiffusePathValue;
				const float3 SpecularPathWeight = BSDF.Weight * BSDFEvaluate.SpecularPathValue;

				Acc += SatNoL * InRadiance * (DiffusePathWeight + SpecularPathWeight) / (S.w != 0 ?  S.w : 1);
			}
			OutColor = Acc / max(1, NumSamples);
		}
		else if (IntegratorType == STRATA_INTEGRATION_SAMPLING)
		{
			LOOP
			for (uint SampleIt = 0; SampleIt < NumSamples; ++SampleIt)
			{
				const float2 U = Hammersley(SampleIt, NumSamples, 0);

				const float3 UnusedL = float3(0.0f, 0.0f, 1.0f);
				FStrataBSDFContext BSDFContextIS = StrataCreateBSDFContext(TangentBasis, BSDF, V, UnusedL);
				FStrataImportanceSampleResult S = StrataImportanceSampleBSDF(BSDFContextIS, BSDF, U);

				// Evaluate specular part for now. 
				// Importance sample (STRATA_TODO: change API to support diffuse/specular filter and MIS)
				const float3 L = S.SpecularDirection;
				const float PDF = S.SpecularPDF;
				//const float3 L = S.DiffuseDirection;
				//const float PDF = S.DiffusePDF;

				const float SatNoL = saturate(dot(L, N));
				FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(TangentBasis, BSDF, V, L);
				FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(BSDFContext, ShadowTerms);

				const float3 DiffusePathWeight  = BSDF.Weight * BSDFEvaluate.DiffusePathValue;
				const float3 SpecularPathWeight = BSDF.Weight * BSDFEvaluate.SpecularPathValue;

				Acc += SatNoL * InRadiance * (DiffusePathWeight + SpecularPathWeight) / (PDF != 0 ? PDF : 1);

			}
			OutColor = Acc / max(1, NumSamples);
		}
		else if (IntegratorType == STRATA_INTEGRATION_ENV)
		{
			const float3 BSDFThroughput = BSDF.Weight;

			const float3 UnusedL = float3(0.0f, 0.0f, 1.0f);
			const float3x3 TangentBasis = GetTangentBasis(N);
			FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(TangentBasis, BSDF, V, UnusedL);

			const bool bEnableSpecular = true;
			FStrataEnvLightResult StrataEnvLight = StrataEvaluateForEnvLight(BSDFContext, bEnableSpecular);

			const float3 InIrradiance = InRadiance; //It should have a Pi factor though
			const float3 SpecularSkyLighting = BSDF.Weight * StrataEnvLight.SpecularWeight * InRadiance;
			const float3 DiffuseSkyLighting  = BSDF.Weight * StrataEnvLight.DiffuseColor * InIrradiance;

			OutColor = 
				SpecularSkyLighting + 
				DiffuseSkyLighting;;
		}
	}
}

#endif // SHADER_FURNACE_ANALYTIC

////////////////////////////////////////////////////////////////////////////////////////////////////////////