// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once



float3 StrataEnvironmentLighting(
	float2 BufferUV,
	FGBufferData GBuffer,
	float3 WorldPosition,
	float3 CameraToPixel,
	float3 V,
	float3 AmbientOcclusion,
	FStrataPixelBSDFs PixelBSDFs
	)
{
	float3 SkyLighting = 0;
	for (int i = 0; i < PixelBSDFs.BSDFCount; ++i)
	{
		FStrataBSDF BSDF = PixelBSDFs.BSDFs[i];
		const float3 BSDFThroughput = BSDF.Weight;

		float3 Albedo = 0.0f;
		float3 Normal = 0.0f;
		float3 SpecularLuminance = 0.0f;
		switch (BSDF.BSDFType)
		{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			Albedo = BSDF.Diffuse.Albedo;
			Normal = BSDF.Diffuse.Normal;
		}
		break;
		case STRATA_BSDF_TYPE_DIELECTRIC:
		{
			BRANCH
			if (ReflectionStruct.SkyLightParameters.y > 0)
			{
				float F0 = DielectricIorToF0(BSDF.Dielectric.IOR);

				const float SafeRoughness = MakeRoughnessSafe(BSDF.Dielectric.Roughness.x);
				float a2 = Pow4(SafeRoughness);
				float Energy = 1.0f; // See EnergyNormalization

				// Generalized microfacet specular
				//float D = D_GGX(a2, Context.NoH) * Energy;
				//float Vis = Vis_SmithJointApprox(a2, Context.NoV, SatNoL);
				//float3 F = F_Schlick(F0, Context.VoH);

				const float3 N = BSDF.Dielectric.Normal;
				const float SatNoV = saturate(dot(N, V));
				float3 R = 2 * dot(V, N) * N - V;

				float3 EvalEnvBRDF = EnvBRDFApprox(F0, SafeRoughness, SatNoV);
				float SkyAverageBrightness = 1.0f;
				SpecularLuminance += GetSkyLightReflection(R, SafeRoughness, SkyAverageBrightness) * EvalEnvBRDF * BSDF.Dielectric.Tint;
			}
		}
		break;
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			BRANCH
			if (ReflectionStruct.SkyLightParameters.y > 0)
			{
				// See SpecularGGX, isotropic verion

				const float SafeRoughness = MakeRoughnessSafe(BSDF.Conductor.Roughness.x);
				float a2 = Pow4(SafeRoughness);
				float Energy = 1.0f; // See EnergyNormalization

				// Generalized microfacet specular
				//float D = D_GGX(a2, Context.NoH) * Energy;
				//float Vis = Vis_SmithJointApprox(a2, Context.NoV, SatNoL);
				//float3 F = F_Schlick(BSDF.Conductor.Reflectivity, BSDF.Conductor.EdgeColor, Context.VoH); // STRATA_TODO check that this is correct 

				const float3 N = BSDF.Conductor.Normal;
				const float SatNoV = saturate(dot(N, V));
				float3 R = 2 * dot(V, N) * N - V;

				float3 EvalEnvBRDF = EnvBRDFApprox(BSDF.Conductor.Reflectivity, BSDF.Conductor.EdgeColor, SafeRoughness, SatNoV);
				float SkyAverageBrightness = 1.0f;
				SpecularLuminance += GetSkyLightReflection(R, SafeRoughness, SkyAverageBrightness) * EvalEnvBRDF;
			}
		}
		break;
		case STRATA_BSDF_TYPE_VOLUME:
		{
			const float3 VolumeAlbedo = BSDF.Volume.Albedo;
			const float3 ExtinctionCoefficients = BSDF.Volume.Extinction;
			const float3 ScatteringCoefficients = VolumeAlbedo * ExtinctionCoefficients;
			const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
			const float  Thickness = BSDF.Volume.Thickness;

			const float3 SafeExtinctionThreshold = 0.000001f;
			const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

			const float SatNoV = saturate(dot(GBuffer.WorldNormal, V));
			const float PathLength = Thickness / max(0.0001f, SatNoV);
			const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
			const float3 NormLuminanceTransfert = 1.0f * ScatteringCoefficients;
			float3 NormLuminanceSingleScattering = (NormLuminanceTransfert - NormLuminanceTransfert * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;

			// No phase function because the SH already contains integration of BSDF with respect to hemisphere. Incorrect but needed.
			Albedo = NormLuminanceSingleScattering;

			// STRATA_TODO: This is to fake some directionality. Have normal specified on the material as for MaterialX?
			Normal = GBuffer.WorldNormal;
		}
		break;
		}

		// Diffuse component
		if (any(Albedo > 0.0f))
		{
			// Apply bent normal if needed
			#if APPLY_SKY_SHADOWING
			{
				Normal = UpsampleDFAO(BufferUV, GBuffer.Depth, Normal); // Bent normal
			}
			#endif

			// Compute the common sky visibility factors
			FSkyLightVisibilityData SkyVisData = GetSkyLightVisibilityData(GBuffer, AmbientOcclusion, Normal);

			// Finally sample the sky diffuse contribution (spherical harmonic, Lambert BRDF)
			float3 DiffuseLookup = GetSkySHDiffuse(Normal) * View.SkyLightColor.rgb;			// STRATA_TODO compute SH coefficients for ON or Chan
			// And accumulate
			SkyLighting += BSDFThroughput * (SkyVisData.SkyDiffuseLookUpMul * DiffuseLookup + SkyVisData.SkyDiffuseLookUpAdd) * Albedo;
		}

		// Specular component
		SkyLighting += BSDFThroughput * SpecularLuminance * View.SkyLightColor.rgb * AmbientOcclusion;
	}
#if USE_PREEXPOSURE
	SkyLighting *= View.PreExposure;
#endif
	return SkyLighting;
}


