// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once



float3 StrataForwardLighting(
	FGBufferData GBuffer,
	float3 MaterialParametersWorldNormal,
	float3 V,
	float3 L,
	float3 LColor,
	float3 LShadow,
	float3 IndirectOcclusion,
	FStrataPixelHeader Header,
	FStrataData Strata,
	inout float3 OutThroughput
	)
{
	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;

	float3 Color = 0;
	OutThroughput = 1.0f;

	UNROLL
	for (int l = 0; l < Strata.LayerCount; ++l)
	{
		float3 LayerThroughput = 0.0f;
		float3 LayerCoverage = 0.0f;

		UNROLL
		for (int i = 0; i < Strata.Layers[l].BSDFCount; ++i)
		{
			FStrataBSDF BSDF = Strata.Layers[l].BSDFs[i];

			// Sanitize BSDF before it is used for forward shading
			StrataSanitizeBSDF(BSDF);

			const float3 BSDFCoverage = BSDF.Weight;

			// Create the BSDF context
			FStrataBSDFContext StrataBSDFContext = StrataCreateBSDFContext(Header, BSDF, V, L);

			// Compute some common factors
			const float3 DirLightBaseFactor = OutThroughput * BSDFCoverage * LColor * LShadow;
			const float3 DirLightGeometryFactor = DirLightBaseFactor * StrataBSDFContext.SatNoL;
			const float3 SkyLightCommonFactor = OutThroughput * BSDFCoverage * ResolvedView.SkyLightColor.rgb * IndirectOcclusion;

			// Evaluate environment lighting
			const bool bEnableSpecular = ReflectionStruct.SkyLightParameters.y > 0.0f;
			FStrataEnvLightResult StrataEnvLight = StrataEvaluateForEnvLight(StrataBSDFContext, bEnableSpecular);
			if (any(StrataEnvLight.DiffuseAlbedo > 0.0f))
			{
				// SkySHDiffuse is pre integrated according to a Lambert diffuse lobe. Thus, we need to rescale to account for the phase function operating over 4PI.
				// We apply a 2PI factor to recover average luminance over half hemisphere, and then times the phase function to account for the scattering events.
				const float VolumeOnlyFactor = BSDF_GETTYPE(BSDF) == STRATA_BSDF_TYPE_VOLUME ? 2.0f * PI * IsotropicPhase() : 1.0f;

				Color += GetEffectiveSkySHDiffuse(StrataEnvLight.DiffuseNormal) * StrataEnvLight.DiffuseAlbedo * SkyLightCommonFactor * VolumeOnlyFactor;
			}
			if (any(StrataEnvLight.SpecularWeight > 0.0f))
			{
				float SkyAverageBrightness = 1.0f;
				Color += GetSkyLightReflection(StrataEnvLight.SpecularDirection, StrataEnvLight.SpecularSafeRoughness, SkyAverageBrightness) * StrataEnvLight.SpecularWeight * SkyLightCommonFactor;
			}

			// Evalaute the lighting coming from L (it will lso contain the BSDF throughput to the next layer)
			FStrataEvaluateResult StrataEvaluate = StrataEvaluateBSDF(StrataBSDFContext);
			Color += StrataEvaluate.Value * DirLightGeometryFactor;

			LayerCoverage	+= BSDFCoverage;
			LayerThroughput += BSDFCoverage * StrataEvaluate.Throughput;
		}

		// Take into account the non covered part for this layer and update throughput accordingly
		LayerThroughput += (1.0 - saturate(LayerCoverage)) * FullThroughput;

		// And combine this layer throughtput with he material throughput
		OutThroughput *= LayerThroughput;
	}
	return Color;
}


