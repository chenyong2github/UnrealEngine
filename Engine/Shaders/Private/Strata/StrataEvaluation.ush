// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Strata.ush"
#include "StrataMultipleScattering.ush"

#include "../ParticipatingMediaCommon.ush"
#include "../MonteCarlo.ush"
#include "../SHCommon.ush"
#include "../ShadingModels.ush"
#include "../ThinFilmBSDF.ush"



#ifndef STRATA_FASTPATH 
#define STRATA_FASTPATH 0
#endif

#ifndef STRATA_USE_ENV_BRDF_APPROX
#define STRATA_USE_ENV_BRDF_APPROX 0
#endif

#ifndef STRATA_TRANSLUCENT_ENABLED
#define STRATA_TRANSLUCENT_ENABLED 0
#endif

#ifndef STRATA_MICROFACET_MULTIPLESCATTERING
#define STRATA_MICROFACET_MULTIPLESCATTERING 0
#endif

#ifndef STRATA_SSS_TRANSMISSION
#define STRATA_SSS_TRANSMISSION 0
#endif

// STRATA_TODO put in a common file
// Point lobe in off-specular peak direction
float3 StrataGetOffSpecularPeakReflectionDir(float3 Normal, float3 ReflectionVector, float Roughness)
{
	float a = Square(Roughness);
	return lerp(Normal, ReflectionVector, (1 - a) * (sqrt(1 - a) + a));
}

// When haziness is used, both lobes take equal part in the blending. Only roughness changes.
#define SPECULAR_HAZINESS_WEIGHT 0.5f



///////////////////////////////////////////////////////////////////////////////
// BSDF evaluate and sampling

struct FStrataBSDFContext
{
	FStrataBSDF BSDF;

	float3 N;
	float3 X;
	float3 Y;
	float3 V;
	float3 R;
	float3 H;

	float3 L;	// There to initialise the BxDFContext. Only used by StrataEvaluateBSDF, not by StrataImportanceSampleBSDF or StrataEvaluateForEnvLight

	BxDFContext Context;
	float SatNoL;
	float SatNoV;

	float3x3 TangentBasis;
	float3 TangentV;
	float3 TangentH;

	// Preprocessed roughness override used for specular BSDF evaluation when integration area light (using MRP integrator)
	float a2Override;
	float a2OverrideHazy;
};

void StrataGetBSDFRoughness(in FStrataBSDF BSDF, inout float R)
{
	R = 0;
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	switch (BSDFType)
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		R = SLAB_ROUGHNESSX(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_HAIR:
	{
		R = HAIR_ROUGHNESS(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		R = SLW_ROUGHNESS(BSDF);
		break;
	}
	}
}

FStrataBSDFContext StrataCreateBSDFContext(float3x3 TangentBasis, FStrataBSDF BSDF, float3 V, float3 L, bool bHasValidL=true)
{
	FStrataBSDFContext BSDFContext = (FStrataBSDFContext)0;

	BSDFContext.BSDF = BSDF;

	BSDFContext.X = TangentBasis[0]; 
	BSDFContext.Y = TangentBasis[1];
	BSDFContext.N = TangentBasis[2]; 
	BSDFContext.V = V;
	BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
	BSDFContext.L = bHasValidL ? L : BSDFContext.R;
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);

	BSDFContext.Context = (BxDFContext)0;
	if (BSDF_GETANISOTROPY(BSDF) != 0)
	{
		Init(BSDFContext.Context, BSDFContext.N, BSDFContext.X, BSDFContext.Y, BSDFContext.V, BSDFContext.L);
	}
	else
	{
		Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, BSDFContext.L);
	}
	BSDFContext.TangentBasis = float3x3(BSDFContext.X, BSDFContext.Y, BSDFContext.N);

	BSDFContext.TangentV = mul(BSDFContext.TangentBasis, BSDFContext.V);
	BSDFContext.TangentH = mul(BSDFContext.TangentBasis, BSDFContext.H);

	BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
	BSDFContext.SatNoV = saturate(BSDFContext.Context.NoV);

	return BSDFContext;
}

FStrataBSDFContext StrataCreateBSDFContext(FStrataPixelHeader StrataPixelHeader, FStrataBSDF BSDF, const FStrataAddressing StrataAddressing, float3 V)
{
	float3 UnusedL = float3(0, 0, 1);
	float3x3 TangentBasis = StrataGetBSDFSharedBasis(StrataPixelHeader, BSDF, StrataAddressing);
	return StrataCreateBSDFContext(TangentBasis, BSDF, V, UnusedL, false);
}

FStrataBSDFContext StrataCreateBSDFContext(FStrataPixelHeader StrataPixelHeader, FStrataBSDF BSDF, const FStrataAddressing StrataAddressing, float3 V, float3 L)
{
	float3x3 TangentBasis = StrataGetBSDFSharedBasis(StrataPixelHeader, BSDF, StrataAddressing);
	return StrataCreateBSDFContext(TangentBasis, BSDF, V, L, true);
}

void StrataUpdateBSDFContext(inout FStrataBSDFContext BSDFContext, float3 NewL)
{
	// Update all the data related to L
	BSDFContext.L = NewL;
	Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, BSDFContext.L);
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);
	BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
	BSDFContext.TangentH = mul(BSDFContext.H, BSDFContext.TangentBasis);
	BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
	BSDFContext.SatNoV = saturate(BSDFContext.Context.NoV);
}

struct FStrataEvaluateResult
{
	float3 EmissivePathValue;

	float3 DiffusePathValue;
	float3 SpecularPathValue;
	float3 SpecularHazePathValue;
	float3 TransmissionPathValue;
	float3 ThinTransmissionPathValue;

	// The following probabilities are part of the pdf to work correctly with a monter carlo based integrator and as expected are not applied on the xxxPathValue.
	// So PathProbability should be applied on PathValue in the rasteriser to recover the correct balance.
	float SpecularPathProbability;
	float SpecularHazePathProbability;

	float  DiffusePDF;
	float  SpecularPDF;
	float  SpecularHazePDF;
	float  TransmissionPDF;
	float  ThinTransmissionPathPDF;

	float3 Throughput;					// Throughput to the next layer
	bool   bSubsurface;					// True if we need to separate the subsurface light contribution for the screen space diffusion process.
	bool   bApplyProjectedSolidAngle;	// True if the Saturate(NoL) factor should be applied or not over the value of the BSDF
};

float StrataBSDFProjectedSolidAngleFactor(in FStrataBSDFContext BSDFContext)
{
	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	return BSDFType == STRATA_BSDF_TYPE_HAIR ? 1.0f : BSDFContext.SatNoL;
}

float StrataBSDFBackFaceProjectedSolidAngleFactor(in FStrataBSDFContext BSDFContext)
{
	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	return BSDFType == STRATA_BSDF_TYPE_HAIR ? 1.0f : saturate(-BSDFContext.Context.NoL);
}

#if STRATA_MICROFACET_MULTIPLESCATTERING

FStrataGGXLUTResult StrataEvaluateGGXLUT(float3 DiffuseAlbedo, float3 F0, float NoV, float Metallic, float SafeRoughnessX, float SafeRoughnessY)
{
#if STRATA_TRANSLUCENT_ENABLED
	return StrataSampleGGXLUT(
		TranslucentBasePass.Strata.GGXEnergyLUT2DTexture, TranslucentBasePass.Strata.GGXEnergyLUT3DTexture, TranslucentBasePass.Strata.GGXEnergyLUTSampler,
		TranslucentBasePass.Strata.GGXEnergyLUTScaleBias, NoV, SafeRoughnessX, SafeRoughnessY, F0, Metallic, DiffuseAlbedo);
#else
	return StrataSampleGGXLUT(
		Strata.GGXEnergyLUT2DTexture, Strata.GGXEnergyLUT3DTexture, Strata.GGXEnergyLUTSampler,
		Strata.GGXEnergyLUTScaleBias, NoV, SafeRoughnessX, SafeRoughnessY, F0, Metallic, DiffuseAlbedo);
#endif
}

#else // STRATA_MICROFACET_MULTIPLESCATTERING

float3 StrataEnvBRDF(float3 F0, float3 F90, float SafeRoughnessX, float SatNoV)
{
#if STRATA_USE_ENV_BRDF_APPROX
	return EnvBRDFApprox(F0, F90, SafeRoughnessX, SatNoV);
#else
	return EnvBRDF(F0, F90, SafeRoughnessX, SatNoV);
#endif
}

#endif // STRATA_MICROFACET_MULTIPLESCATTERING



FStrataEvaluateResult StrataEvaluateBSDF(FStrataBSDFContext BSDFContext, FShadowTerms ShadowTerms)
{
	FStrataEvaluateResult Sample = (FStrataEvaluateResult)0;

	const float OpaqueBSDFThroughput = 0.0f;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const bool bHasSubsurface = BSDF_GETHASSSS(BSDFContext.BSDF) > 0;
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);
			const float3 DiffuseColor = BaseColor - BaseColor * Metallic;
			const float SafeRoughness = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			float a2 = Pow4(SafeRoughness);

			Sample.DiffusePathValue	= Diffuse_Chan(DiffuseColor, a2, BSDFContext.SatNoV, BSDFContext.SatNoL, BSDFContext.Context.VoH, BSDFContext.Context.NoH);
			Sample.DiffusePDF		= BSDFContext.SatNoL / PI;
			Sample.bSubsurface		= bHasSubsurface;

			const float3 F0  = ComputeF0(SLAB_SPECULAR(BSDFContext.BSDF), BaseColor, Metallic);
			const float3 F90 = ComputeF90(F0, SLAB_EDGECOLOR(BSDFContext.BSDF), Metallic);

			const float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));

			float HazeSafeRoughnessX = SafeRoughnessX;
			float HazeSafeRoughnessY = SafeRoughnessY;

			const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
			const bool bHaziness = BSDF_GETHASHAZINESS(BSDFContext.BSDF);
			float D = 0;
			float Vis = 0;
			float PDF = 0;
			float HazeD = 0;
			float HazeVis = 0;
			float HazePDF = 0;

			#if STRATA_FASTPATH==0
			BRANCH
			if (bHasAnisotropy)
			{
				// Generalized microfacet specular
				{
					const float Alpha0 = Pow2(SafeRoughnessX);
					const float Alpha1 = Pow2(SafeRoughnessY);
					D   = D_GGXaniso(Alpha0, Alpha1, BSDFContext.Context.NoH, BSDFContext.Context.XoH, BSDFContext.Context.YoH);
					Vis = Vis_SmithJointAniso(Alpha0, Alpha1, BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.XoV, BSDFContext.Context.XoL, BSDFContext.Context.YoV, BSDFContext.Context.YoL);
					const float H_PDF = VisibleGGXPDF_aniso(BSDFContext.TangentV, BSDFContext.TangentH, float2(Alpha0, Alpha1));
					PDF = RayPDFToReflectionRayPDF(BSDFContext.Context.VoH, H_PDF);
				}

				if (bHaziness)
				{
					HazeSafeRoughnessX = ComputeHazyLobeRoughness(SafeRoughnessX, SLAB_HAZINESS(BSDFContext.BSDF));
					HazeSafeRoughnessY = ComputeHazyLobeRoughness(SafeRoughnessY, SLAB_HAZINESS(BSDFContext.BSDF));

					const float HazeAlpha0 = Pow2(HazeSafeRoughnessX);
					const float HazeAlpha1 = Pow2(HazeSafeRoughnessY);
					HazeD   = D_GGXaniso(HazeAlpha0, HazeAlpha1, BSDFContext.Context.NoH, BSDFContext.Context.XoH, BSDFContext.Context.YoH);
					HazeVis = Vis_SmithJointAniso(HazeAlpha0, HazeAlpha1, BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.XoV, BSDFContext.Context.XoL, BSDFContext.Context.YoV, BSDFContext.Context.YoL);
					const float H_PDF = VisibleGGXPDF_aniso(BSDFContext.TangentV, BSDFContext.TangentH, float2(HazeAlpha0, HazeAlpha1));
					HazePDF = RayPDFToReflectionRayPDF(BSDFContext.Context.VoH, H_PDF);
				}
			}
			else
			#endif
			{
				// Special override for roughness for supporting area light integrator with Sphere/Tube/Disk light, which modifies/increase roughness.
				const float a2 = BSDFContext.a2Override > 0 ? BSDFContext.a2Override : Pow4(SafeRoughnessX);

				// Generalized microfacet specular
				{
					D   = D_GGX(a2, BSDFContext.Context.NoH);
					Vis = Vis_SmithJoint(a2, BSDFContext.Context.NoV, BSDFContext.SatNoL);
					const float H_PDF = VisibleGGXPDF(BSDFContext.TangentV, BSDFContext.TangentH, a2);
					PDF = RayPDFToReflectionRayPDF(BSDFContext.Context.VoH, H_PDF);
				}

				#if STRATA_FASTPATH==0
				if (bHaziness)
				{
					HazeSafeRoughnessX = ComputeHazyLobeRoughness(SafeRoughnessX, SLAB_HAZINESS(BSDFContext.BSDF));

					const float a2Haze = BSDFContext.a2OverrideHazy > 0 ? BSDFContext.a2OverrideHazy : Pow4(HazeSafeRoughnessX);
					HazeD   = D_GGX(a2Haze, BSDFContext.Context.NoH);
					HazeVis = Vis_SmithJoint(a2Haze, BSDFContext.Context.NoV, BSDFContext.SatNoL);
					const float H_PDF = VisibleGGXPDF(BSDFContext.TangentV, BSDFContext.TangentH, a2Haze);
					HazePDF = RayPDFToReflectionRayPDF(BSDFContext.Context.VoH, H_PDF);
				}
				#endif
			}

			float3 MSScale = 1;
			float3 HazeMSScale = 1;
			#if STRATA_MICROFACET_MULTIPLESCATTERING
				FStrataGGXLUTResult StrataGGXLUTResult = StrataEvaluateGGXLUT(DiffuseColor, F0, BSDFContext.Context.NoV, Metallic, SafeRoughnessX, SafeRoughnessY);
				MSScale	= StrataGGXLUTResult.SpecularMultipleScatteringScale;
				const float3 DirectionalAlbedo_SpecularTransmission = StrataGGXLUTResult.DirectionalAlbedo.SpecularT; // We ignore Haziness influence
				#if STRATA_FASTPATH==0
				if (bHaziness)
				{
					HazeMSScale = StrataEvaluateGGXLUT(DiffuseColor, F0, BSDFContext.Context.NoV, Metallic, HazeSafeRoughnessX, HazeSafeRoughnessY).SpecularMultipleScatteringScale;
				}
				#endif
			#else
				const float3 ApproxFresnelForSpecularTransmittance = F_Schlick(F0, F90, BSDFContext.SatNoV);
				const float3 DirectionalAlbedo_SpecularTransmission = 1.0f - ApproxFresnelForSpecularTransmittance;
			#endif

			float3 FresnelTerm = 0;
			#if STRATA_FASTPATH==0
			const bool bHasThinFilm = BSDF_GETHASTHINFILM(BSDFContext.BSDF);
			BRANCH
			if (bHasThinFilm)
			{
				float ThinFilmIOR = SLAB_THINFILM_IOR(BSDFContext.BSDF);
				float ThinFilmThickness = SLAB_THINFILM_THICKNESS(BSDFContext.BSDF);
				FresnelTerm = F_ThinFilm(BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.VoH, F0, F90, ThinFilmIOR, ThinFilmThickness);
			}
			else
			#endif
			{
				FresnelTerm = F_Schlick(F0, F90, BSDFContext.Context.VoH);
			}

			Sample.SpecularPathProbability		= bHaziness	? (1.0f - SPECULAR_HAZINESS_WEIGHT) : 1.0f;
			Sample.SpecularHazePathProbability	= bHaziness	? SPECULAR_HAZINESS_WEIGHT			: 0.0f;

			Sample.SpecularPathValue		= D * Vis * FresnelTerm * MSScale;
			Sample.SpecularPDF				= PDF * Sample.SpecularPathProbability;

			Sample.SpecularHazePathValue	= HazeD * HazeVis * FresnelTerm * HazeMSScale;
			Sample.SpecularHazePDF			= HazePDF * Sample.SpecularHazePathProbability;

			Sample.EmissivePathValue = BSDF_GETEMISSIVE(BSDFContext.BSDF);

			Sample.Throughput = OpaqueBSDFThroughput;

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETHASFUZZ(BSDFContext.BSDF))
			{
				const float Fuzz = SLAB_FUZZ_AMOUNT(BSDFContext.BSDF);
				const float3 FuzzF0  = SLAB_FUZZ_COLOR(BSDFContext.BSDF);

				// Special override for roughness for supporting area light integrator with Sphere/Tube/Disk light, which modifies/increase roughness.
				const float a2 = BSDFContext.a2Override > 0 ? BSDFContext.a2Override : Pow4(SafeRoughness);

				const float SafeClothNoV = saturate(abs(BSDFContext.Context.NoV) + 1e-5);
				
				// Generalized inverse microfacet specular
				float ClothD   = D_InvGGX(a2, BSDFContext.Context.NoH);
				float ClothVis = Vis_Cloth(SafeClothNoV, BSDFContext.SatNoL);
				float3 ClothF  = F_Schlick(FuzzF0, BSDFContext.Context.VoH);
				float3 ClothDVF = ClothD * ClothVis * ClothF;
				
				// What to do with specular and diffuse here?
				Sample.SpecularPathValue = lerp(Sample.SpecularPathValue,	ClothDVF,					Fuzz);
				Sample.SpecularPDF		 = lerp(Sample.SpecularPDF,			BSDFContext.SatNoV / PI,	Fuzz); // Per "Production Friendly Microfacet Sheen BRDF", hemispherical sampling give good result as the roughness is usually high.
				// Fuzz does not affect throughput

				if (bHaziness)
				{
					Sample.SpecularHazePathValue= lerp(Sample.SpecularHazePathValue,	ClothDVF,					Fuzz);
					Sample.SpecularHazePDF		= lerp(Sample.SpecularHazePDF,			BSDFContext.SatNoV / PI,	Fuzz);
				}
				break;
			}
			#endif

			#if STRATA_FASTPATH==0 && STRATA_SSS_TRANSMISSION
			const bool bHasProfile = BSDF_GETHASSSSPROFILE(BSDFContext.BSDF);
			if (BSDF_GETHASSSS(BSDFContext.BSDF))
			{
				const float ThicknessInCm = DecodeThickness(ShadowTerms.TransmissionThickness) * SSSS_MAX_TRANSMISSION_PROFILE_DISTANCE;

				float OneOverIOR = 1.0f;
				float PhaseFunctionAnisotropy = 0.0f;
				float3 TransmissionThroughput = 1.0f;
				if (bHasProfile)
				{
					const uint ProfileId = StrataSubsurfaceProfileIdTo8bits(SLAB_SSSPROFILEID(BSDFContext.BSDF)); // TODO move this into the PackStrataOut( function, to avoid this decode here
					const FTransmissionProfileParams TransmissionParams = GetTransmissionProfileParams(ProfileId);
					TransmissionThroughput	= GetTransmissionProfile(ProfileId, ThicknessInCm).rgb;
					PhaseFunctionAnisotropy = TransmissionParams.ScatteringDistribution;
					OneOverIOR				= TransmissionParams.OneOverIOR;

				}
				else
				{
					const float3 SubsurfaceAlebdo = SLAB_BASECOLOR(BSDFContext.BSDF);
					const float3 MeanFreePathInCm = SLAB_SSSDMFP(BSDFContext.BSDF);
					TransmissionThroughput	= GetBurleyTransmissionProfile(SubsurfaceAlebdo, MeanFreePathInCm, ThicknessInCm);
					PhaseFunctionAnisotropy = 0.93f; // STRATA_TODO: expose phase function eccentricity. For now, forward scattering matching default SSS profile value
					OneOverIOR				= 1.f / DielectricF0ToIor(F0.y);
				}

				const float3 RefracV = refract(BSDFContext.V, -BSDFContext.N, OneOverIOR);
				const float PhaseFunction = ApproximateHG(dot(-BSDFContext.L, RefracV), PhaseFunctionAnisotropy);

				Sample.Throughput				= TransmissionThroughput * PhaseFunction;
				Sample.TransmissionPathValue	= TransmissionThroughput * PhaseFunction;
				Sample.TransmissionPDF			= 1.0f / (4.0f * PI);		// STRATA_TODO this currently match the uniform sphere sampling from StrataImportanceSampleBSDF
			}
			#endif

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETISTHIN(BSDFContext.BSDF))
			{
				FParticipatingMedia PM = StrataSlabCreateParticipatingMedia(DiffuseColor, SLAB_SSSDMFP(BSDFContext.BSDF));
				const float BackFaceNoL = -BSDFContext.Context.NoL;
				const float BackFaceNoLSat = saturate(BackFaceNoL);

				// We consider single scattering and perpendicular to the surface light transmittance.
				// Using BackFaceNoL instead of 1 for TransmittanceNoL would be more correct but it gives some high frequency details looking weird without multiple scattering.
				const float TransmittanceNoL = 1.0f;	
				const float3 SlabTransmittance = IsotropicMediumSlabTransmittance(PM, STRATA_SIMPLEVOLUME_THICKNESS_M, TransmittanceNoL);

				// We recover the transmitted luminance from as the back face Lambert affected by the transmittance.
				// The MFP is specified on the slab node and then transmittance recoved from it.
				// We assume the back face diffuse albedo is white=1 and no diffusion happens at this stage.
				const float3 BackFaceWhiteDiffuseColor = float3(1.0f, 1.0f, 1.0f);

				// The diffuse is attenuated by the slab transmittance and the GGX interface SpecularTransmission.
				Sample.ThinTransmissionPathValue = Diffuse_Lambert(BackFaceWhiteDiffuseColor) * SlabTransmittance * DirectionalAlbedo_SpecularTransmission;
				Sample.ThinTransmissionPathPDF = BackFaceNoLSat / PI;

				// At this stage, Sample.bSubsurface should have been setup correctly already if SSS is enabled with two-sided lighting.
			}
			#endif

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETISSIMPLEVOLUME(BSDFContext.BSDF))
			{
				FParticipatingMedia PM = StrataSlabCreateParticipatingMedia(DiffuseColor, SLAB_SSSDMFP(BSDFContext.BSDF));
				const float DiffuseToVolumeBlend = StrataSlabDiffuseToVolumeBlend(PM);
				const float3 SlabDirectionalAlbedo = IsotropicMediumSlabPunctualDirectionalAlbedo(PM);
				const float3 SlabTransmittance = IsotropicMediumSlabTransmittance(PM, STRATA_SIMPLEVOLUME_THICKNESS_M, BSDFContext.Context.NoV);

				const float Phase = IsotropicPhase();

				// The diffuse and throughput account for the GGX interface SpecularTransmission.
				Sample.DiffusePathValue = lerp(Sample.DiffusePathValue,		SlabDirectionalAlbedo * DirectionalAlbedo_SpecularTransmission,		DiffuseToVolumeBlend);
				Sample.DiffusePDF		= lerp(Sample.DiffusePDF,			Phase,																DiffuseToVolumeBlend);
				Sample.Throughput		= lerp(Sample.Throughput,			SlabTransmittance     * DirectionalAlbedo_SpecularTransmission,		DiffuseToVolumeBlend);

				Sample.bSubsurface = false;	// It should already be the case because Enforce in this case because BSDF_GETHASSSS should be false when BSDF_GETISSIMPLEVOLUME is true
			}
			#endif

			break;
		}

		#if STRATA_FASTPATH==0
		case STRATA_BSDF_TYPE_HAIR:
		{
			FGBufferData GBuffer	= (FGBufferData)0;
			GBuffer.BaseColor		= HAIR_BASECOLOR(BSDFContext.BSDF);
			GBuffer.Specular		= HAIR_SPECULAR(BSDFContext.BSDF);
			GBuffer.Roughness		= HAIR_ROUGHNESS(BSDFContext.BSDF);
			GBuffer.Metallic		= HAIR_SCATTER(BSDFContext.BSDF);
			GBuffer.CustomData.z	= HAIR_BACKLIT(BSDFContext.BSDF);
			GBuffer.ShadingModelID	= SHADINGMODELID_HAIR;
			GBuffer.WorldNormal		= BSDFContext.N;

			float BacklitEnabled = 1.0f;
			float Area = 0.0f;
			uint2 Random = uint2(0, 0);
			Sample.TransmissionPathValue= HairShading(GBuffer, BSDFContext.L, BSDFContext.V, BSDFContext.N, ShadowTerms.TransmissionShadow, ShadowTerms.HairTransmittance, BacklitEnabled, Area, Random);
			Sample.TransmissionPDF		= 1.0f / (4.0f * PI);		// STRATA_TODO this currently match the uniform sphere sampling from StrataImportanceSampleBSDF
			Sample.Throughput			= OpaqueBSDFThroughput; 
		}
		break;

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
		#endif
	}

	return Sample;
}

FStrataEvaluateResult StrataEvaluateBSDF(FStrataBSDFContext BSDFContext)
{
	FShadowTerms Shadow = { 1, 1, 1, InitHairTransmittanceData() };
	return StrataEvaluateBSDF(BSDFContext, Shadow);
}

struct FStrataImportanceSampleResult
{
	float3 SpecularDirection;
	float  SpecularPDF;

	float3 DiffuseDirection;
	float  DiffusePDF;
};

/**
 * Importance sample a Strata BSDF
 * BSDF: the strata BSDF to importance sample
 * E: two random numbers
 * CameraVector: vector from the camera to the considered direction (not V)
 */
FStrataImportanceSampleResult StrataImportanceSampleBSDF(FStrataBSDFContext BSDFContext, FStrataBSDF BSDF, float2 E)
{
	FStrataImportanceSampleResult Sample = (FStrataImportanceSampleResult)0;

	float PDF = 0.0f;
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);

			// We assume a cosine hemisphere sampling is enough for any roughness.
			// We also assume that this will work just as well for volumetric (considering it is an isotropic phase function and we are interesting in sampling mostly the hemisphere and not the layers below)
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.DiffuseDirection = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			Sample.DiffusePDF = ImportanceSample.w;
			PDF = Sample.DiffusePDF;

			const float3 F0 = ComputeF0(SLAB_SPECULAR(BSDF), BaseColor, Metallic);
			// STRATA_TODO take into account F90 

			const float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
			float4 TangentH = 0;
			if (bHasAnisotropy)
			{
				const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));
				TangentH = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(E), float2(Pow2(SafeRoughnessX), Pow2(SafeRoughnessY)), BSDFContext.TangentV);
			}
			else
			{
				TangentH = ImportanceSampleVisibleGGX(UniformSampleDisk(E), Pow4(SafeRoughnessX), BSDFContext.TangentV);
			}

			// STRATA_TODO take into account Haziness
			// STRATA_TODO take into account Fuzz: Per "Production Friendly Microfacet Sheen BRDF", uniform hemispherical sampling gives good result as the roughness is usually high and avoid issue at grazing angle.
			// STRATA_TODO take into account Two sided material

			const float HPDF = TangentH.w;
			const float3 H = mul(TangentH.xyz, BSDFContext.TangentBasis);
			const float VoH = saturate(dot(BSDFContext.V, H));

			Sample.SpecularDirection = 2 * dot(BSDFContext.V, H) * H - BSDFContext.V;
			Sample.SpecularPDF = RayPDFToReflectionRayPDF(VoH, HPDF);
			PDF = Sample.SpecularPDF;
			break;
		}

		case STRATA_BSDF_TYPE_HAIR:
		{
			// STRATA_TODO do something better when we get there with Lumen, and evaluate the different researched solution (e.g. Importance Sampling for Physically-Based Hair Fiber Models)
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.DiffuseDirection = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			PDF = ImportanceSample.w;
			break;
		}

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
	}

	//StrataUpdateBSDFContext(BSDFContext, Sample.Direction);
	//Sample.Eval = StrataEvaluateBSDF(BSDFContext);
	//Sample.Eval.PDF = PDF;	// We override the pdf to make sure the compiler skips all pdf code from StrataEvaluateBSDF because GGXSample.w si the pdf already for instance.

	return Sample;
}

FStrataImportanceSampleResult StrataImportanceSampleBSDF(FStrataPixelHeader StrataPixelHeader, FStrataBSDF BSDF, const FStrataAddressing StrataAddressing, float2 E, float3 CameraVector)
{
	FStrataImportanceSampleResult Sample = (FStrataImportanceSampleResult)0;

	// Create a context from the information we have
	const float3 V = -CameraVector;
	FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, StrataAddressing, V);
	return StrataImportanceSampleBSDF(BSDFContext, BSDF, E);
}

struct FStrataEnvLightResult
{
	float3 DiffuseNormal;
	float3 DiffuseWeight;
	float3 DiffuseBackFaceWeight;

	float3 SpecularDirection;
	float3 SpecularWeight;
	float  SpecularSafeRoughness;

	// Specular haze maintains the same off peak specular direction as the non hazy specular lobe
	float3 SpecularHazeWeight;
	float  SpecularHazeSafeRoughness;
	float  SSRReduction;

	bool   bSubsurface; // True if we need to separate the subsurface light contribution for the screen space diffusion process.
};

FStrataEnvLightResult StrataEvaluateForEnvLight(FStrataBSDFContext BSDFContext, bool bEnableSpecular)
{
	FStrataEnvLightResult StrataEnvLightResult = (FStrataEnvLightResult)0;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);

			const float3 DiffuseColor = BaseColor - BaseColor * Metallic;
			StrataEnvLightResult.DiffuseNormal = BSDFContext.N;
			StrataEnvLightResult.bSubsurface = BSDF_GETHASSSS(BSDFContext.BSDF) > 0;
			StrataEnvLightResult.DiffuseWeight = DiffuseColor;

			float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			float3 F0 = ComputeF0(SLAB_SPECULAR(BSDFContext.BSDF), BaseColor, Metallic);
			const float3 F90 = ComputeF90(F0, SLAB_EDGECOLOR(BSDFContext.BSDF), Metallic);
			float3 ThinFilmFresnelWeight = 1;

			const float3 ApproxFresnelForSpecularTransmittance = F_Schlick(F0, F90, BSDFContext.SatNoV);
			float3 DirectionalAlbedo_SpecularTransmission = 1.0f - ApproxFresnelForSpecularTransmittance;

			BRANCH
			if (bEnableSpecular)
			{

				#if STRATA_FASTPATH==0
				const bool bHasThinFilm = BSDF_GETHASTHINFILM(BSDFContext.BSDF);
				if (bHasThinFilm)
				{
					float ThinFilmIOR = SLAB_THINFILM_IOR(BSDFContext.BSDF);
					float ThinFilmThickness = SLAB_THINFILM_THICKNESS(BSDFContext.BSDF);
					ThinFilmFresnelWeight = F_ThinFilm(BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.VoH, F0, F90, ThinFilmIOR, ThinFilmThickness);
					F0 = 1.f;
				}
				#endif


				#if STRATA_FASTPATH==0
				const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
				if (bHasAnisotropy)
				{
					const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));

					// Modified the BSDF normal (and roughness)
					float Anisotropy = 0;
					GetAnisotropicFactor(SafeRoughnessX, SafeRoughnessY, Anisotropy, SafeRoughnessX);
					ModifyGGXAnisotropicNormalRoughness(BSDFContext.X, Anisotropy, SafeRoughnessX, BSDFContext.N, BSDFContext.V);

					// Update context (only needs: NoL/SatNoL/R) with the new N
					BSDFContext.Context.NoL = dot(BSDFContext.N, BSDFContext.L);
					BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
					BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
				}
				#endif

				// Compute the directional albedo for specular and diffuse
			#if STRATA_MICROFACET_MULTIPLESCATTERING
				float3 EvalEnvBRDF = 0;
				{
					FStrataGGXLUTResult GGXLUT	= StrataEvaluateGGXLUT(DiffuseColor, F0, BSDFContext.Context.NoV, Metallic, SafeRoughnessX, SafeRoughnessX);
					EvalEnvBRDF					= ThinFilmFresnelWeight * GGXLUT.DirectionalAlbedo.SpecularR;
					StrataEnvLightResult.DiffuseWeight = GGXLUT.DirectionalAlbedo.Diffuse;
					DirectionalAlbedo_SpecularTransmission = GGXLUT.DirectionalAlbedo.SpecularT; // We ignore Haziness influence
				}
			#else
				const float3 EvalEnvBRDF = ThinFilmFresnelWeight * StrataEnvBRDF(F0, F90, SafeRoughnessX, BSDFContext.SatNoV);
			#endif

				StrataEnvLightResult.SpecularDirection = StrataGetOffSpecularPeakReflectionDir(BSDFContext.N, BSDFContext.R, SafeRoughnessX);
				StrataEnvLightResult.SpecularWeight = EvalEnvBRDF;
				StrataEnvLightResult.SpecularSafeRoughness = SafeRoughnessX;

				#if STRATA_FASTPATH==0
				const bool bHasHaziness = BSDF_GETHASHAZINESS(BSDFContext.BSDF);
				if (bHasHaziness)
				{
					// Smoothly fade in haziness while fading out SSR to make sure we do not add energy and avoid popping.
					const float Haziness = SLAB_HAZINESS(BSDFContext.BSDF);
					const float HazinessFadeIn = saturate(Haziness / 0.1f);
					StrataEnvLightResult.SSRReduction = lerp(0.0f, SPECULAR_HAZINESS_WEIGHT, HazinessFadeIn);

					// Apply blend factor on the sharp specular contribution
					StrataEnvLightResult.SpecularWeight *= lerp(1.0f, (1.0f - SPECULAR_HAZINESS_WEIGHT), HazinessFadeIn);

					// Compute the second specular weight and roughness
					float SafeRoughnessHaze = ComputeHazyLobeRoughness(SafeRoughnessX, Haziness);

					// Compute the directional albedo for hazy specular
				#if STRATA_MICROFACET_MULTIPLESCATTERING
					FStrataGGXLUTResult GGXLUTHaze = StrataEvaluateGGXLUT(DiffuseColor, F0, BSDFContext.Context.NoV, Metallic, SafeRoughnessHaze, SafeRoughnessHaze);
					const float3 EvalEnvBRDFHaze = ThinFilmFresnelWeight * GGXLUTHaze.DirectionalAlbedo.SpecularR;
				#else
					const float3 EvalEnvBRDFHaze = ThinFilmFresnelWeight * StrataEnvBRDF(F0, F90, SafeRoughnessX, BSDFContext.SatNoV);
				#endif

					StrataEnvLightResult.SpecularHazeWeight = lerp(0.0f, SPECULAR_HAZINESS_WEIGHT, HazinessFadeIn) * EvalEnvBRDFHaze;
					StrataEnvLightResult.SpecularHazeSafeRoughness = SafeRoughnessHaze;
				}
				#endif
			}
			#if STRATA_MICROFACET_MULTIPLESCATTERING
			else
			{
				// Compute the directional albedo for diffuse
				FStrataGGXLUTResult GGXLUT = StrataEvaluateGGXLUT(DiffuseColor, 1.f, BSDFContext.Context.NoV, 0.f, SafeRoughnessX, SafeRoughnessX);
				StrataEnvLightResult.DiffuseWeight = GGXLUT.DirectionalAlbedo.Diffuse;
			}
			#endif

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETISSIMPLEVOLUME(BSDFContext.BSDF))
			{
				FParticipatingMedia PM = StrataSlabCreateParticipatingMedia(DiffuseColor, SLAB_SSSDMFP(BSDFContext.BSDF));
				const float DiffuseToVolumeBlend = StrataSlabDiffuseToVolumeBlend(PM);

				// The environment response of has been measured for an hemisphere having a uniform radiance of 1. 
				// This DirectionalAlbedo also contains the integral over the hemisphere according to the phase function.
				// The spherical harmonic used for environment lighting contains the diffuse integral over the hemisphere as DiffLambert = int_{\omega} {1 * NoL d\Omega} = PI.
				// We do not want to be affected by the NoL term here since The DirectionalAlbedo also contains the integral over the hemisphere according to the phase function.
				// Integral of a value=1 over the Hemisphere is int_{\omega} {1  d\Omega} = 2PI.
				// So, as an approximation, we recover the uniform hemisphere luminance as UniformEnvL = DiffLambert * (1 / PI) * (2 * PI).
				// We consider that the diffuse integration of the environment SH over the hemisphere multiplied with the light response will be a good approximation similar to the "split sum integral".
				float3 SlabDirectionalAlbedo = IsotropicMediumSlabEnvDirectionalAlbedo(PM) * ((1 / PI)* (2 * PI));

			#if 1
				// Because the default EnvBRDF does not account for multiple scattering, we rescale the participating media response according to EnvBRDF.
				// This is to ensure a monotone light response behavior when transitioning from the Diffuse to the Volumetric model (without that, multiple scattering can result in higher luminance while trnasitionning from diffuse to volume light model)
				// STRATA_TODO: We should NOT have to do that. This should be investigated futher...
				const float MaxDiffuseWeight = max3(StrataEnvLightResult.DiffuseWeight.x, StrataEnvLightResult.DiffuseWeight.y, StrataEnvLightResult.DiffuseWeight.z);
				const float MaxSlabDirectionalAlbedo = max3(SlabDirectionalAlbedo.x, SlabDirectionalAlbedo.y, SlabDirectionalAlbedo.z);
				if (MaxDiffuseWeight < MaxSlabDirectionalAlbedo)
				{
					// We only want to do that when the slab light response is higher than the diffse response, so that when the mfp is large (and scattering low), the light response still work correctly according to thickness and MFP.
					SlabDirectionalAlbedo *= MaxDiffuseWeight / MaxSlabDirectionalAlbedo;
				}
			#endif

				// The diffuse is attenuated by the GGX interface SpecularTransmission.
				SlabDirectionalAlbedo *= DirectionalAlbedo_SpecularTransmission;

				StrataEnvLightResult.DiffuseWeight = lerp(StrataEnvLightResult.DiffuseWeight, SlabDirectionalAlbedo, DiffuseToVolumeBlend);
				// We keep the same normal
				StrataEnvLightResult.bSubsurface = false;
			}
			#endif
			

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETISTHIN(BSDFContext.BSDF))
			{
				FParticipatingMedia PM = StrataSlabCreateParticipatingMedia(DiffuseColor, SLAB_SSSDMFP(BSDFContext.BSDF));

				// We consider single scattering and perpendicular to the surface light transmittance.
				// Using BackFaceNoL instead of 1 for TransmittanceNoL would be more correct but it gives some high frequency details looking weird without multiple scattering.
				const float TransmittanceNoL = 1.0f;
				const float3 SlabTransmittance = IsotropicMediumSlabTransmittance(PM, STRATA_SIMPLEVOLUME_THICKNESS_M, TransmittanceNoL);

				// We recover the transmitted luminance from as the back face Lambert affected by the transmittance.
				// The MFP is specified on the slab node and then transmittance recoved from it.
				// We assume the back face diffuse albedo is white=1 and no diffusion happens at this stage.
				const float3 BackFaceWhiteDiffuseColor = float3(1.0f, 1.0f, 1.0f);

				// The diffuse is attenuated by the slab transmittance and the GGX interface SpecularTransmission.
				StrataEnvLightResult.DiffuseBackFaceWeight = Diffuse_Lambert(BackFaceWhiteDiffuseColor) * SlabTransmittance * DirectionalAlbedo_SpecularTransmission;

				// At this stage, StrataEnvLightResult.bSubsurface should have been setup correctly already if SSS is enabled to be applied on a thin surface.
			}
			#endif

			#if STRATA_FASTPATH==0
			BRANCH
			if (BSDF_GETHASFUZZ(BSDFContext.BSDF))
			{
				const float Fuzz = SLAB_FUZZ_AMOUNT(BSDFContext.BSDF);
				const float3 FuzzColor  = SLAB_FUZZ_COLOR(BSDFContext.BSDF);

				// This should be a lerp, but SkyLightDiffuse from ReflectionEnvironmentPixelShader.usf add the contribution...
				// STRATA_TODO fix the Fuzz model
				//StrataEnvLightResult.DiffuseWeight = lerp(StrataEnvLightResult.DiffuseWeight, FuzzColor, Fuzz);
				StrataEnvLightResult.DiffuseWeight += FuzzColor * Fuzz;
				// Fuzz does not affect throughput.
				break;
			}
			#endif

			break;
		}

#if STRATA_FASTPATH==0

		case STRATA_BSDF_TYPE_HAIR:
		{
			FGBufferData GBuffer	= (FGBufferData)0;
			GBuffer.BaseColor		= HAIR_BASECOLOR(BSDFContext.BSDF);
			GBuffer.Specular		= HAIR_SPECULAR(BSDFContext.BSDF);
			GBuffer.Roughness		= HAIR_ROUGHNESS(BSDFContext.BSDF);
			GBuffer.Metallic		= HAIR_SCATTER(BSDFContext.BSDF);
			GBuffer.CustomData.z	= HAIR_BACKLIT(BSDFContext.BSDF);
			GBuffer.ShadingModelID	= SHADINGMODELID_HAIR;
			GBuffer.WorldNormal		= BSDFContext.N;
			
			float BacklitEnabled = 0.0f;
			float Area = 0.2;
			uint2 Random = uint2(0, 0);
			float TransmissionShadow = 1.0f;
			FHairTransmittanceData TransmittanceData = InitHairTransmittanceData(true);

			const float3 N = BSDFContext.N;
			const float3 V = BSDFContext.V;
			float3 L = normalize(V - N * dot(V, N));
			StrataEnvLightResult.DiffuseNormal = L;

			StrataEnvLightResult.DiffuseWeight = PI * HairShading(GBuffer, L, V, N, TransmissionShadow, TransmittanceData, BacklitEnabled, Area, Random);
			// No specular environment contribution as of today if not using the special HairStrand render path
			break;
		}

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
#endif
	}

	return StrataEnvLightResult;
}

FThreeBandSHVector StrataBSDFToSH(FStrataBSDFContext BSDFContext)
{
	FThreeBandSHVector SHVector;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	if (BSDFType == STRATA_BSDF_TYPE_HAIR)
	{
		// Hack to avoid culling directions that hair will sample
		SHVector = (FThreeBandSHVector)0;
		SHVector.V0.x = 1.0f;
	}
	else
	{
		SHVector = CalcDiffuseTransferSH3(BSDFContext.N, 1.0f);
	}

	// STRATA_TODO adapt the SH to BSDFs
	return SHVector;
}


