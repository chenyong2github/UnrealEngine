// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

#define STRATA_INLINE_SHADING 0
#include "/Engine/Private/Strata/Strata.ush"

#define TILE_SIZE 8
#define GROUP_THREAD_COUNT (TILE_SIZE*TILE_SIZE)

#if SHADER_CATEGORIZATION 

// Note: 
// This code is partial copy of PackStrataOut in Strata.ush. 
// The command part will progressively be removed as we remove data from the gbuffer.
void ComputePostProcessBSDFData(
	const FStrataPixelHeader Header,
	const FStrataBSDF BSDF,
	float3 V,
	inout FStrataClassification Classification,
	inout FStrataSubsurfaceData SSS,
	inout FStrataTopLayerData TopLayer)
{
	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	const float3 BSDFCoverage = BSDF.Weight;
	const float  BSDFCoverageAvg = dot(BSDF.Weight,1.0f/3.0f);

	// STRATA_TODO apply the same normal transform as for the material
	float3x3 TangentBasis = StrataGetBSDFSharedBasis(Header, BSDF);
	float3 N = TangentBasis[2];
	//N = normalize(N);

	TopLayer.Normal += N;

	BxDFContext ContextNoLight = (BxDFContext)0;
	const float3 FakeL = float3(0, 0, 1);
	Init(ContextNoLight, N, V, FakeL);

	const bool bTopLayer = BSDF_GETISTOPLAYER(BSDF);

	Classification.ShadingModels |= StrataShadingModelBit(BSDF_GETTYPE(BSDF));
	Classification.bIsSimple = Classification.bIsSimple && BSDF_GETTYPE(BSDF) == STRATA_BSDF_TYPE_SLAB;

	switch (BSDF_GETTYPE(BSDF))
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		const float3 F0  = ComputeF0(SLAB_SPECULAR(BSDF), SLAB_BASECOLOR(BSDF), SLAB_METALLIC(BSDF));
		const float3 F90 = ComputeF90(F0, SLAB_BASECOLOR(BSDF), SLAB_METALLIC(BSDF));

		if (bTopLayer)
		{
			// Setup SSR for the top layer
			TopLayer.Roughness += BSDFCoverageAvg * SLAB_ROUGHNESSX(BSDF);
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;

			const float SafeRoughness = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDF));
			TopLayer.BaseColor += BSDFCoverage * EnvBRDFApprox(F0, F90, SafeRoughness, saturate(ContextNoLight.NoV));
		}

		Classification.bIsSimple =
			Classification.bIsSimple &&
			!BSDF_GETANISOTROPY(BSDF) &&
			!BSDF_GETHASSCATTERING(BSDF) &&
			!BSDF_GETHASSSSPROFILE(BSDF) &&
			!BSDF_GETHASHAZINESS(BSDF);

		// Select the first/toppest layer with subsurface scattering
		if (BSDF_GETHASSCATTERING(BSDF) && BSDFCoverageAvg > 0 && !SSS.bHasSubsurface)
		{
			SSS.bHasSubsurface = true;
			SSS.bHasProfile			= BSDF_GETHASSSSPROFILE(BSDF);
			SSS.ProfilePackedId		= SLAB_SSSPROFILEID(BSDF);
			SSS.ProfileRadiusScale	= SLAB_SSSPROFILERADIUSSCALE(BSDF);
			SSS.BaseColor			= SLAB_BASECOLOR(BSDF);
			SSS.DMFP				= SLAB_SSSDMFP(BSDF);
		}
		break;
	}

	case STRATA_BSDF_TYPE_SHEEN:
	{
		const float3 F0  = SHEEN_BASECOLOR(BSDF);
		const float3 F   = F_Schlick(F0, ContextNoLight.VoH);

		if (bTopLayer)
		{
			TopLayer.Roughness += SHEEN_ROUGHNESS(BSDF);
			TopLayer.AccumRoughnessCount += 1.0f;

			const float SafeRoughness = MakeRoughnessSafe(SHEEN_ROUGHNESS(BSDF));
			TopLayer.BaseColor += BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
		}
		break;
	}

	case STRATA_BSDF_TYPE_HAIR:
	{
		Classification.bHasTransmission = true;

		// No SSR
		if (bTopLayer)
		{
			TopLayer.Roughness += BSDFCoverageAvg * FullyRough; // Do not trigger SSR by using fully rough
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;
		}
		break;
	}

	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		if (bTopLayer)
		{
			const float Roughness = SLW_ROUGHNESS(BSDF);

			TopLayer.Roughness += BSDFCoverageAvg * Roughness;
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;

			// The specular over the water in completely in the hand of the user. We do not fade out metallness for instance.
			const float3 F0 = ComputeF0(SLW_SPECULAR(BSDF), SLW_BASECOLOR(BSDF), SLW_METALLIC(BSDF));
			const float SafeRoughness = MakeRoughnessSafe(Roughness);
			TopLayer.BaseColor += BSDFCoverageAvg * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
		}
		break;
	}

	} // switch		
}

void MainPS(
	float4 SVPos : SV_POSITION, 
	out uint OutColor0 : SV_Target0,
	out uint2 OutColor1 : SV_Target1)
{
	const uint2 PixelPos = uint2(SVPos.xy);

	// Sample scene textures.
	float2 BufferUV		 = SvPositionToBufferUV(SVPos);
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);
	
	FStrataClassification ClassificationData	= (FStrataClassification)0;
	FStrataSubsurfaceData SSSData				= (FStrataSubsurfaceData)0;
	FStrataTopLayerData TopLayerData			= (FStrataTopLayerData)0;

	ClassificationData.bIsStrataMaterial = GBuffer.ShadingModelID == SHADINGMODELID_STRATA;
	ClassificationData.GBufferAO = GBuffer.GBufferAO;
	ClassificationData.bIsSimple = true; // non strata material or sky pixels are considered as simple.
	if (ClassificationData.bIsStrataMaterial)
	{
		float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
		const float Depth = 1000000.0f;
		float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
		const float3 V = normalize(View.WorldCameraOrigin - WorldPos.xyz);

		uint PixelStrataDataByteOffset = GetStrataPixelDataByteOffset(PixelPos, View.BufferSizeAndInvSize.x, Strata.MaxBytesPerPixel);
		FStrataPixelHeader Header = UnpackStrataHeaderIn(Strata.MaterialLobesBuffer, PixelStrataDataByteOffset);
		ClassificationData.bIsSimple = Header.BSDFCount == 1;
		for (uint BSDFIndex = 0; BSDFIndex < Header.BSDFCount; ++BSDFIndex)
		{
			const FStrataBSDF BSDF = UnpackStrataBSDFIn(Strata.MaterialLobesBuffer, PixelStrataDataByteOffset);
			ComputePostProcessBSDFData(Header, BSDF, V, ClassificationData, SSSData, TopLayerData);
		}

		FinalizeTopLayerData(TopLayerData);
	}

	OutColor0 = StrataPackClassificationData(ClassificationData);
	OutColor1 = StrataPackTopLayerData(TopLayerData);
}
#endif // SHADER_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint EncodeTile(uint2 TileCoord)
{
	return TileCoord.x | (TileCoord.y << 16); // assumes 16bit is enough to represent a tiled resolution up to 65,535 :)
}

uint2 DecodeTile(uint In)
{
	return uint2(In & 0xFFFF, In >> 16);
}

#if SHADER_TILE_CATEGORIZATION
int TileSize;
int bRectPrimitive;
int2 ViewResolution;
Texture2D<uint> ClassificationTexture;
RWBuffer<uint> TileIndirectData;
RWBuffer<uint> TileListData;

groupshared bool s_IsSimpleTile[GROUP_THREAD_COUNT];

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileMainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	if (all(DispatchThreadId == 0))
	{
		TileIndirectData[0] = bRectPrimitive > 0 ? 4 : 6;
		TileIndirectData[2] = 0;
		TileIndirectData[3] = 0;
	}

	// TODO: add a SM6 permutation with ballot?
	const uint2 PixelCoord = DispatchThreadId;

	// Pixels outside of the view area are considered simple to enable screen borders to receive the simple permutation when not aligned to shader group size.
	bool bIsSimpleTile = true;
	if (all(PixelCoord < uint2(ViewResolution)))
	{
		const uint PackClassification = ClassificationTexture.Load(uint3(PixelCoord, 0));
		FStrataClassification Data = StrataUnpackClassificationData(PackClassification);
		bIsSimpleTile = Data.bIsSimple;
	}
	s_IsSimpleTile[LinearIndex] = bIsSimpleTile;

	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 1 && (s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 1]))
	{
		uint WriteToIndex;
		InterlockedAdd(TileIndirectData[1], 1, WriteToIndex);
		TileListData[WriteToIndex] = EncodeTile(GroupId.xy);
	}
}
#endif // SHADER_TILE_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_STENCIL_CATEGORIZATION

int  TileSize;
int2 TileCount;
int	 bRectPrimitive;
int2 OutputResolution;
Buffer<uint> TileListBuffer;

void StencilMainVS(
	in uint InVertexId : SV_VertexID,
	in uint InInstanceId : SV_InstanceID,
	out float4 OutPosition : SV_POSITION)
{
	const uint2 TileCoord = DecodeTile(TileListBuffer[InInstanceId]);

	uint2 TileVertex = TileCoord * TILE_SIZE;
	TileVertex.x += InVertexId == 1 || InVertexId == 2 || InVertexId == 4 ? TILE_SIZE : 0;
	TileVertex.y += InVertexId == 2 || InVertexId == 4 || InVertexId == 5 ? TILE_SIZE : 0;
	OutPosition = float4(float2(TileVertex) / OutputResolution * float2(2.0f, -2.0f) + float2(-1.0, 1.0f), 0.5f, 1.0f);
}

void StencilMainPS(
	float4 SVPos : SV_POSITION,
	out uint OutColor0 : SV_Target0)
{
	OutColor0 = 255;
}

#endif //SHADER_STENCIL_CATEGORIZATION
