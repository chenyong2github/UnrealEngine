// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../BRDF.ush"
#include "../DeferredShadingCommon.ush"

#include "/Engine/Shared/StrataDefinitions.h"


// During the base pass or forward rendering, shared normals are simply available from registers.
// If a BSDF is loaded for processing from the strata buffer, normals are unpacked on demand to reduce VGPR pressure and increase occupancy.
#ifndef STRATA_INLINE_SHADING
#define STRATA_INLINE_SHADING 1
#endif

#ifndef STRATA_CLAMPED_LAYER_COUNT
#define STRATA_CLAMPED_LAYER_COUNT 1
#endif



///////////////////////////////////////////////////////////////////////////////
// BSDFs representation
struct FStrataBSDF
{
	float3				Weight;		// Weight is a float3 because, when loaded from the material buffer, it contains the BSDF throughput (coverage and transmittance combined)
	uint				State;		// (27 unused bits) (1bit as HasAnisotropy) (2bits as SharedNormalIndex) (3bits as BSDFType)

#if STRATA_INLINE_SHADING
	float3				Emissive;	// All bsdf can potientially have emissive. This is never written out to the strata gbuffer but instead accumulated in the emissive buffer during the base pass.
#endif

	float4 VGPRs[2];
};

// Num bits for each component store in BSDF state
#define STATE_BITS_BSDF					3
#define STATE_BITS_SHAREDNORMALID		2
#define STATE_BITS_ANISOTROPY			1
#define STATE_BITS_TOPLAYER				1
#define STATE_BITS_HASSCATTERING		1
#define STATE_BITS_HASSSSPROFILE		1
#define STATE_BITS_GREYWEIGHT			1
#define STATE_BITS___UNUSED___			13
#define STATE_BITS_WEIGHT10F			10

// Bit offset of each component store in BSDF state 
#define STATE_BIT_OFFSET_BSDF			0
#define STATE_BIT_OFFSET_SHAREDNORMALID	(STATE_BIT_OFFSET_BSDF				+ STATE_BITS_BSDF)
#define STATE_BIT_OFFSET_ANISOTROPY		(STATE_BIT_OFFSET_SHAREDNORMALID	+ STATE_BITS_SHAREDNORMALID)
#define STATE_BIT_OFFSET_TOPLAYER		(STATE_BIT_OFFSET_ANISOTROPY		+ STATE_BITS_ANISOTROPY)
#define STATE_BIT_OFFSET_HASSCATTERING	(STATE_BIT_OFFSET_TOPLAYER			+ STATE_BITS_TOPLAYER)
#define STATE_BIT_OFFSET_HASSSSPROFILE	(STATE_BIT_OFFSET_HASSCATTERING		+ STATE_BITS_HASSCATTERING)
#define STATE_BIT_OFFSET_GREYWEIGHT		(STATE_BIT_OFFSET_HASSSSPROFILE		+ STATE_BITS_HASSSSPROFILE)
#define STATE_BIT_OFFSET_WEIGHT10F		22

#define TO_BITMASK(BitCount)							((1<<BitCount)-1)
#define BSDF_GETSTATE(X, BitCount, BitOffset)			uint((X.State>>BitOffset) & TO_BITMASK(BitCount))
#define BSDF_SETSTATE(X, BitCount, BitOffset, Value)	X.State = (X.State & (~(TO_BITMASK(BitCount)<<BitOffset))) | ((Value & TO_BITMASK(BitCount)) << BitOffset)

// Accessors for the BSDF type
#define BSDF_GETTYPE(X)					BSDF_GETSTATE(X, STATE_BITS_BSDF, STATE_BIT_OFFSET_BSDF)
#define BSDF_SETTYPE(X, NewType)		BSDF_SETSTATE(X, STATE_BITS_BSDF, STATE_BIT_OFFSET_BSDF, NewType)

// Accessors for Shared Normal
// This assumes Normals[STRATA_MAX_SHARED_NORMAL_REGISTERS]
#define BSDF_GETNORMALID(X)				BSDF_GETSTATE(X, STATE_BITS_SHAREDNORMALID, STATE_BIT_OFFSET_SHAREDNORMALID)
#define BSDF_SETNORMALID(X, NrmlIdx)	BSDF_SETSTATE(X, STATE_BITS_SHAREDNORMALID, STATE_BIT_OFFSET_SHAREDNORMALID, NrmlIdx)

// Accessors for HasAnisotropy
// Indicates if the BSDF has anisotropic feature
#define BSDF_GETANISOTROPY(X)			BSDF_GETSTATE(X, STATE_BITS_ANISOTROPY, STATE_BIT_OFFSET_ANISOTROPY)
#define BSDF_SETANISOTROPY(X, Aniso)	BSDF_SETSTATE(X, STATE_BITS_ANISOTROPY, STATE_BIT_OFFSET_ANISOTROPY, Aniso)

// Indicates if the BSDF is part of the top layer
#define BSDF_GETISTOPLAYER(X)			BSDF_GETSTATE(X, STATE_BITS_TOPLAYER, STATE_BIT_OFFSET_TOPLAYER)
#define BSDF_SETISTOPLAYER(X, IsTop)	BSDF_SETSTATE(X, STATE_BITS_TOPLAYER, STATE_BIT_OFFSET_TOPLAYER, IsTop)

// Indicates if the BSDF has scattering component
#define BSDF_GETHASSCATTERING(X)		BSDF_GETSTATE(X, STATE_BITS_HASSCATTERING, STATE_BIT_OFFSET_HASSCATTERING)
#define BSDF_SETHASSCATTERING(X, Scatt)	BSDF_SETSTATE(X, STATE_BITS_HASSCATTERING, STATE_BIT_OFFSET_HASSCATTERING, Scatt)

// Indicates if the BSDF has a SSS profile
#define BSDF_GETHASSSSPROFILE(X)		BSDF_GETSTATE(X, STATE_BITS_HASSSSPROFILE, STATE_BIT_OFFSET_HASSSSPROFILE)
#define BSDF_SETHASSSSPROFILE(X, Profi)	BSDF_SETSTATE(X, STATE_BITS_HASSSSPROFILE, STATE_BIT_OFFSET_HASSSSPROFILE, Profi)

// Indicates if the BSDF weight is grey scale so that it can be stored in a single float (e.g. top layer BSDFs)
#define BSDF_GETGREYWEIGHT(X)			BSDF_GETSTATE(X, STATE_BITS_GREYWEIGHT, STATE_BIT_OFFSET_GREYWEIGHT)
#define BSDF_SETGREYWEIGHT(X, Grey)		BSDF_SETSTATE(X, STATE_BITS_GREYWEIGHT, STATE_BIT_OFFSET_GREYWEIGHT, Grey)

// Accessors for the 10bits float weight used if is it detected being a grey scale
#define BSDF_GETWEIGHT10F(X)			BSDF_GETSTATE(X, STATE_BITS_WEIGHT10F, STATE_BIT_OFFSET_WEIGHT10F)
#define BSDF_SETWEIGHT10F(X, Weight)	BSDF_SETSTATE(X, STATE_BITS_WEIGHT10F, STATE_BIT_OFFSET_WEIGHT10F, Weight)

#if STRATA_INLINE_SHADING
#define BSDF_SETEMISSIVE(X, V)	X.Emissive = V
#define BSDF_GETEMISSIVE(X)		X.Emissive
#else
#define BSDF_SETEMISSIVE(X, V)	X
#define BSDF_GETEMISSIVE(X)		0.0f
#endif

#define DIFFUSE_ALBEDO(X)				X.VGPRs[0].xyz
#define DIFFUSE_ROUGHNESS(X)			X.VGPRs[0].w
// Either with SSS profile
#define DIFFUSE_SSSPROFILEID(X)			X.VGPRs[1].x
#define DIFFUSE_SSSPROFILERADIUS(X)		X.VGPRs[1].y
// Or explicit DMFP
#define DIFFUSE_SSSDMFPALBEDO(X)		X.VGPRs[1].xyz
#define DIFFUSE_SSSDMFPRADIUS(X)		X.VGPRs[1].w

#define DIELECTRIC_TINT(X)				X.VGPRs[0].xyz
#define DIELECTRIC_IOR(X)				X.VGPRs[0].w
#define DIELECTRIC_ROUGHNESS0(X)		X.VGPRs[1].y
#define DIELECTRIC_ROUGHNESS1(X)		X.VGPRs[1].x

#define CONDUCTOR_REFLECTIVITY(X)		X.VGPRs[0].xyz
#define CONDUCTOR_EDGECOLOR(X)			X.VGPRs[1].xyz
#define CONDUCTOR_ROUGHNESS0(X)			X.VGPRs[0].w
#define CONDUCTOR_ROUGHNESS1(X)			X.VGPRs[1].w

#define VOLUME_ALBEDO(X)				X.VGPRs[0].xyz
#define VOLUME_EXTINCTION(X)			X.VGPRs[1].xyz
#define VOLUME_ANISOTROPY(X)			X.VGPRs[0].w
#define VOLUME_THICKNESS(X)				X.VGPRs[1].w

#define SHEEN_ALBEDO(X)					X.VGPRs[0].xyz
#define SHEEN_ROUGHNESS(X)				X.VGPRs[0].w

#define VOLUMETRICFOGCLOUD_ALBEDO(X)	X.VGPRs[0].xyz
#define VOLUMETRICFOGCLOUD_EXTINCTION(X)X.VGPRs[1].xyz
#define VOLUMETRICFOGCLOUD_AO(X)		X.VGPRs[0].w

#define UNLIT_TRANSMITTANCE(X)			X.VGPRs[0].xyz

#define HAIR_BASECOLOR(X)				X.VGPRs[0].xyz
#define HAIR_SCATTER(X)					X.VGPRs[0].w
#define HAIR_ROUGHNESS(X)				X.VGPRs[1].x
#define HAIR_SPECULAR(X)				X.VGPRs[1].y
#define HAIR_BACKLIT(X)					X.VGPRs[1].z

void StrataRequestSharedNormalTangentBasis(inout uint NormalTypes, uint Index);

bool StrataHasAnisotropy(in float Roughness0, float Roughness1)
{
	return Roughness0 != Roughness1;
}

// Return true if a BSDF has a custom area light integrator
bool StrataHasAreaLightIntegrator(in FStrataBSDF BSDF)
{
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	return
		BSDFType == STRATA_BSDF_TYPE_CONDUCTOR ||
		BSDFType == STRATA_BSDF_TYPE_DIELECTRIC;
}

bool StrataHasScattering(in float3 Albedo)
{
	return any(Albedo > 0.0f);
}

bool StrataHasGreyScaleWeight(in float3 Weight)
{
	return Weight.x == Weight.y && Weight.y == Weight.z;
}


struct FStrataLayer
{
	int BSDFCount;

	FStrataBSDF BSDFs[STRATA_MAX_BSDF_COUNT_PER_LAYER];
};

struct FStrataData
{
	int LayerCount;

	FStrataLayer Layers[STRATA_MAX_LAYER_COUNT];	// Layer 0 is the top layer
};

uint GetStrataSubsurfaceProfile(float NormalizedId)
{
	// can be optimized
	return uint(NormalizedId * 255.0f + 0.5f);

}
FStrataData GetInitialisedStrataData()
{
	FStrataData StrataData = (FStrataData)0;
	return StrataData;
}

FStrataData GetStrataDiffuseBSDF(float3 Albedo, float Roughness, float SSSProfileID, float SSSDMFPScale, float3 SSSDMFPAlbedo, float SSSDMFPRadius, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_DIFFUSE);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	BSDF_SETHASSCATTERING	(StrataData.Layers[0].BSDFs[0],		SSSDMFPScale > 0 ? 1 : 0);

	const bool bHasSSSProfile = SSSProfileID > 0;
	BSDF_SETHASSSSPROFILE	(StrataData.Layers[0].BSDFs[0],		bHasSSSProfile ? 1 : 0);

	DIFFUSE_ALBEDO			(StrataData.Layers[0].BSDFs[0])		= Albedo;
	DIFFUSE_ROUGHNESS		(StrataData.Layers[0].BSDFs[0])		= Roughness;

	if (bHasSSSProfile)
	{
		DIFFUSE_SSSPROFILEID	(StrataData.Layers[0].BSDFs[0])	= SSSProfileID;
		DIFFUSE_SSSPROFILERADIUS(StrataData.Layers[0].BSDFs[0])	= SSSDMFPScale;
	}
	else
	{
		DIFFUSE_SSSDMFPALBEDO	(StrataData.Layers[0].BSDFs[0])	= saturate(SSSDMFPAlbedo);
		DIFFUSE_SSSDMFPRADIUS	(StrataData.Layers[0].BSDFs[0])	= clamp(SSSDMFPRadius * SSSDMFPScale, 0.f, SSS_PROFILE_PERPIXEL_MAXRADIUS);
	}

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataDielectricBSDF(float2 Roughness, float IOR, float3 Tint, uint SharedNormalIndex, inout uint SharedNormalTypes)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	const uint bHasAnisotropy = StrataHasAnisotropy(Roughness.x, Roughness.y) ? 1 : 0;
	if (bHasAnisotropy)
	{
		StrataRequestSharedNormalTangentBasis(SharedNormalTypes, SharedNormalIndex);
	}

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_DIELECTRIC);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETANISOTROPY		(StrataData.Layers[0].BSDFs[0],		bHasAnisotropy);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	DIELECTRIC_IOR			(StrataData.Layers[0].BSDFs[0])		= IOR;
	DIELECTRIC_TINT			(StrataData.Layers[0].BSDFs[0])		= Tint;
	DIELECTRIC_ROUGHNESS0	(StrataData.Layers[0].BSDFs[0])		= Roughness.x;
	DIELECTRIC_ROUGHNESS1	(StrataData.Layers[0].BSDFs[0])		= Roughness.y;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataConductorBSDF(float3 Reflectivity, float3 EdgeColor, float2 Roughness, uint SharedNormalIndex, inout uint SharedNormalTypes)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	const uint bHasAnisotropy = StrataHasAnisotropy(Roughness.x, Roughness.y) ? 1 : 0;
	if (bHasAnisotropy)
	{
		StrataRequestSharedNormalTangentBasis(SharedNormalTypes, SharedNormalIndex);
	}

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_CONDUCTOR);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETANISOTROPY		(StrataData.Layers[0].BSDFs[0],		bHasAnisotropy);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	CONDUCTOR_REFLECTIVITY	(StrataData.Layers[0].BSDFs[0])		= Reflectivity;
	CONDUCTOR_EDGECOLOR		(StrataData.Layers[0].BSDFs[0])		= EdgeColor;
	CONDUCTOR_ROUGHNESS0	(StrataData.Layers[0].BSDFs[0])		= Roughness.x;
	CONDUCTOR_ROUGHNESS1	(StrataData.Layers[0].BSDFs[0])		= Roughness.y;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataVolumeBSDF(float3 Albedo, float3 Extinction, float Anisotropy, float Thickness, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	const uint bHasScattering = StrataHasScattering(Albedo) ? 1 : 0;

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE(				StrataData.Layers[0].BSDFs[0],	STRATA_BSDF_TYPE_VOLUME);
	BSDF_SETNORMALID(			StrataData.Layers[0].BSDFs[0],	SharedNormalIndex);
	BSDF_SETISTOPLAYER			(StrataData.Layers[0].BSDFs[0],	0);
	BSDF_SETHASSCATTERING		(StrataData.Layers[0].BSDFs[0], bHasScattering);
	VOLUME_ALBEDO				(StrataData.Layers[0].BSDFs[0])	= Albedo;
	VOLUME_EXTINCTION			(StrataData.Layers[0].BSDFs[0])	= Extinction;
	VOLUME_ANISOTROPY			(StrataData.Layers[0].BSDFs[0])	= Anisotropy;
	VOLUME_THICKNESS			(StrataData.Layers[0].BSDFs[0])	= Thickness;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataSheenBSDF(float3 Albedo, float Roughness, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_SHEEN);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	SHEEN_ALBEDO			(StrataData.Layers[0].BSDFs[0])		= Albedo;
	SHEEN_ROUGHNESS			(StrataData.Layers[0].BSDFs[0])		= Roughness;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataVolumeFogCloudBSDF(float3 Albedo, float3 Extinction, float3 Emissive, float AmbientOcclusion)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD);
	VOLUMETRICFOGCLOUD_ALBEDO		(StrataData.Layers[0].BSDFs[0]) = Albedo;
	VOLUMETRICFOGCLOUD_EXTINCTION	(StrataData.Layers[0].BSDFs[0]) = Extinction;
	VOLUMETRICFOGCLOUD_AO			(StrataData.Layers[0].BSDFs[0]) = AmbientOcclusion;
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], Emissive);

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

FStrataData GetStrataUnlitBSDF(float3 EmissiveColor, float3 TransmittanceColor)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_UNLIT);
	UNLIT_TRANSMITTANCE				(StrataData.Layers[0].BSDFs[0]) = TransmittanceColor;
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], EmissiveColor);

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

FStrataData GetStrataHairBSDF(float3 BaseColor, float Scatter, float Specular, float Roughness, float Backlit, float3 EmissiveColor, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_HAIR);
	BSDF_SETNORMALID				(StrataData.Layers[0].BSDFs[0], SharedNormalIndex);
	HAIR_BASECOLOR					(StrataData.Layers[0].BSDFs[0]) = BaseColor;
	HAIR_SCATTER					(StrataData.Layers[0].BSDFs[0]) = Scatter;
	HAIR_ROUGHNESS					(StrataData.Layers[0].BSDFs[0]) = Roughness;
	HAIR_SPECULAR					(StrataData.Layers[0].BSDFs[0]) = Specular;
	HAIR_BACKLIT					(StrataData.Layers[0].BSDFs[0]) = Backlit;
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], EmissiveColor);

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}



///////////////////////////////////////////////////////////////////////////////
// Shared normals

float3 StrataUnpackNormal(uint PackedNormal);
void StrataUnpackNormalAndTangent(inout float3 Normal, inout float3 Tangent, in uint InPacked);

#define STRATA_BASIS_TYPE_NORMAL 0
#define STRATA_BASIS_TYPE_TANGENT 1
struct FSharedNormals
{
	uint NormalCount;
	uint NormalTypes;
	float3 Normals[STRATA_MAX_SHARED_NORMAL_REGISTERS];
	float3 Tangents[STRATA_MAX_SHARED_NORMAL_REGISTERS];
};

FSharedNormals StrataInitialiseSharedNormals()
{
	FSharedNormals SharedNormals = (FSharedNormals)0;
	return SharedNormals;
}

void StrataRequestSharedNormalTangentBasis(inout uint NormalTypes, uint Index)
{
	NormalTypes = NormalTypes | (STRATA_BASIS_TYPE_TANGENT << Index);
}

uint StrataGetSharedNormalType(in uint NormalTypes, uint Index)
{
	return (NormalTypes >> Index) & 0x1 ? STRATA_BASIS_TYPE_TANGENT : STRATA_BASIS_TYPE_NORMAL;
}

struct FStrataPixelHeader
{
	uint BSDFCount;

#if STRATA_INLINE_SHADING
	// All the shared normal in VGPRS. This is only used in basepass and during forward rendering.
	FSharedNormals SharedNormals;
#else
	ByteAddressBuffer StrataBuffer;
	uint SharedNormalByteOffset;
	uint SharedNormalTypes;
#endif
};

FStrataPixelHeader InitialiseStrataPixelHeader()
{
	FStrataPixelHeader Out;
	Out.BSDFCount = 0;
#if STRATA_INLINE_SHADING
	Out.SharedNormals = (FSharedNormals)0;
#else
	Out.SharedNormalByteOffset = 0;
	Out.SharedNormalTypes = 0;
#endif
	return Out;
}

float3x3 StrataGetBSDFSharedBasis(in FStrataPixelHeader StrataPixelHeader, in FStrataBSDF BSDF)
{
#if STRATA_INLINE_SHADING
	// Assume Normal & Tangent are already been normalized
	float3 Normal  = StrataPixelHeader.SharedNormals.Normals[BSDF_GETNORMALID(BSDF)];
	float3 Tangent = StrataPixelHeader.SharedNormals.Tangents[BSDF_GETNORMALID(BSDF)];
	float3 Bitangent = cross(Normal, Tangent);
	return float3x3(Tangent, Bitangent, Normal);
#else
	const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDF) != 0;
	uint PackedBasis = StrataPixelHeader.StrataBuffer.Load(StrataPixelHeader.SharedNormalByteOffset + BSDF_GETNORMALID(BSDF) * STRATA_PACKED_NORMAL_STRIDE_BYTES);
	uint BasisType   = StrataGetSharedNormalType(StrataPixelHeader.SharedNormalTypes, BSDF_GETNORMALID(BSDF));
	float3x3 OutTangentBasis;
	if (BasisType == STRATA_BASIS_TYPE_NORMAL)
	{
		float3 Normal = StrataUnpackNormal(PackedBasis);
		OutTangentBasis = GetTangentBasis(Normal);
	}
	else // if (BasisType == STRATA_BASIS_TYPE_TANGENT)
	{
		float3 Normal;
		float3 Tangent;
		StrataUnpackNormalAndTangent(Normal, Tangent, PackedBasis);

		OutTangentBasis[0] = Tangent;
		OutTangentBasis[1] = cross(Normal, Tangent);
		OutTangentBasis[2] = Normal;
	}
	return OutTangentBasis;
#endif
}



///////////////////////////////////////////////////////////////////////////////
// Operators node

FStrataData StrataAdd(FStrataData A, FStrataData B)
{
	FStrataData StrataData = A;

	// Append each BSDF from B to A, with same layer position
	UNROLL
	for (int Layer = 0; Layer < B.LayerCount; ++Layer)
	{
		FStrataLayer ALayer = A.Layers[Layer];
		FStrataLayer BLayer = B.Layers[Layer];
		UNROLL
		for (int BSDF = 0; BSDF < BLayer.BSDFCount; BSDF++)
		{
			StrataData.Layers[Layer].BSDFs[ALayer.BSDFCount + BSDF] = BLayer.BSDFs[BSDF];
		}

		StrataData.Layers[Layer].BSDFCount = ALayer.BSDFCount + BLayer.BSDFCount;
	}

	StrataData.LayerCount = max(A.LayerCount, B.LayerCount);

	return StrataData;
}

FStrataData StrataMultiply(FStrataData A, float Weight)
{
	FStrataData StrataData = A;

	// Apply the weight to each BSDF
	UNROLL
	for (int Layer = 0; Layer < StrataData.LayerCount; ++Layer)
	{
		UNROLL
		for (int BSDF = 0; BSDF < StrataData.Layers[Layer].BSDFCount; ++BSDF)
		{
			StrataData.Layers[Layer].BSDFs[BSDF].Weight *= Weight;
		}
	}

	return StrataData;
}

FStrataData StrataHorizontalMixing(FStrataData Foreground, FStrataData Background, float Mix)
{
	const float ForgroundMixFactor = Mix;
	const float BackgroundMixFactor = 1.0 - Mix;

	FStrataData A = StrataMultiply(Foreground, ForgroundMixFactor);
	FStrataData B = StrataMultiply(Background, BackgroundMixFactor);
	return StrataAdd(A, B);
}

FStrataData StrataVerticalLayering(FStrataData Top, FStrataData Base)
{
	FStrataData StrataData = Top;

	// Add each layer from Base under Top
	int TopLayerCount = Top.LayerCount;
	UNROLL
	for (int Layer = 0; Layer < Base.LayerCount; ++Layer)
	{
		StrataData.Layers[TopLayerCount + Layer] = Base.Layers[Layer];
	}

	StrataData.LayerCount += Base.LayerCount;

	return StrataData;
}



///////////////////////////////////////////////////////////////////////////////
// Functions used to sanitize BSDF before they are used for lighting (when forward) or stored to memory (base pass).
// We do not normalize normals, this is done before the lighting step.

void SanitizeStrataDiffuse(inout FStrataBSDF BSDF)
{
	DIFFUSE_ALBEDO(BSDF) = saturate(DIFFUSE_ALBEDO(BSDF));
	DIFFUSE_ROUGHNESS(BSDF) = saturate(DIFFUSE_ROUGHNESS(BSDF));
}

void SanitizeStrataDielectric(inout FStrataBSDF BSDF)
{
	DIELECTRIC_IOR(BSDF) = clamp(DIELECTRIC_IOR(BSDF), 1.0f, 5.0f);		// See https://en.wikipedia.org/wiki/List_of_refractive_indices
	DIELECTRIC_TINT(BSDF) = saturate(DIELECTRIC_TINT(BSDF));
	DIELECTRIC_ROUGHNESS0(BSDF) = saturate(DIELECTRIC_ROUGHNESS0(BSDF));
	DIELECTRIC_ROUGHNESS1(BSDF) = saturate(DIELECTRIC_ROUGHNESS1(BSDF));
}

void SanitizeStrataConductor(inout FStrataBSDF BSDF)
{
	CONDUCTOR_REFLECTIVITY(BSDF) = saturate(CONDUCTOR_REFLECTIVITY(BSDF));
	CONDUCTOR_EDGECOLOR(BSDF) = saturate(CONDUCTOR_EDGECOLOR(BSDF));
	CONDUCTOR_ROUGHNESS0(BSDF) = saturate(CONDUCTOR_ROUGHNESS0(BSDF));
	CONDUCTOR_ROUGHNESS1(BSDF) = saturate(CONDUCTOR_ROUGHNESS1(BSDF));
}

void SanitizeStrataVolume(inout FStrataBSDF BSDF)
{
	VOLUME_ALBEDO(BSDF) = saturate(VOLUME_ALBEDO(BSDF));
	VOLUME_EXTINCTION(BSDF) = max(0.0f, VOLUME_EXTINCTION(BSDF));
	VOLUME_ANISOTROPY(BSDF) = max(0.0f, VOLUME_ANISOTROPY(BSDF));
	VOLUME_THICKNESS(BSDF) = max(0.0f, VOLUME_THICKNESS(BSDF));
}

void SanitizeStrataSheen(inout FStrataBSDF BSDF)
{
	SHEEN_ALBEDO(BSDF) = saturate(SHEEN_ALBEDO(BSDF));
	SHEEN_ROUGHNESS(BSDF) = saturate(SHEEN_ROUGHNESS(BSDF));
}

void SanitizeStrataHair(inout FStrataBSDF BSDF)
{
	HAIR_BASECOLOR(BSDF) = saturate(HAIR_BASECOLOR(BSDF));
	HAIR_SCATTER(BSDF) = saturate(HAIR_SCATTER(BSDF));
	HAIR_ROUGHNESS(BSDF) = saturate(HAIR_ROUGHNESS(BSDF));
	HAIR_SPECULAR(BSDF) = saturate(HAIR_SPECULAR(BSDF));
	HAIR_BACKLIT(BSDF) = saturate(HAIR_BACKLIT(BSDF));
	BSDF_SETEMISSIVE(BSDF, clamp(BSDF_GETEMISSIVE(BSDF), 0.0, Max10BitsFloat));
}

void StrataSanitizeBSDF(inout FStrataBSDF BSDF)
{
	switch (BSDF_GETTYPE(BSDF))
	{
		case STRATA_BSDF_TYPE_DIFFUSE:
		{
			SanitizeStrataDiffuse(BSDF);
			break; 
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		{
			SanitizeStrataDielectric(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			SanitizeStrataConductor(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			SanitizeStrataVolume(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_SHEEN:
		{
			SanitizeStrataSheen(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_HAIR:
		{
			SanitizeStrataHair(BSDF);
			break;
		}
	}
}



///////////////////////////////////////////////////////////////////////////////
// BSDFs packing/unpacking
// 11G11B10F and 10F are unsigned float format

uint Pack10F(float Value)
{
	return (f32tof16(Value) >> 5) & 0x000003FF;
}

float Unpack10F(uint Value)
{
	return f16tof32((Value << 5) & 0x7FE0);
}

uint PackR11G11B10F(float3 rgb)
{
	uint r = (f32tof16(rgb.r) << 17) & 0xFFE00000;
	uint g = (f32tof16(rgb.g) << 6)  & 0x001FFC00;
	uint b = (f32tof16(rgb.b) >> 5)  & 0x000003FF;
	return r | g | b;
}

float3 UnpackR11G11B10F(uint rgb)
{
	float r = f16tof32((rgb >> 17) & 0x7FF0);
	float g = f16tof32((rgb >> 6)  & 0x7FF0);
	float b = f16tof32((rgb << 5)  & 0x7FE0);
	return float3(r, g, b);
}

uint2 PackR16G16B16A16F(float4 rgba)
{
	uint A = (f32tof16(rgba.r) << 16) | f32tof16(rgba.g);
	uint B = (f32tof16(rgba.b) << 16) | f32tof16(rgba.a);
	return uint2 (A, B);
}

float4 UnpackR16G16B16A16F(uint2 AB)
{
	float r = f16tof32(AB.x >> 16);
	float g = f16tof32(AB.x);
	float b = f16tof32(AB.y >> 16);
	float a = f16tof32(AB.y);
	return float4(r, g, b, a);
}

uint PackAlbedoLinearToGamma2(float3 rgb)
{
	uint r = (uint(sqrt(saturate(rgb.r)) * 255.0f) << 16);
	uint g = (uint(sqrt(saturate(rgb.g)) * 255.0f) << 8);
	uint b = (uint(sqrt(saturate(rgb.b)) * 255.0f) << 0);
	return r | g | b;
}

float3 UnpackAlbedoGamma2ToLinear(uint rgb)
{
	float r = float((rgb >> 16) & 0x000000FF);
	float g = float((rgb >> 8)  & 0x000000FF);
	float b = float((rgb >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return Gamma2 * Gamma2;	// Simple gamma 2.0
}

uint PackAlbedoLinearToGamma2AlphaLinear(float4 rgba)
{
	uint r = (uint(sqrt(saturate(rgba.r)) * 255.0f) << 24);
	uint g = (uint(sqrt(saturate(rgba.g)) * 255.0f) << 16);
	uint b = (uint(sqrt(saturate(rgba.b)) * 255.0f) << 8);
	uint a = (uint(     saturate(rgba.a)  * 255.0f) << 0);
	return r | g | b | a;
}

float4 UnpackAlbedoGamma2ToLinearAlphaLinear(uint rgba)
{
	float r = float((rgba >> 24) & 0x000000FF);
	float g = float((rgba >> 16) & 0x000000FF);
	float b = float((rgba >> 8)  & 0x000000FF);
	float a = float((rgba >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return float4(Gamma2 * Gamma2, a * (1.0f / 255.0f));	// Simple gamma 2.0
}

uint PackRGBA8(float4 rgba)
{
	uint r = (uint(saturate(rgba.r) * 255.0f) << 0);
	uint g = (uint(saturate(rgba.g) * 255.0f) << 8);
	uint b = (uint(saturate(rgba.b) * 255.0f) << 16);
	uint a = (uint(saturate(rgba.a) * 255.0f) << 24);
	return r | g | b | a;
}

float4 UnpackRGBA8(uint rgba)
{
	float4 Out;
	Out.r = float((rgba >> 0)  & 0xFF);
	Out.g = float((rgba >> 8)  & 0xFF);
	Out.b = float((rgba >> 16) & 0xFF);
	Out.a = float((rgba >> 24) & 0xFF);
	return Out;
}

// Simple Octahedral from "A Survey of Efficient Representations for Independent Unit Vectors" http://jcgt.org/published/0003/02/01/
float SignNotZero(in float k)
{
	return k >= 0.0 ? 1.0 : -1.0;
}
float2 SignNotZero(in float2 v)
{
	return float2(SignNotZero(v.x), SignNotZero(v.y));
}

uint StrataPackNormal(in float3 Normal)
{
	float l1norm = abs(Normal.x) + abs(Normal.y) + abs(Normal.z);
	float2 result = Normal.xy * (1.0 / l1norm);
	if (Normal.z < 0.0)
	{
		result = (1.0 - abs(result.yx)) * SignNotZero(result.xy);
	}
	uint PackedX = f32tof16(result.x);
	uint PackedY = f32tof16(result.y);
	return PackedX | (PackedY << 16);
}

float3 StrataUnpackNormal(uint PackedNormal)
{
	float x = f16tof32(0xFFFFFFFF &  PackedNormal);
	float y = f16tof32(0xFFFFFFFF & (PackedNormal>>16));

	float3 Normal = float3(x, y, 1.0f - abs(x) - abs(y));
	if (Normal.z < 0.0f)
	{
		Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
	}
	return normalize(Normal);
}

#define STRATA_TANGENT_SYMMETRY 1
uint StrataPackNormalAndTangent(in float3 Normal, in float3 Tangent)
{
	uint X10Bits;
	uint Y10Bits;
	uint Z11Bits;
	uint W1Bit;

	// Oct. encoding for the normal
	{
		float l1norm = abs(Normal.x) + abs(Normal.y) + abs(Normal.z);
		float2 result = Normal.xy * (1.0 / l1norm);
		if (Normal.z < 0.0)
		{
			result = (1.0 - abs(result.yx)) * SignNotZero(result.xy);
		}
		X10Bits = uint(clamp(result.x * 511.0f + 512.0f, 0.0f, 1023.0f));
		Y10Bits = uint(clamp(result.y * 511.0f + 512.0f, 0.0f, 1023.0f));
	}

	// Oct. encoding for the projected tangent, relative to an generated ortho frame based on normal
	{
		// Use the quantize normal to regenerate tje ortho. frame. This removes discontinuities
		float x = float(int(X10Bits) - 512) / 511.0f;
		float y = float(int(Y10Bits) - 512) / 511.0f;
		Normal = float3(x, y, 1.0f - abs(x) - abs(y));
		if (Normal.z < 0.0f)
		{
			Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
		}
		//Normal = normalize(Normal);

		float3x3 LocalRef = GetTangentBasis(Normal);
		float2 ProjXY = float2(dot(LocalRef[0], Tangent), dot(LocalRef[1], Tangent));
	#if STRATA_TANGENT_SYMMETRY
		// Use symmetry to improve precision
		ProjXY = ProjXY.x >= 0 ? ProjXY : -ProjXY.xy;
	#endif
		float l1norm = abs(ProjXY.x) + abs(ProjXY.y);
		float2 result = ProjXY.xy * (1.0 / l1norm);

	#if STRATA_TANGENT_SYMMETRY
		Z11Bits = uint(clamp(result.x * 2047.0f, 0.0f, 2047.0f));
	#else
		Z11Bits = uint(clamp(result.x * 1023.0f + 1024.0f, 0.0f, 2047.0f));
	#endif
		W1Bit   = ProjXY.y >= 0 ? 1u : 0u;
	}

	return
		 (0x3FF & X10Bits)        | 
		((0x3FF & Y10Bits) << 10) | 
		((0x7FF & Z11Bits) << 20) |
		((0x1   & W1Bit  ) << 31);
}

void StrataUnpackNormalAndTangent(inout float3 Normal, inout float3 Tangent, in uint InPacked)
{
	uint X10Bits = 0x3FF &  InPacked;
	uint Y10Bits = 0x3FF & (InPacked>>10);
	uint Z11bits = 0x7FF & (InPacked>>20);
	uint W1Bit   = 0x1   & (InPacked>>31);

	// Oct. decoding for the normal
	{
		float x = float(int(X10Bits) - 512) / 511.0f;
		float y = float(int(Y10Bits) - 512) / 511.0f;

		Normal = float3(x, y, 1.0f - abs(x) - abs(y));
		if (Normal.z < 0.0f)
		{
			Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
		}
		Normal = normalize(Normal);
	}

	// Oct. decoding for the projected tangent, relative to an generated ortho frame based on normal
	{
		// Create intermediate basis
		float3x3 LocalRef = GetTangentBasis(Normal);
	#if STRATA_TANGENT_SYMMETRY
		float x = float(Z11bits) / 2047.0f;
	#else
		float x = float(int(Z11bits) - 1024) / 1023.0f;
	#endif
		float Sign = (W1Bit > 0 ? 1 : -1);
		float2 ProjX = float2(x, 1.0f - abs(x));
		Tangent = LocalRef[0] * ProjX.x + LocalRef[1] * ProjX.y * Sign;
		Tangent = normalize(Tangent);
	}
}


#if COMPILER_SWITCH // These platforms are complaining so simply disabling Strata there for now.

#define STRATA_STORE_UINT1(x) 
#define STRATA_STORE_UINT2(x) 
#define STRATA_STORE_UINT3(x) 
#define STRATA_STORE_UINT4(x) 

#define STRATA_LOAD_UINT1(x) x = 0;
#define STRATA_LOAD_UINT2(x) x = 0;
#define STRATA_LOAD_UINT3(x) x = 0;
#define STRATA_LOAD_UINT4(x) x = 0;

#define STRATA_LOAD_FLOAT1(x) x = 0;
#define STRATA_LOAD_FLOAT2(x) x = 0;
#define STRATA_LOAD_FLOAT3(x) x = 0;
#define STRATA_LOAD_FLOAT4(x) x = 0;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint2 StrataLoadUint2(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint3 StrataLoadUint3(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint4 StrataLoadUint4(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }

#else

#define STRATA_STORE_UINT1(x) StrataBuffer.Store (ByteOffset, asuint(x)); ByteOffset += 4;
#define STRATA_STORE_UINT2(x) StrataBuffer.Store2(ByteOffset, asuint(x)); ByteOffset += 8;
#define STRATA_STORE_UINT3(x) StrataBuffer.Store3(ByteOffset, asuint(x)); ByteOffset += 12;
#define STRATA_STORE_UINT4(x) StrataBuffer.Store4(ByteOffset, asuint(x)); ByteOffset += 16;

#define STRATA_LOAD_UINT1(x) x = StrataBuffer.Load (ByteOffset); ByteOffset += 4;
#define STRATA_LOAD_UINT2(x) x = StrataBuffer.Load2(ByteOffset); ByteOffset += 8;
#define STRATA_LOAD_UINT3(x) x = StrataBuffer.Load3(ByteOffset); ByteOffset += 12;
#define STRATA_LOAD_UINT4(x) x = StrataBuffer.Load4(ByteOffset); ByteOffset += 16;

#define STRATA_LOAD_FLOAT1(x) x = asfloat(StrataBuffer.Load (ByteOffset)); ByteOffset += 4;
#define STRATA_LOAD_FLOAT2(x) x = asfloat(StrataBuffer.Load2(ByteOffset)); ByteOffset += 8;
#define STRATA_LOAD_FLOAT3(x) x = asfloat(StrataBuffer.Load3(ByteOffset)); ByteOffset += 12;
#define STRATA_LOAD_FLOAT4(x) x = asfloat(StrataBuffer.Load4(ByteOffset)); ByteOffset += 16;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint  x = StrataBuffer.Load (ByteOffset); ByteOffset += 4; return x; }
uint2 StrataLoadUint2(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint2 x = StrataBuffer.Load2(ByteOffset); ByteOffset += 8; return x; }
uint3 StrataLoadUint3(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint3 x = StrataBuffer.Load3(ByteOffset); ByteOffset +=12; return x; }
uint4 StrataLoadUint4(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint4 x = StrataBuffer.Load4(ByteOffset); ByteOffset +=16; return x; }

#endif

void StrataLoad_R16G16B16F_A16F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A, inout float B)
{
	float4 temp = UnpackR16G16B16A16F(StrataLoadUint2(StrataBuffer, ByteOffset));
	A = temp.xyz;
	B = temp.a;
}

void StrataLoad_R11G11B10F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A)
{
	A = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, ByteOffset));
}

void StrataLoad_R11_G11_B10F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float A, inout float B, inout float C)
{
	float3 temp = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, ByteOffset));
	A = temp.x;
	B = temp.y;
	C = temp.z;
}

void StrataLoad_AlbedoGamma2ToLinear(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A)
{
	A = UnpackAlbedoGamma2ToLinear(StrataLoadUint1(StrataBuffer, ByteOffset));
}

void StrataLoad_AlbedoGamma2ToLinearAlphaLinear(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 RGB, inout float A)
{
	float4 Data = UnpackAlbedoGamma2ToLinearAlphaLinear(StrataLoadUint1(StrataBuffer, ByteOffset));
	RGB = Data.rgb;
	A = Data.a;
}

uint PackStrataHeaderIn(uint BSDFCount, FStrataPixelHeader In);

uint GetStrataPixelDataByteOffset(uint2 PixelPos, uint ViewBufferSizeX, uint StrataMaxBytesPerPixel)
{
	return (PixelPos.y * ViewBufferSizeX + PixelPos.x) * StrataMaxBytesPerPixel;
}

// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
void PackStrataOut(
	RWByteAddressBuffer StrataBuffer, 
	uint ByteOffset, 
	FStrataPixelHeader StrataPixelHeader,
	FStrataData Strata,
	float3 VertexNormal,
	float3 V,
	inout FGBufferData GBuffer)
{

	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	uint BSDFCount = 0;
	float3 Throughput = 1.0f;

	// We clamp the layer count to the maximum one according to our byte per pixel budget (removing the bottom layer first)
	Strata.LayerCount = STRATA_CLAMPED_LAYER_COUNT;

	// Subsurface scattering parameters
	bool   bHasSubsurfaceScattering = false;
	bool   bHasSubsurfaceProfile = false;
	float  SubsurfaceProfile = 0;
	float  SubsurfaceRadiusScale = 0;
	float3 SubsurfaceBaseColor = 0;
	float3 SubsurfaceDMFPAlbedo = 0;
	float  SubsurfaceDMFPRadius = 0;

	// For each of the BSDF, we evaluated their combined weight/throughput according to the material operation performed (layering, mixing, etc.).
	int l;
	UNROLL
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		float3 LayerThroughput = 0.0f;
		float3 LayerCoverage = 0.0f;

		float3 AccumTopNormal = 0.0f;
		float  AccumRoughness = 0.0f;
		float  AccumRoughnessCount = 0.0f;
		float3 AccumBaseColor = 0.0f;
		const bool bTopLayer = l == 0;

		UNROLL
		for (int i = 0; i < Strata.Layers[l].BSDFCount; ++i)
		{
			// Sanitize BSDF in place before it is used and packed out to memory
			StrataSanitizeBSDF(Strata.Layers[l].BSDFs[i]);

			FStrataBSDF BSDF = Strata.Layers[l].BSDFs[i];
			const float3 BSDFCoverage = BSDF.Weight;
			const float  BSDFCoverageAvg = dot(BSDF.Weight,1.0f/3.0f);
			BSDFCount++;

			// STRATA_TODO apply the same normal transform as for the material
			float3x3 TangentBasis = StrataGetBSDFSharedBasis(StrataPixelHeader, BSDF);
			float3 N = TangentBasis[2];
			//N = normalize(N);

			AccumTopNormal += N;

			BxDFContext ContextNoLight = (BxDFContext)0;
			const float3 FakeL = float3(0, 0, 1);
			Init(ContextNoLight, N, V, FakeL);

			switch (BSDF_GETTYPE(BSDF))
			{
			case STRATA_BSDF_TYPE_DIFFUSE:
			{
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverageAvg * FullyRough; // Do not trigger SSR by using fully rough
					AccumRoughnessCount += BSDFCoverageAvg;
				}

				// Select the first/toppest layer with subsurface scattering
				if (BSDF_GETHASSCATTERING(BSDF) && BSDFCoverageAvg > 0 && DIFFUSE_SSSPROFILERADIUS(BSDF) > 0 && !bHasSubsurfaceScattering)
				{
					bHasSubsurfaceScattering = true;
					bHasSubsurfaceProfile	= BSDF_GETHASSSSPROFILE(BSDF);
					SubsurfaceProfile		= DIFFUSE_SSSPROFILEID(BSDF);
					SubsurfaceRadiusScale	= DIFFUSE_SSSPROFILERADIUS(BSDF);
					SubsurfaceBaseColor		= DIFFUSE_ALBEDO(BSDF);
					SubsurfaceDMFPAlbedo	= DIFFUSE_SSSDMFPALBEDO(BSDF);
					SubsurfaceDMFPRadius	= DIFFUSE_SSSDMFPRADIUS(BSDF);
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_DIELECTRIC:
			{
				float F0 = DielectricIorToF0(DIELECTRIC_IOR(BSDF));
				float3 F = F_Schlick(F0, ContextNoLight.VoH);

				if (bTopLayer)
				{
					AccumRoughness		+= DIELECTRIC_ROUGHNESS0(BSDF);
					AccumRoughnessCount += 1.0f;

					const float SafeRoughness = MakeRoughnessSafe(DIELECTRIC_ROUGHNESS0(BSDF));
					AccumBaseColor		+= BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * (1.0f - F); // STRATA_TODO use 1-FGD instead of simple 1-F, event if we ignore ray scattering/spreading
				break;
			}

			case STRATA_BSDF_TYPE_CONDUCTOR:
			{
				float3 F = F_Schlick(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_EDGECOLOR(BSDF), ContextNoLight.VoH);

				if (bTopLayer)
				{
					AccumRoughness		+= CONDUCTOR_ROUGHNESS0(BSDF);
					AccumRoughnessCount += 1.0f;

					const float SafeRoughness = MakeRoughnessSafe(CONDUCTOR_ROUGHNESS0(BSDF));
					AccumBaseColor		+= BSDFCoverage * EnvBRDFApprox(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_EDGECOLOR(BSDF), SafeRoughness, saturate(ContextNoLight.NoV));;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_VOLUME:
			{
				const float3 Albedo					= VOLUME_ALBEDO(BSDF);
				const float3 ExtinctionCoefficients = VOLUME_EXTINCTION(BSDF);
				const float3 ScatteringCoefficients = Albedo * ExtinctionCoefficients;
				const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
				const float  Thickness				= VOLUME_THICKNESS(BSDF);

				const float3 SafeExtinctionThreshold = 0.000001f;
				const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

				const float PathLength = Thickness / max(0.0001f, abs(ContextNoLight.NoV));
				const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
				
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverageAvg * FullyRough; // Do not trigger SSR by using fully rough
					AccumRoughnessCount += BSDFCoverageAvg;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * SafePathSegmentTransmittance;
				break;
			}

			case STRATA_BSDF_TYPE_SHEEN:
			{
				const float3 F0  = SHEEN_ALBEDO(BSDF);
				const float3 F = F_Schlick(F0, ContextNoLight.VoH);

				if (bTopLayer)
				{
					AccumRoughness		+= SHEEN_ROUGHNESS(BSDF);
					AccumRoughnessCount += 1.0f;

					const float SafeRoughness = MakeRoughnessSafe(SHEEN_ROUGHNESS(BSDF));
					AccumBaseColor      += BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * (1.0f - F); // STRATA_TODO use 1-FGD instead of simple 1-F, event if we ignore ray scattering/spreading
				break;
			}

			case STRATA_BSDF_TYPE_HAIR:
			{
				// No SSR
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverageAvg * FullyRough; // Do not trigger SSR by using fully rough
					AccumRoughnessCount += BSDFCoverageAvg;
				}
				// Hair are considered opaque
				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			} // switch

			// Update the weights to take into account throughput towards the view from layers above
			Strata.Layers[l].BSDFs[i].Weight *= Throughput;
			
			// Notify that the BSDF is at the top for SSR to only affect reflection there and not on the lower layers
			BSDF_SETISTOPLAYER(Strata.Layers[l].BSDFs[i], bTopLayer ? 1 : 0);
		}

		// Now modify the gbuffer according to the top layer information
		if (bTopLayer)
		{
			// Normal is needed for some AO techniques
			GBuffer.WorldNormal = normalize(AccumTopNormal);

			// Roughness is needed for SSR, base color represents EnvBRDF
			GBuffer.Roughness = AccumRoughnessCount > 0.0f ? saturate(AccumRoughness / AccumRoughnessCount) : FullyRough;
			GBuffer.BaseColor = saturate(AccumBaseColor);
			
			// Approximative way to be able to have SSR produce colored specular reflections
			GBuffer.Specular = 1;
			GBuffer.Metallic = 1;
		}

		// Take into account the non covered part for this layer and update throughput accordingly
		LayerThroughput += (1.0 - saturate(LayerCoverage)) * FullThroughput;

		// And combine this layer throughtput with he material throughput
		Throughput *= LayerThroughput;
	}

	// Patch Gbuffer data with SSS data if enabled
	GBuffer.CustomData = 0;
	if (bHasSubsurfaceScattering)
	{
		if (bHasSubsurfaceProfile)
		{
			GBuffer.BaseColor      = SubsurfaceBaseColor;
			GBuffer.CustomData.rgb = EncodeSubsurfaceProfile(SubsurfaceProfile);
			GBuffer.CustomData.a   = SubsurfaceRadiusScale;
		}
		else
		{
			GBuffer.BaseColor      = SubsurfaceBaseColor;
			GBuffer.CustomData.rgb = sqrt(SubsurfaceDMFPAlbedo);
			GBuffer.CustomData.a   = saturate(SubsurfaceDMFPRadius / SSS_PROFILE_PERPIXEL_MAXRADIUS);
		}
	}

	// Now write out Strata data

	// 1. the header
	STRATA_STORE_UINT1(PackStrataHeaderIn(BSDFCount, StrataPixelHeader));
#if STRATA_INLINE_SHADING
	UNROLL
	for (uint i = 0; i < StrataPixelHeader.SharedNormals.NormalCount; ++i)
	{
		const uint BasisType = StrataGetSharedNormalType(StrataPixelHeader.SharedNormals.NormalTypes, i);
		if (BasisType == STRATA_BASIS_TYPE_NORMAL)
		{
			STRATA_STORE_UINT1(StrataPackNormal(StrataPixelHeader.SharedNormals.Normals[i]));
		}
		else // if (BasisType == STRATA_BASIS_TYPE_TANGENT)
		{
			STRATA_STORE_UINT1(StrataPackNormalAndTangent(StrataPixelHeader.SharedNormals.Normals[i], StrataPixelHeader.SharedNormals.Tangents[i]));
		}
	}
#endif

	// 2. the list of BSDFs
	BSDFCount = 0;
	UNROLL
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		FStrataLayer Layer = Strata.Layers[l];

		UNROLL
		for (int i = 0; i < Layer.BSDFCount; ++i)
		{
			FStrataBSDF BSDF = Layer.BSDFs[i];

			const uint GreyScaleWeight = StrataHasGreyScaleWeight(BSDF.Weight) ? 1 : 0;
			BSDF_SETGREYWEIGHT(BSDF, GreyScaleWeight);
			if (GreyScaleWeight > 0)
			{
				BSDF_SETWEIGHT10F(BSDF, Pack10F(BSDF.Weight.x));
				STRATA_STORE_UINT1(BSDF.State);
			}
			else
			{
				STRATA_STORE_UINT1(BSDF.State);
				STRATA_STORE_UINT1(PackR11G11B10F(BSDF.Weight));
			}

			const uint BSDFType = BSDF_GETTYPE(BSDF);
			switch (BSDF_GETTYPE(BSDF))
			{
			case STRATA_BSDF_TYPE_DIFFUSE:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(DIFFUSE_ALBEDO(BSDF), DIFFUSE_ROUGHNESS(BSDF))));
				if (BSDF_GETHASSCATTERING(BSDF))
				{
					if (BSDF_GETHASSSSPROFILE(BSDF))
					{
						STRATA_STORE_UINT1(PackRGBA8(float4(DIFFUSE_SSSPROFILEID(BSDF), DIFFUSE_SSSPROFILERADIUS(BSDF), 0, 0)));
					}
					else
					{
						STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(DIFFUSE_SSSDMFPALBEDO(BSDF), DIFFUSE_SSSDMFPRADIUS(BSDF) / SSS_PROFILE_PERPIXEL_MAXRADIUS)));
					}
				}
				// 8 bytes
			}
			break;
			case STRATA_BSDF_TYPE_DIELECTRIC:
			{
				STRATA_STORE_UINT1(PackR11G11B10F(DIELECTRIC_TINT(BSDF)));
				STRATA_STORE_UINT1(PackR11G11B10F(float3(DIELECTRIC_ROUGHNESS0(BSDF), DIELECTRIC_ROUGHNESS1(BSDF), DIELECTRIC_IOR(BSDF))));
				// 8 bytes
			}
			break;
			case STRATA_BSDF_TYPE_CONDUCTOR:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_ROUGHNESS0(BSDF))));
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(CONDUCTOR_EDGECOLOR(BSDF),    CONDUCTOR_ROUGHNESS1(BSDF))));
				// 8 bytes
			}
			break;
			case STRATA_BSDF_TYPE_VOLUME:
			{
				// We simply multiply the absorption and scattering coefficient by the thickness to simplify the material to be a normalise medium of thickness 1 meter.
				// This gives the same result and reduces memory usage.
				const float Thickness = VOLUME_THICKNESS(BSDF);
				STRATA_STORE_UINT1(PackR11G11B10F(VOLUME_EXTINCTION(BSDF) * Thickness));
				if (BSDF_GETHASSCATTERING(BSDF))
				{
					STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(VOLUME_ALBEDO(BSDF), VOLUME_ANISOTROPY(BSDF) * 0.5f + 0.5f)));
				}
				// 8 bytes
			}
			break;
			case STRATA_BSDF_TYPE_SHEEN:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(SHEEN_ALBEDO(BSDF), SHEEN_ROUGHNESS(BSDF))));
				// 4 bytes
			}
			break;
			case STRATA_BSDF_TYPE_HAIR:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(HAIR_BASECOLOR(BSDF), HAIR_ROUGHNESS(BSDF))));
				STRATA_STORE_UINT1(PackR11G11B10F(float3(HAIR_SCATTER(BSDF), HAIR_SPECULAR(BSDF), HAIR_BACKLIT(BSDF))));
				// 8 bytes
			}
			break;
			}

			// Stop writing if above budget.
			BSDFCount++;
		}
	}
}

// Pack only strata header
uint PackStrataHeaderIn(uint InBSDFCount, FStrataPixelHeader InHeader)
{
	uint Out = InBSDFCount;
#if STRATA_INLINE_SHADING
	Out    |= (InHeader.SharedNormals.NormalCount << 8);
	Out    |= (InHeader.SharedNormals.NormalTypes << 16);
#endif
	return Out;
}

// Unpack only strata header
// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
FStrataPixelHeader UnpackStrataHeaderIn(ByteAddressBuffer StrataBuffer, inout uint ByteOffset)
{
	FStrataPixelHeader Out = InitialiseStrataPixelHeader();

	uint Packed = 0;
	STRATA_LOAD_UINT1(Packed);
	Out.BSDFCount    = 0xFF &  Packed;
	uint NormalCount = 0xFF & (Packed >> 8);
	uint NormalTypes = 0xFF & (Packed >> 16);

#if STRATA_INLINE_SHADING==0
	// Only keep the offset to the shared normal memory. We are going to load them on demand.
	Out.SharedNormalByteOffset = ByteOffset;
	Out.StrataBuffer = StrataBuffer;
	Out.SharedNormalTypes = NormalTypes;

	// Now skip over the shared normal memory to be able to load the BSDF content
	ByteOffset += NormalCount * STRATA_PACKED_NORMAL_STRIDE_BYTES;
#endif

	return Out;
}

// Unpack a single BSDF
// Note: All BSDF lobes needs to be unpack in a sequential manner since each BSDF has a variable footprint.
// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
FStrataBSDF UnpackStrataBSDFIn(ByteAddressBuffer StrataBuffer, inout uint ByteOffset)
{
	FStrataBSDF OutBSDF = (FStrataBSDF)0;

	float DummyFloat = 0.0f;

	STRATA_LOAD_UINT1(OutBSDF.State);
	if (BSDF_GETGREYWEIGHT(OutBSDF))
	{
		OutBSDF.Weight = Unpack10F(BSDF_GETWEIGHT10F(OutBSDF));
	}
	else
	{
		StrataLoad_R11G11B10F(StrataBuffer, ByteOffset, OutBSDF.Weight);
	}


	const uint BSDFType = BSDF_GETTYPE(OutBSDF);
	BSDF_SETTYPE(OutBSDF, BSDFType);
	switch (BSDFType)
	{
	case STRATA_BSDF_TYPE_DIFFUSE:
	{
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, DIFFUSE_ALBEDO(OutBSDF), DIFFUSE_ROUGHNESS(OutBSDF));
		if (BSDF_GETHASSCATTERING(OutBSDF))
		{
			if (BSDF_GETHASSSSPROFILE(OutBSDF))
			{
				float4 Data = UnpackRGBA8(StrataLoadUint1(StrataBuffer, ByteOffset));
				DIFFUSE_SSSPROFILEID(OutBSDF)	  = Data.r;
				DIFFUSE_SSSPROFILERADIUS(OutBSDF) = Data.g;
			}
			else
			{
				StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, DIFFUSE_SSSDMFPALBEDO(OutBSDF), DIFFUSE_SSSDMFPRADIUS(OutBSDF));
				DIFFUSE_SSSDMFPRADIUS(OutBSDF) *= SSS_PROFILE_PERPIXEL_MAXRADIUS;
			}
		}
	}
	break;
	case STRATA_BSDF_TYPE_DIELECTRIC:
	{
		StrataLoad_R11G11B10F			(StrataBuffer, ByteOffset, DIELECTRIC_TINT(OutBSDF));
		StrataLoad_R11_G11_B10F			(StrataBuffer, ByteOffset, DIELECTRIC_ROUGHNESS0(OutBSDF), DIELECTRIC_ROUGHNESS1(OutBSDF), DIELECTRIC_IOR(OutBSDF));
	}
	break;
	case STRATA_BSDF_TYPE_CONDUCTOR:
	{
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, CONDUCTOR_REFLECTIVITY(OutBSDF),	CONDUCTOR_ROUGHNESS0(OutBSDF));
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, CONDUCTOR_EDGECOLOR(OutBSDF),		CONDUCTOR_ROUGHNESS1(OutBSDF));
	}
	break;
	case STRATA_BSDF_TYPE_VOLUME:
	{
		StrataLoad_R11G11B10F			(StrataBuffer, ByteOffset, VOLUME_EXTINCTION(OutBSDF));
		if (BSDF_GETHASSCATTERING(OutBSDF))
		{
			StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, VOLUME_ALBEDO(OutBSDF), VOLUME_ANISOTROPY(OutBSDF));
			VOLUME_ANISOTROPY(OutBSDF) = VOLUME_ANISOTROPY(OutBSDF) * 2.0f - 1.0f;
		}
		// else, albedo and anisotropy have already cleared out to zero when creating OutBSDF.
		VOLUME_THICKNESS(OutBSDF) = 1.0f;
	}
	break;
	case STRATA_BSDF_TYPE_SHEEN:
	{
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, SHEEN_ALBEDO(OutBSDF), SHEEN_ROUGHNESS(OutBSDF));
	}
	break;
	case STRATA_BSDF_TYPE_HAIR:
	{
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, HAIR_BASECOLOR(OutBSDF), HAIR_ROUGHNESS(OutBSDF));
		StrataLoad_R11_G11_B10F(StrataBuffer, ByteOffset, HAIR_SCATTER(OutBSDF), HAIR_SPECULAR(OutBSDF), HAIR_BACKLIT(OutBSDF));
		// 8 bytes
	}
	break;
	}

	return OutBSDF;
}