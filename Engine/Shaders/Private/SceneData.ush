// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "LargeWorldCoordinates.ush"
#include "OctahedralCommon.ush"

#ifndef USE_GLOBAL_GPU_SCENE_DATA
	#define USE_GLOBAL_GPU_SCENE_DATA 0
#endif

#ifndef USE_GLOBAL_GPU_SCENE_DATA_RW
	#define USE_GLOBAL_GPU_SCENE_DATA_RW 0
#endif

#ifndef USES_PER_INSTANCE_CUSTOM_DATA
	#define USES_PER_INSTANCE_CUSTOM_DATA 0
#endif

#ifndef USES_PER_INSTANCE_RANDOM
	#define USES_PER_INSTANCE_RANDOM 0
#endif

#ifndef NEEDS_LIGHTMAP_COORDINATE
	#define NEEDS_LIGHTMAP_COORDINATE 0
#endif

// Whether to fetch primitive values (eg LocalToWorld) by dynamically indexing a scene-wide buffer, or to reference a single Primitive uniform buffer
#if VF_SUPPORTS_PRIMITIVE_SCENE_DATA
	#if FEATURE_LEVEL == FEATURE_LEVEL_ES3_1
		#define VF_USE_PRIMITIVE_SCENE_DATA 2
	#else	
		#define VF_USE_PRIMITIVE_SCENE_DATA 1
	#endif
#else
	#define VF_USE_PRIMITIVE_SCENE_DATA 0
#endif

// Must match PrimitiveUniformShaderParameters.h
#define PRIMITIVE_SCENE_DATA_FLAG_CAST_SHADOWS						0x1
#define PRIMITIVE_SCENE_DATA_FLAG_USE_SINGLE_SAMPLE_SHADOW_SL		0x2
#define PRIMITIVE_SCENE_DATA_FLAG_USE_VOLUMETRIC_LM_SHADOW_SL		0x4
#define PRIMITIVE_SCENE_DATA_FLAG_DECAL_RECEIVER					0x8
#define PRIMITIVE_SCENE_DATA_FLAG_DRAWS_VELOCITY					0x10
#define PRIMITIVE_SCENE_DATA_FLAG_OUTPUT_VELOCITY					0x20
#define PRIMITIVE_SCENE_DATA_FLAG_DETERMINANT_SIGN					0x40
#define PRIMITIVE_SCENE_DATA_FLAG_HAS_CAPSULE_REPRESENTATION		0x80
#define PRIMITIVE_SCENE_DATA_FLAG_HAS_CAST_CONTACT_SHADOW			0x100
#define PRIMITIVE_SCENE_DATA_FLAG_HAS_PRIMITIVE_CUSTOM_DATA			0x200
#define PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_0				0x400
#define PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_1				0x800
#define PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_2				0x1000
#define PRIMITIVE_SCENE_DATA_FLAG_VISIBLE_IN_RASTER					0x2000
#define PRIMITIVE_SCENE_DATA_FLAG_HAS_NANITE_IMPOSTER				0x4000
#define PRIMITIVE_SCENE_DATA_FLAG_HAS_INSTANCE_LOCAL_BOUNDS			0x8000

// GPUCULL_TODO: Eventually we need to remove this workaround
#define VF_TREAT_INSTANCE_ID_OFFSET_AS_PRIMITIVE_ID_FLAG (1U << 31U)

// Must match InstanceUniformShaderParameters.h
#define INSTANCE_SCENE_DATA_FLAG_DETERMINANT_SIGN			0x1
#define INSTANCE_SCENE_DATA_FLAG_HAS_RANDOM					0x2
#define INSTANCE_SCENE_DATA_FLAG_HAS_CUSTOM_DATA			0x4
#define INSTANCE_SCENE_DATA_FLAG_HAS_DYNAMIC_DATA			0x8
#define INSTANCE_SCENE_DATA_FLAG_HAS_LIGHTSHADOW_UV_BIAS	0x10
#define INSTANCE_SCENE_DATA_FLAG_HAS_HIERARCHY_OFFSET		0x20
#define INSTANCE_SCENE_DATA_FLAG_HAS_LOCAL_BOUNDS			0x40

#define INVALID_PRIMITIVE_ID 0x000FFFFFu

#define INSTANCE_COMPRESSED_TRANSFORM	0

#define NUM_CUSTOM_PRIMITIVE_DATA 9 // Num float4s used for custom data. Must match FCustomPrimitiveData::NumCustomPrimitiveDataFloat4s in SceneTypes.h

// Must match FPrimitiveUniformShaderParameters in C++
struct FPrimitiveSceneData
{
	uint		Flags; // TODO: Use 16 bits?
	int			InstanceSceneDataOffset; // Link to the range of instances that belong to this primitive
	int			NumInstanceSceneDataEntries;
	uint		SingleCaptureIndex; // TODO: Use 16 bits? 8 bits?
	float3		TilePosition;
	FLWCMatrix	LocalToWorld;
	FLWCInverseMatrix WorldToLocal;
	FLWCMatrix	PreviousLocalToWorld;
	FLWCInverseMatrix PreviousWorldToLocal;
	float3		InvNonUniformScale;
	float		ObjectBoundsX;
	FLWCVector3	ObjectWorldPosition;
	FLWCVector3	ActorWorldPosition;
	float		ObjectRadius;
	uint		LightmapUVIndex;   // TODO: Use 16 bits? // TODO: Move into associated array that disappears if static lighting is disabled
	float3		ObjectOrientation; // TODO: More efficient representation?
	uint		LightmapDataIndex; // TODO: Use 16 bits? // TODO: Move into associated array that disappears if static lighting is disabled
	float4		NonUniformScale;
	float3		PreSkinnedLocalBoundsMin;
	uint		NaniteResourceID;
	float3		PreSkinnedLocalBoundsMax;
	uint		NaniteHierarchyOffset;
	float3		LocalObjectBoundsMin;
	float		ObjectBoundsY;
	float3		LocalObjectBoundsMax;
	float		ObjectBoundsZ;
	uint		InstancePayloadDataOffset;
	uint		InstancePayloadDataStride; // TODO: Use 16 bits? 8 bits?
	float3		InstanceLocalBoundsCenter;
	float3		InstanceLocalBoundsExtent;
	float4		CustomPrimitiveData[NUM_CUSTOM_PRIMITIVE_DATA]; // TODO: Move to associated array to shrink primitive data and pack cachelines more effectively
};

// Fetch from Primitive uniform buffer
FPrimitiveSceneData GetPrimitiveDataFromUniformBuffer()
{
	FPrimitiveSceneData PrimitiveData;

	PrimitiveData.Flags							= Primitive.Flags;
	PrimitiveData.InstanceSceneDataOffset		= Primitive.InstanceSceneDataOffset;
	PrimitiveData.NumInstanceSceneDataEntries	= Primitive.NumInstanceSceneDataEntries;
	PrimitiveData.SingleCaptureIndex			= Primitive.SingleCaptureIndex;
	PrimitiveData.TilePosition					= Primitive.TilePosition;
	PrimitiveData.LocalToWorld					= MakeLWCMatrix4x3(Primitive.TilePosition, Primitive.LocalToRelativeWorld);
	PrimitiveData.WorldToLocal					= MakeLWCInverseMatrix4x3(Primitive.TilePosition, Primitive.RelativeWorldToLocal);
	PrimitiveData.PreviousLocalToWorld			= MakeLWCMatrix4x3(Primitive.TilePosition, Primitive.PreviousLocalToRelativeWorld);
	PrimitiveData.PreviousWorldToLocal			= MakeLWCInverseMatrix4x3(Primitive.TilePosition, Primitive.PreviousRelativeWorldToLocal);
	PrimitiveData.InvNonUniformScale			= Primitive.InvNonUniformScale;
	PrimitiveData.ObjectBoundsX					= Primitive.ObjectBoundsX;
	PrimitiveData.ObjectWorldPosition			= MakeLWCVector3(Primitive.TilePosition, Primitive.ObjectRelativeWorldPositionAndRadius.xyz);
	PrimitiveData.ObjectRadius					= Primitive.ObjectRelativeWorldPositionAndRadius.w;
	PrimitiveData.ActorWorldPosition			= MakeLWCVector3(Primitive.TilePosition, Primitive.ActorRelativeWorldPosition);
	PrimitiveData.LightmapUVIndex				= Primitive.LightmapUVIndex;
	PrimitiveData.ObjectOrientation				= Primitive.ObjectOrientation;
	PrimitiveData.LightmapDataIndex				= Primitive.LightmapDataIndex;
	PrimitiveData.NonUniformScale				= Primitive.NonUniformScale;
	PrimitiveData.PreSkinnedLocalBoundsMin		= Primitive.PreSkinnedLocalBoundsMin;
	PrimitiveData.NaniteResourceID				= Primitive.NaniteResourceID;
	PrimitiveData.PreSkinnedLocalBoundsMax		= Primitive.PreSkinnedLocalBoundsMax;
	PrimitiveData.NaniteHierarchyOffset			= Primitive.NaniteHierarchyOffset;
	PrimitiveData.LocalObjectBoundsMin			= Primitive.LocalObjectBoundsMin;
	PrimitiveData.ObjectBoundsY					= Primitive.ObjectBoundsY;
	PrimitiveData.LocalObjectBoundsMax			= Primitive.LocalObjectBoundsMax;
	PrimitiveData.ObjectBoundsZ					= Primitive.ObjectBoundsZ;
	PrimitiveData.InstancePayloadDataOffset		= Primitive.InstancePayloadDataOffset;
	PrimitiveData.InstancePayloadDataStride		= Primitive.InstancePayloadDataStride;
	
	UNROLL
	for (int DataIndex = 0; DataIndex < NUM_CUSTOM_PRIMITIVE_DATA; ++DataIndex)
	{
		PrimitiveData.CustomPrimitiveData[DataIndex] = Primitive.CustomPrimitiveData[DataIndex];
	}
	return PrimitiveData;
}

#if VF_USE_PRIMITIVE_SCENE_DATA

#if USE_GLOBAL_GPU_SCENE_DATA
StructuredBuffer<float4> GPUScenePrimitiveSceneData;
#elif USE_GLOBAL_GPU_SCENE_DATA_RW
RWStructuredBuffer<float4> GPUScenePrimitiveSceneDataRW;
#endif

// Stride of a single primitive's data in float4's, must match C++
#define PRIMITIVE_SCENE_DATA_STRIDE 37

float4 LoadPrimitivePrimitiveSceneDataElement(uint PrimitiveIndex, uint ItemIndex)
{
	uint TargetIdx = PrimitiveIndex + ItemIndex;

#if USE_GLOBAL_GPU_SCENE_DATA
	checkStructuredBufferAccessSlow(GPUScenePrimitiveSceneData, TargetIdx);
	return GPUScenePrimitiveSceneData[TargetIdx];
#elif USE_GLOBAL_GPU_SCENE_DATA_RW
	checkStructuredBufferAccessSlow(GPUScenePrimitiveSceneDataRW, TargetIdx);
	return GPUScenePrimitiveSceneDataRW[TargetIdx];
#else
	checkStructuredBufferAccessSlow(View.PrimitiveSceneData, TargetIdx);
	return View.PrimitiveSceneData[TargetIdx];
#endif
}

// Fetch from scene primitive buffer
FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)
{
#if (FEATURE_LEVEL == FEATURE_LEVEL_ES3_1 && VERTEXSHADER)
	// Vertex shaders do not have access to GPUScene on mobile. Use GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
	// TODO: need a way to report invalid usage, after all dead code elimination
	return (FPrimitiveSceneData)0;
#else
	FPrimitiveSceneData PrimitiveData = (FPrimitiveSceneData)0;
	// Note: layout must match FPrimitiveSceneShaderData in C++
	// Relying on optimizer to remove unused loads
	uint PrimitiveIndex = PrimitiveId * PRIMITIVE_SCENE_DATA_STRIDE;
	
	float3 TilePosition = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 1).xyz;

	float4x4 LocalToWorld;
	LocalToWorld[0] = float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 2).xyz, 0.0f);
	LocalToWorld[1] = float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 3).xyz, 0.0f);
	LocalToWorld[2] = float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 4).xyz, 0.0f);
	LocalToWorld[3] = float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 5).xyz, 1.0f);

	float4x4 PreviousLocalToWorld;
	PreviousLocalToWorld[0]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 10).xyz, 0.0f);
	PreviousLocalToWorld[1]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 11).xyz, 0.0f);
	PreviousLocalToWorld[2]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 12).xyz, 0.0f);
	PreviousLocalToWorld[3]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 13).xyz, 1.0f);

	float4x4 WorldToLocal;
	WorldToLocal[0]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 6).xyz, 0.0f);
	WorldToLocal[1]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 7).xyz, 0.0f);
	WorldToLocal[2]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 8).xyz, 0.0f);
	WorldToLocal[3]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 9).xyz, 1.0f);

	float4x4 PreviousWorldToLocal;
	PreviousWorldToLocal[0]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 14).xyz, 0.0f);
	PreviousWorldToLocal[1]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 15).xyz, 0.0f);
	PreviousWorldToLocal[2]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 16).xyz, 0.0f);
	PreviousWorldToLocal[3]	= float4(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 17).xyz, 1.0f);

	float4 ObjectWorldPositionAndRadius	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 19);

	PrimitiveData.Flags							= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).x);
	PrimitiveData.InstanceSceneDataOffset		= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).y);
	PrimitiveData.NumInstanceSceneDataEntries	= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).z);
	PrimitiveData.SingleCaptureIndex			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).w);
	PrimitiveData.TilePosition					= TilePosition;
	PrimitiveData.LocalToWorld					= MakeLWCMatrix4x3(TilePosition, LocalToWorld);
	PrimitiveData.WorldToLocal					= MakeLWCInverseMatrix4x3(TilePosition, WorldToLocal);
	PrimitiveData.PreviousLocalToWorld			= MakeLWCMatrix4x3(TilePosition, PreviousLocalToWorld);
	PrimitiveData.PreviousWorldToLocal			= MakeLWCInverseMatrix4x3(TilePosition, PreviousWorldToLocal);
	PrimitiveData.InvNonUniformScale			= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 18).xyz;
	PrimitiveData.ObjectBoundsX					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 18).w;
	PrimitiveData.ObjectWorldPosition			= MakeLWCVector3(TilePosition, ObjectWorldPositionAndRadius.xyz);
	PrimitiveData.ObjectRadius					= ObjectWorldPositionAndRadius.w;
	PrimitiveData.ActorWorldPosition			= MakeLWCVector3(TilePosition, LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20).xyz);
	PrimitiveData.LightmapUVIndex				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20).w);
	PrimitiveData.ObjectOrientation				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21).xyz;
	PrimitiveData.LightmapDataIndex				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21).w);
	PrimitiveData.NonUniformScale				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 22);
	PrimitiveData.PreSkinnedLocalBoundsMin		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 23).xyz;
	PrimitiveData.NaniteResourceID				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 23).w);
	PrimitiveData.PreSkinnedLocalBoundsMax		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).xyz;
	PrimitiveData.NaniteHierarchyOffset			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).w);
	PrimitiveData.LocalObjectBoundsMin			= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).xyz;
	PrimitiveData.ObjectBoundsY					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).w;
	PrimitiveData.LocalObjectBoundsMax			= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).xyz;
	PrimitiveData.ObjectBoundsZ					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).w;
	PrimitiveData.InstanceLocalBoundsCenter		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).xyz;
	PrimitiveData.InstancePayloadDataOffset		= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).w);
	PrimitiveData.InstanceLocalBoundsExtent		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).xyz;
	PrimitiveData.InstancePayloadDataStride		= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).w);

	// TODO: Move to associated array to shrink primitive data and better pack cachelines
	UNROLL
	for (int DataIndex = 0; DataIndex < NUM_CUSTOM_PRIMITIVE_DATA; ++DataIndex)
	{
		PrimitiveData.CustomPrimitiveData[DataIndex] = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex,  29 + DataIndex);
	}
	return PrimitiveData;
#endif
}

#else // !VF_USE_PRIMITIVE_SCENE_DATA

FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)
{
	return GetPrimitiveDataFromUniformBuffer();
}

#endif // VF_USE_PRIMITIVE_SCENE_DATA

float GetPrimitive_DeterminantSign_FromFlags(uint Flags)
{
	return CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_DETERMINANT_SIGN, -1.0f, 1.0f);
}

float GetPrimitive_DeterminantSign(uint PrimitiveId)
{
	return GetPrimitive_DeterminantSign_FromFlags(GetPrimitiveData(PrimitiveId).Flags);
}

#if VF_USE_PRIMITIVE_SCENE_DATA
float GetPrimitive_DeterminantSign(FPrimitiveSceneData Primitive)
{
	return GetPrimitive_DeterminantSign_FromFlags(Primitive.Flags);
}
#endif

float GetPrimitive_PerObjectGBufferData_FromFlags(uint Flags)
{
	const float CapsuleRepresentation = CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_HAS_CAPSULE_REPRESENTATION, 1.0f, 0.0f);
	const float CastContactShadow     = CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_HAS_CAST_CONTACT_SHADOW,    1.0f, 0.0f);
	return (2.0f * CapsuleRepresentation + CastContactShadow) / 3.0f;
}

float GetPrimitive_PerObjectGBufferData(uint PrimitiveId)
{
	return GetPrimitive_PerObjectGBufferData_FromFlags(GetPrimitiveData(PrimitiveId).Flags);
}

#if VF_USE_PRIMITIVE_SCENE_DATA
float GetPrimitive_PerObjectGBufferData(FPrimitiveSceneData Primitive)
{
	return GetPrimitive_PerObjectGBufferData_FromFlags(Primitive.Flags);
}
#endif

uint GetPrimitive_LightingChannelMask_FromFlags(uint Flags)
{
	const uint Channel0 = CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_0, 1u, 0u);
	const uint Channel1 = CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_1, 1u, 0u);
	const uint Channel2 = CondMask(Flags & PRIMITIVE_SCENE_DATA_FLAG_LIGHTING_CHANNEL_2, 1u, 0u);
	return (Channel0 | (Channel1 << 1u) | (Channel2 << 2u));
}

uint GetPrimitive_LightingChannelMask(uint PrimitiveId)
{
	return GetPrimitive_LightingChannelMask_FromFlags(GetPrimitiveData(PrimitiveId).Flags);
}

#if VF_USE_PRIMITIVE_SCENE_DATA
uint GetPrimitive_LightingChannelMask(FPrimitiveSceneData Primitive)
{
	return GetPrimitive_LightingChannelMask_FromFlags(Primitive.Flags);
}
#endif

// Unpacked AoS layout - see FInstanceSceneShaderData::Setup() for SoA packed layout.
struct FInstanceSceneData
{
	FLWCMatrix LocalToWorld;
	FLWCMatrix PrevLocalToWorld;
	FLWCInverseMatrix WorldToLocal;
	float4   NonUniformScale;
	float3   InvNonUniformScale;
	float    DeterminantSign;
	float3   LocalBoundsCenter;
	uint     PrimitiveId;
	uint     RelativeId;
	uint     PayloadDataOffset; // TODO: Implement payload data
	float3   LocalBoundsExtent;
	uint     LastUpdateSceneFrameNumber;
	uint     NaniteRuntimeResourceID;
	uint     NaniteHierarchyOffset;
#if USES_PER_INSTANCE_RANDOM
	float    RandomID;
#endif
#if USES_PER_INSTANCE_CUSTOM_DATA
	float    CustomDataFloat0;
	uint     CustomDataOffset;
	uint     NumCustomDataFloats;
#endif
#if 1 //NEEDS_LIGHTMAP_COORDINATE
	float4   LightMapAndShadowMapUVBias;
#endif
	bool     ValidInstance;
	bool     HasRandomID;
	bool     HasCustomData;
	bool     HasDynamicData;
	bool     HasLightShadowUVBias;
	uint     Flags;
};

#if USE_GLOBAL_GPU_SCENE_DATA
StructuredBuffer<float4> GPUSceneInstanceSceneData;
StructuredBuffer<float4> GPUSceneInstancePayloadData;
uint GPUSceneFrameNumber;
#elif USE_GLOBAL_GPU_SCENE_DATA_RW
RWStructuredBuffer<float4> GPUSceneInstanceSceneDataRW;
RWStructuredBuffer<float4> GPUSceneInstancePayloadDataRW;
uint GPUSceneFrameNumber;
#endif

uint GetGPUSceneFrameNumber()
{
#if USE_GLOBAL_GPU_SCENE_DATA
	return GPUSceneFrameNumber;
#else
	return View.FrameNumber;
#endif
}

float4 LoadInstanceSceneDataElement(uint Index)
{
#if USE_GLOBAL_GPU_SCENE_DATA
	return GPUSceneInstanceSceneData[Index];
#elif USE_GLOBAL_GPU_SCENE_DATA_RW
	return GPUSceneInstanceSceneDataRW[Index];
#else
	return View.InstanceSceneData[Index];
#endif
}

float4 LoadInstancePayloadDataElement(uint Index)
{
#if USE_GLOBAL_GPU_SCENE_DATA
	return GPUSceneInstancePayloadData[Index];
#elif USE_GLOBAL_GPU_SCENE_DATA_RW
	return GPUSceneInstancePayloadDataRW[Index];
#else
	return View.InstancePayloadData[Index];
#endif
}

// [Frisvad 2012, "Building an Orthonormal Basis from a 3D Unit Vector Without Normalization"]
void GetHemiOrthoBasis( inout float3 BasisX, inout float3 BasisY, float3 BasisZ )
{
	float A = 1.0f / ( 1.0f + BasisZ.z );
	float B = -BasisZ.x * BasisZ.y * A;
	BasisX = float3( 1.0f - BasisZ.x * BasisZ.x * A, B, -BasisZ.x );
	BasisY = float3( B, 1.0f - BasisZ.y * BasisZ.y * A, -BasisZ.y );
}

float4x4 DecodeTransform( uint4 RotationScale, float3 Translation, inout float3 Scale )
{
	float4x4 M = 0.0;
	M[3].xyz = Translation;
	M[3].w = 1.0;

	// Rotation
	{
		float3 Rotation =
		{
			( RotationScale[0] >>  0 ) & 0xffff,
			( RotationScale[0] >> 16 ) & 0xffff,
			( RotationScale[1] >>  0 ) & 0x7fff
		};

		float2 OctZ  = ( Rotation.xy - 32768 ) * (1.0f / 32767.0f);
		float Spin0  = ( Rotation.z  - 16384 ) * (0.70710678f / 16383.0f);	// rsqrt(2)
		bool bSpinIsX = RotationScale[1] & 0x8000;

		M[2].xyz = HemiOctahedronToUnitVector( OctZ );

		float3 BasisX, BasisY;
		GetHemiOrthoBasis( BasisX, BasisY, M[2].xyz );

		float Spin1 = sqrt( 1.0f - Spin0 * Spin0 );
		float X = bSpinIsX ? Spin0 : Spin1;
		float Y = bSpinIsX ? Spin1 : Spin0;

		M[0].xyz = BasisX * X + BasisY * Y;
		M[1].xyz = cross( M[2].xyz, M[0].xyz );
	}

	// Scale
	{
		const uint SignMantissaBits	= 16;
		const uint SignMantissaMask	= (1u << SignMantissaBits) - 1;
		const uint MantissaBits		= SignMantissaBits - 1;

#if 0
		uint SharedExp = RotationScale[3] >> 22;

		float ExpScale = asfloat( ( SharedExp - MantissaBits ) << 23 );

		int3 Mantissa =
		{
			( RotationScale[2] >> 0 ),
			( RotationScale[2] >> 18 ) | ( RotationScale[3] << 14 ),
			( RotationScale[3] >> 4 )
		};
#else
		uint SharedExp = RotationScale[3] >> 16;

		float ExpScale = asfloat( ( SharedExp - MantissaBits ) << 23 );

		uint3 Mantissa =
		{
			RotationScale[2] >> 0,
			RotationScale[2] >> 16,
			RotationScale[3] >> 0
		};
		
#endif
		Mantissa &= SignMantissaMask;
		Scale = Mantissa;
		Scale -= 1u << MantissaBits;
		Scale *= ExpScale;

		M[0] *= Scale[0];
		M[1] *= Scale[1];
		M[2] *= Scale[2];
	}

	return M;
}

void ComputeInstanceDerivedData(inout FInstanceSceneData InstanceData, float3 TilePosition, float4x4 LocalToRelativeWorld)
{
	//
	// Do not put any load operations here!
	//

#if !INSTANCE_COMPRESSED_TRANSFORM
	float3 Scale2;
	Scale2.x = length2(LocalToRelativeWorld[0].xyz);
	Scale2.y = length2(LocalToRelativeWorld[1].xyz);
	Scale2.z = length2(LocalToRelativeWorld[2].xyz);

	InstanceData.InvNonUniformScale							= rsqrt(Scale2);
	InstanceData.DeterminantSign							= CondMask(InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_DETERMINANT_SIGN, -1.0f, 1.0f);
	InstanceData.NonUniformScale.xyz						= Scale2 * InstanceData.InvNonUniformScale;
#endif

	InstanceData.NonUniformScale.w							= max3( InstanceData.NonUniformScale.x, InstanceData.NonUniformScale.y, InstanceData.NonUniformScale.z );

	float4x4 RelativeWorldToLocal							= LocalToRelativeWorld;
	RelativeWorldToLocal[0].xyz							   *= Pow2(InstanceData.InvNonUniformScale.x);
	RelativeWorldToLocal[1].xyz					           *= Pow2(InstanceData.InvNonUniformScale.y);
	RelativeWorldToLocal[2].xyz					           *= Pow2(InstanceData.InvNonUniformScale.z);
	RelativeWorldToLocal[3].xyz						        = 0.0f;
	RelativeWorldToLocal								    = transpose(RelativeWorldToLocal);
	RelativeWorldToLocal[3].xyz						        = mul(float4(-LocalToRelativeWorld[3].xyz, 0.0f), RelativeWorldToLocal).xyz;
	InstanceData.WorldToLocal								= MakeLWCInverseMatrix(TilePosition, RelativeWorldToLocal);

	InstanceData.HasRandomID								= (InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_RANDOM);
	InstanceData.HasCustomData								= (InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_CUSTOM_DATA);
	InstanceData.HasDynamicData								= (InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_DYNAMIC_DATA);
	InstanceData.HasLightShadowUVBias						= (InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_LIGHTSHADOW_UV_BIAS);
}

// Fetch from scene primitive buffer
FInstanceSceneData GetInstanceSceneData(uint InstanceId, uint SOAStride, bool bCheckValid = true)
{
	FInstanceSceneData InstanceData = (FInstanceSceneData)0;

	//
	// NOTE: When changing the packed data layout, ensure that GPUScene/GPUSceneWriter.ush is kept in sync!
	//       Also, please update the GetInstanceSceneData function in GPUScene.cpp for validation purposes.
	//

	// Only process valid instances
	// Note: keep primitive ID packing in sync with GPUSceneWriter.ush
	const uint FlagsAndPrimitiveId	= asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).x);
	InstanceData.PrimitiveId		= BitFieldExtractU32(FlagsAndPrimitiveId,  20, 0);  // Max of 1,048,576 primitives
	InstanceData.Flags				= BitFieldExtractU32(FlagsAndPrimitiveId,  12, 20); // Max of 12 instance flags
	InstanceData.ValidInstance		= InstanceData.PrimitiveId != INVALID_PRIMITIVE_ID;

	BRANCH
	if (!bCheckValid || InstanceData.ValidInstance)
	{
		const uint RelativeIdAndCustomDataCount					= asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).y);
		InstanceData.RelativeId									= BitFieldExtractU32(RelativeIdAndCustomDataCount, 24, 0); // Max of 16,777,216 instances per primitive
		InstanceData.NaniteHierarchyOffset						= asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).z);
		InstanceData.LastUpdateSceneFrameNumber					= asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).w);
		
		float3 TilePosition = GetPrimitiveData(InstanceData.PrimitiveId).TilePosition;
#if !INSTANCE_COMPRESSED_TRANSFORM
		float4x4 LocalToRelativeWorld							= transpose(float4x4(LoadInstanceSceneDataElement(1 * SOAStride + InstanceId),
																					 LoadInstanceSceneDataElement(2 * SOAStride + InstanceId),
																	                 LoadInstanceSceneDataElement(3 * SOAStride + InstanceId),
																	                 float4(0.0f, 0.0f, 0.0f, 1.0f)));

		float4x4 PrevLocalToRelativeWorld						= transpose(float4x4(LoadInstanceSceneDataElement(4 * SOAStride + InstanceId),
																	                 LoadInstanceSceneDataElement(5 * SOAStride + InstanceId),
																	                 LoadInstanceSceneDataElement(6 * SOAStride + InstanceId),
																	                 float4(0.0f, 0.0f, 0.0f, 1.0f)));

		BRANCH
		if ((InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_LOCAL_BOUNDS) != 0u)
		{
			InstanceData.LocalBoundsCenter							= LoadInstanceSceneDataElement(7 * SOAStride + InstanceId).xyz;
			InstanceData.LocalBoundsExtent.x						= LoadInstanceSceneDataElement(7 * SOAStride + InstanceId).w;
			InstanceData.LocalBoundsExtent.yz						= LoadInstanceSceneDataElement(8 * SOAStride + InstanceId).xy;
		}
		else
		{
			InstanceData.LocalBoundsCenter							= GetPrimitiveData(InstanceData.PrimitiveId).InstanceLocalBoundsCenter;
			InstanceData.LocalBoundsExtent							= GetPrimitiveData(InstanceData.PrimitiveId).InstanceLocalBoundsExtent;
		}

		InstanceData.PayloadDataOffset							= asuint(LoadInstanceSceneDataElement(8 * SOAStride + InstanceId).z);

	#if USES_PER_INSTANCE_RANDOM
		InstanceData.RandomID									= LoadInstanceSceneDataElement(8 * SOAStride + InstanceId).w;
	#endif

	#if 1 //NEEDS_LIGHTMAP_COORDINATE
		InstanceData.LightMapAndShadowMapUVBias					= LoadInstanceSceneDataElement(9 * SOAStride + InstanceId);
	#endif

#else
		uint4  RotationScale									= asuint(LoadInstanceSceneDataElement(1 * SOAStride + InstanceId));
		float3 Translation										= LoadInstanceSceneDataElement(2 * SOAStride + InstanceId).xyz;
		float3 Scale = 0;
		float4x4 LocalToRelativeWorld = DecodeTransform( RotationScale, Translation, Scale );

		uint4  PrevRotationScale								= asuint(LoadInstanceSceneDataElement(3 * SOAStride + InstanceId));
		float3 PrevTranslation									= LoadInstanceSceneDataElement(4 * SOAStride + InstanceId).xyz;
		float3 PrevScale = 0;
		float4x4 PrevLocalToRelativeWorld = DecodeTransform( PrevRotationScale, PrevTranslation, PrevScale );

		BRANCH
		if ((InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_LOCAL_BOUNDS) != 0u)
		{
			InstanceData.LocalBoundsCenter							= LoadInstanceSceneDataElement(5 * SOAStride + InstanceId).xyz;
			InstanceData.LocalBoundsExtent.x						= LoadInstanceSceneDataElement(5 * SOAStride + InstanceId).w;
			InstanceData.LocalBoundsExtent.yz						= LoadInstanceSceneDataElement(6 * SOAStride + InstanceId).xy;
		}
		else
		{
			InstanceData.LocalBoundsCenter							= GetPrimitiveData(InstanceData.PrimitiveId).InstanceLocalBoundsCenter;
			InstanceData.LocalBoundsExtent							= GetPrimitiveData(InstanceData.PrimitiveId).InstanceLocalBoundsExtent;
		}

		InstanceData.PayloadDataOffset							= asuint(LoadInstanceSceneDataElement(6 * SOAStride + InstanceId).z);

	#if USES_PER_INSTANCE_RANDOM
		InstanceData.RandomID									= LoadInstanceSceneDataElement(6 * SOAStride + InstanceId).w;
	#endif

	#if NEEDS_LIGHTMAP_COORDINATE
		InstanceData.LightMapAndShadowMapUVBias					= LoadInstanceSceneDataElement(7 * SOAStride + InstanceId);
	#endif

		InstanceData.NonUniformScale.xyz						= abs( Scale );
		InstanceData.InvNonUniformScale							= rcp( InstanceData.NonUniformScale.xyz );
		InstanceData.DeterminantSign							= CondMask(InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_DETERMINANT_SIGN, -1.0f, 1.0f);	// Scale.x * Scale.y * Scale.z < 0.0 ? -1.0 : 1.0;
#endif

		InstanceData.LocalToWorld								= MakeLWCMatrix(TilePosition, LocalToRelativeWorld);
		InstanceData.PrevLocalToWorld							= MakeLWCMatrix(TilePosition, PrevLocalToRelativeWorld);		

		ComputeInstanceDerivedData(InstanceData, TilePosition, LocalToRelativeWorld);

		// TODO: Temporary hack!
	#if USES_PER_INSTANCE_CUSTOM_DATA
		// Payload data offset it not used yet, so temporarily repurpose it for a single float of custom instance data..
		InstanceData.CustomDataFloat0 = CondMask(InstanceData.HasCustomData, asfloat(InstanceData.PayloadDataOffset), 0.0f);
		InstanceData.CustomDataOffset = CondMask(InstanceData.HasCustomData, 0u, 0xFFFFFFFF);
		InstanceData.NumCustomDataFloats = CondMask(InstanceData.HasCustomData, 1u, 0u);
	#endif

		// TODO: Only do this for primitive types that require per instance hierarchy offsets (i.e. geometry collections)
		InstanceData.NaniteRuntimeResourceID = GetPrimitiveData(InstanceData.PrimitiveId).NaniteResourceID;
		if (InstanceData.NaniteRuntimeResourceID != 0xFFFFFFFFu)
		{
			// Combine this instance's hierarchy offset with the primitive's root hierarchy offset
			InstanceData.NaniteHierarchyOffset += GetPrimitiveData(InstanceData.PrimitiveId).NaniteHierarchyOffset;
		}
	}

	return InstanceData;
}

struct FSceneDataIntermediates
{
	uint PrimitiveId;
	uint InstanceId;
	uint ViewIndex;
	// Index from which we load the instance info, needed for the 
	uint InstanceIdLoadIndex;
	FInstanceSceneData InstanceData;
	FPrimitiveSceneData Primitive;
};

/**
 * Load scene data once given the inputs require.
 * InstanceIdOffset - supplied as a vertex stream with 0 instance step rate (constant for all instances)
 * DrawInstanceId - the instance ID (SV_InstanceID) in the current draw
 */
#if (VF_USE_PRIMITIVE_SCENE_DATA == 1)
FSceneDataIntermediates GetSceneDataIntermediates(uint InstanceIdOffset, uint DrawInstanceId)
{
	FSceneDataIntermediates Intermediates = (FSceneDataIntermediates)0;

	Intermediates.InstanceIdLoadIndex = InstanceIdOffset + DrawInstanceId;
	// GPUCULL_TODO: workaround for the fact that DrawDynamicMeshPassPrivate et al. don't work with GPU-Scene instancing
	//				 instead they mark the top bit in the primitive ID and disable auto instancing such that there is an 1:1:1
	//               drawcmd:primitive:instance. Then we can just look up the primitive and fetch the instance data index.
	// GPUCULL_TODO: Workaround also used for ray tracing interfacing with the VFs, that also supply a DrawInstanceId. 
	// We mark the PrimitiveID with the top bit in dynamic draw passes
	if ((InstanceIdOffset & VF_TREAT_INSTANCE_ID_OFFSET_AS_PRIMITIVE_ID_FLAG) != 0U)
	{
		// mask off the flag
		uint PrimitiveID = InstanceIdOffset & (VF_TREAT_INSTANCE_ID_OFFSET_AS_PRIMITIVE_ID_FLAG - 1U);
		Intermediates.InstanceId = GetPrimitiveData(PrimitiveID).InstanceSceneDataOffset + DrawInstanceId;
		Intermediates.ViewIndex = 0;
	}
	else
	{
		Intermediates.InstanceId = InstanceCulling.InstanceIdsBuffer[InstanceIdOffset + DrawInstanceId] & ((1U << 28U) - 1);
		// We store the view index (which can be used for instanced stereo or other multi-view in the top four bits of the instance ID)
		// Note: this is an index of views for this render pass, not the view ID in the culling manager.
		Intermediates.ViewIndex = InstanceCulling.InstanceIdsBuffer[InstanceIdOffset + DrawInstanceId] >> 28U;
	}

	Intermediates.InstanceData = GetInstanceSceneData(Intermediates.InstanceId, View.InstanceSceneDataSOAStride);
	Intermediates.PrimitiveId = Intermediates.InstanceData.PrimitiveId;
	Intermediates.Primitive = GetPrimitiveData(Intermediates.PrimitiveId);

	return Intermediates;
}
#elif (VF_USE_PRIMITIVE_SCENE_DATA == 2)
// Must match PackLocalBoundsCenter and PackLocalBoundsExtent
float3 UnpackLocalBoundsCenter(float2 PackedCenter)
{
	float3 Result = 0;
	// uses 21 bits for each component, rounded to a 1 unit
	const uint SPLIT_MASK = (1u << 11u) - 1u;
	const float CenterBias = (1u << 20u) - 1u;
	uint p0 = asuint(PackedCenter.x);
	uint p1 = asuint(PackedCenter.y);
	Result.x = float(p0 >> 11u) - CenterBias;
	Result.y = float(p1 >> 11u) - CenterBias;
	Result.z = float((p0 & SPLIT_MASK) | ((p1 & SPLIT_MASK) << 11u)) - CenterBias;
	return Result;
}
float3 UnpackLocalBoundsExtent(float2 PackedExtent)
{
	float3 Result = 0;
	// uses 21 bits for each component, rounded to a 1 unit
	const uint SPLIT_MASK = (1u << 11u) - 1u;
	uint p0 = asuint(PackedExtent.x);
	uint p1 = asuint(PackedExtent.y);
	Result.x = float(p0 >> 11u);
	Result.y = float(p1 >> 11u);
	Result.z = float((p0 & SPLIT_MASK) | ((p1 & SPLIT_MASK) << 11u));
	return Result;
}

FSceneDataIntermediates GetSceneDataIntermediates(uint DrawInstanceId, float4 InstanceOrigin, float4 InstanceTransform1, float4 InstanceTransform2, float4 InstanceTransform3, float4 InstanceAuxData)
{
	// Not all mobile devices can access storage buffers from a vertex shaders
	// we supply some of primtive data using per-instance vertex data, and rest of primitive data comes from Primitive UB
	// If vertex shader uses any of Primitive UB data associated drawcalls will not auto-instance
	FPrimitiveSceneData Primitive = GetPrimitiveDataFromUniformBuffer();
	
	// TODO: add support for LWC, we should pack it as integer tile coordinates 
	float3 TilePosition = float3(0,0,0);

	// TODO: pack important primitive and instance flags here
	const uint PrimitiveFlags = asuint(InstanceTransform1.w);
	const uint InstanceFlags = (PrimitiveFlags >> 16);

	// Reconstruct InstanceData from a packed data
	FInstanceSceneData InstanceData = (FInstanceSceneData)0;

	float4x4 LocalToRelativeWorld = float4x4(
		float4(InstanceTransform1.xyz, 0.0f), 
		float4(InstanceTransform2.xyz, 0.0f), 
		float4(InstanceTransform3.xyz, 0.0f), 
		float4(InstanceOrigin.xyz, 1.0f));
	
	InstanceData.LocalToWorld = MakeLWCMatrix(TilePosition, LocalToRelativeWorld);

	InstanceData.Flags = InstanceFlags;
	InstanceData.PrimitiveId = asuint(InstanceOrigin.w);
	
#if USES_PER_INSTANCE_RANDOM
	InstanceData.RandomID = InstanceTransform3.w;
#endif

#if INSTANCE_COMPRESSED_TRANSFORM
	#error Compressed instance transform is not supported on mobile path
#endif

	ComputeInstanceDerivedData(InstanceData, TilePosition, LocalToRelativeWorld);

	//
	FSceneDataIntermediates Intermediates = (FSceneDataIntermediates)0;
	Intermediates.InstanceData = InstanceData;
	Intermediates.PrimitiveId = InstanceData.PrimitiveId;
	Intermediates.InstanceId = 0;
	Intermediates.ViewIndex = 0;
	Intermediates.InstanceIdLoadIndex = 0;

	Intermediates.Primitive = Primitive;
	// Primitive data that comes from per-instance vertex data
	Intermediates.Primitive.Flags					= PrimitiveFlags;
	Intermediates.Primitive.LocalToWorld			= Intermediates.InstanceData.LocalToWorld;
	Intermediates.Primitive.InvNonUniformScale		= Intermediates.InstanceData.InvNonUniformScale;
	Intermediates.Primitive.WorldToLocal			= Intermediates.InstanceData.WorldToLocal;
	Intermediates.Primitive.NonUniformScale			= Intermediates.InstanceData.NonUniformScale;

#if ALLOW_STATIC_LIGHTING 
	Intermediates.Primitive.LightmapDataIndex = asuint(InstanceTransform2.w);
	InstanceData.LightMapAndShadowMapUVBias = float4(
		UnpackSnorm2x16(asuint(InstanceAuxData.y)), 
		UnpackSnorm2x16(asuint(InstanceAuxData.w)));
#else
	InstanceData.LocalBoundsCenter = UnpackLocalBoundsCenter(InstanceAuxData.xy);
	InstanceData.LocalBoundsExtent = UnpackLocalBoundsExtent(InstanceAuxData.zw);
	Intermediates.Primitive.LocalObjectBoundsMin = InstanceData.LocalBoundsCenter - InstanceData.LocalBoundsExtent; 
	Intermediates.Primitive.LocalObjectBoundsMax = InstanceData.LocalBoundsCenter + InstanceData.LocalBoundsExtent; 

	float3 ObjectRelativeWorldPosition = mul(float4(InstanceData.LocalBoundsCenter.xyz, 0.0f), LocalToRelativeWorld).xyz;
	Intermediates.Primitive.ObjectWorldPosition = MakeLWCVector3(TilePosition, ObjectRelativeWorldPosition);
	Intermediates.Primitive.ObjectRadius = length(InstanceData.LocalBoundsExtent * InstanceData.NonUniformScale.xyz);
#endif
	
	return Intermediates; 
}
#else
FSceneDataIntermediates GetSceneDataIntermediates()
{
	FSceneDataIntermediates Intermediates = (FSceneDataIntermediates)0;
	// Populate from Primitive uniform buffer
	Intermediates.ViewIndex = 0U;
	Intermediates.PrimitiveId = 0U;
	Intermediates.InstanceId = 0U;
	Intermediates.Primitive = GetPrimitiveDataFromUniformBuffer();
	// Populate instance data from primitive data
	Intermediates.InstanceData.LocalToWorld			= Intermediates.Primitive.LocalToWorld;
	Intermediates.InstanceData.PrevLocalToWorld		= Intermediates.Primitive.PreviousLocalToWorld;
	Intermediates.InstanceData.WorldToLocal			= Intermediates.Primitive.WorldToLocal;
	Intermediates.InstanceData.NonUniformScale		= Intermediates.Primitive.NonUniformScale;
	Intermediates.InstanceData.InvNonUniformScale	= Intermediates.Primitive.InvNonUniformScale;
	Intermediates.InstanceData.DeterminantSign		= GetPrimitive_DeterminantSign_FromFlags(Intermediates.Primitive.Flags);
	Intermediates.InstanceData.LocalBoundsCenter	= (Intermediates.Primitive.LocalObjectBoundsMax + Intermediates.Primitive.LocalObjectBoundsMin) * 0.5f;
	Intermediates.InstanceData.LocalBoundsExtent	= (Intermediates.Primitive.LocalObjectBoundsMax - Intermediates.Primitive.LocalObjectBoundsMin) * 0.5f;
	Intermediates.InstanceData.ValidInstance		= true;
	
	return Intermediates;
}
#endif //VF_USE_PRIMITIVE_SCENE_DATA
