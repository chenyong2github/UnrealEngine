// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#ifndef PLATFORM_SUPPORTS_INLINE_RAY_TRACING
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING 0
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING

#if PLATFORM_SUPPORTS_INLINE_RAY_TRACING

#if !COMPUTESHADER
#error Inline ray tracing is only supported in compute shaders
#endif // !COMPUTESHADER

#ifndef ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
#	define ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE 0
#endif // ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE

#ifndef ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
#	define ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS 0
#endif // ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS

#if ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
#include "../Nanite/NaniteRayTrace.ush"
#endif

#if OVERRIDE_TRACERAYINLINE_USH
#include "/Platform/Private/TraceRayInline.ush"

#else // OVERRIDE_TRACERAYINLINE_USH

#include "/Engine/Private/RayTracing/TraceRayInlineCommon.ush"

#if COMPILER_VULKAN
#include "/Engine/Private/RayTracing/TraceRayInlineVulkan.ush"
#endif // COMPILER_VULKAN

#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_NORMALS 0
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS 0
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX 1

FTraceRayInlineResult TraceRayInline(RaytracingAccelerationStructure AccelerationStructure,
	uint RayFlags,
	uint InstanceInclusionMask,
	RayDesc Ray,
	FTraceRayInlineContext TraceRayInlineContext)
{
	FTraceRayInlineResult TraceRayResult = (FTraceRayInlineResult)0;
	TraceRayResult.SetMiss();
	TraceRayResult.bIsCompleted = true;

#if ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
	float2 ProcBarycentrics;
	FTraceRayInlineTraversalStatistics ProcTraversalStatistics = (FTraceRayInlineTraversalStatistics)0;

	RayQuery<RAY_FLAG_FORCE_OPAQUE> RayQ;
#else 
	RayQuery<RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES | RAY_FLAG_FORCE_OPAQUE> RayQ;
#endif // ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE

	RayQ.TraceRayInline(AccelerationStructure, RayFlags, InstanceInclusionMask, Ray);

	while (RayQ.Proceed())
	{
#if ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
		switch (RayQ.CandidateType())
		{
		case CANDIDATE_PROCEDURAL_PRIMITIVE:
		{
			if (TraceRayInlineContext.bProcedural)
			{
				uint PrimitiveID = RayQ.CandidateInstanceID();
				FPrimitiveSceneData PrimitiveData = GetPrimitiveData(PrimitiveID);
				uint PrimitiveInstanceIndex = 0; // TODO
				uint InstanceId = PrimitiveData.InstanceSceneDataOffset + PrimitiveInstanceIndex;
				FInstanceSceneData InstanceData = GetInstanceSceneData(InstanceId, View.InstanceSceneDataSOAStride);

				if (InstanceData.ValidInstance && InstanceData.NaniteRuntimeResourceID != 0xFFFFFFFFu)
				{
					const float3 RayOrg = RayQ.CandidateObjectRayOrigin();
					const float3 RayDir = RayQ.CandidateObjectRayDirection();
					const float TMin = RayQ.RayTMin();
					const float TMax = RayQ.CommittedRayT();

					float IntersectionT = TMax;

					FNaniteIntersectionResult NaniteIntersectionResult;
					if (NaniteIntersection(RayOrg, RayDir, InstanceData, PrimitiveData, TraceRayInlineContext.NaniteCutError, TMin, IntersectionT, NaniteIntersectionResult))
					{
						RayQ.CommitProceduralPrimitiveHit(IntersectionT);
						ProcBarycentrics = NaniteIntersectionResult.Barycentrics;
						ProcTraversalStatistics.NodeIntersectionCount = NaniteIntersectionResult.NodeIntersectionCount;
						ProcTraversalStatistics.ClusterIntersectionCount = NaniteIntersectionResult.ClusterIntersectionCount;
						ProcTraversalStatistics.TriangleIntersectionCount = NaniteIntersectionResult.TriangleIntersectionCount;
					}
				}
			}					
			break;
		}
		}
#endif // ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
	}

	switch (RayQ.CommittedStatus())
	{
	case COMMITTED_TRIANGLE_HIT:
	{
		TraceRayResult.HitT = RayQ.CommittedRayT();
		TraceRayResult.InstanceID = RayQ.CommittedInstanceID();
		TraceRayResult.InstanceIndex = RayQ.CommittedInstanceIndex();
		TraceRayResult.PrimitiveIndex = RayQ.CommittedPrimitiveIndex();
		TraceRayResult.GeometryIndex = RayQ.CommittedGeometryIndex();
		TraceRayResult.Barycentrics = RayQ.CommittedTriangleBarycentrics();
		TraceRayResult.bIsFrontFace = RayQ.CommittedTriangleFrontFace();
		TraceRayResult.InstanceContributionToHitGroupIndex = RayQ.CommittedInstanceContributionToHitGroupIndex();

		// placeholder
		TraceRayResult.WorldGeometryNormal = RayQ.WorldRayDirection();

		TraceRayResult.Bookmark[0] = asuint(TraceRayResult.HitT);
		TraceRayResult.Bookmark[1] = asuint(TraceRayResult.HitT);

#if PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX
		TraceRayResult.ObjectToWorld3x4 = RayQ.CommittedObjectToWorld3x4();
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX

#if ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
		// statistics?
#endif // ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
		break;
	}
#if ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
	case COMMITTED_PROCEDURAL_PRIMITIVE_HIT:
	{
		TraceRayResult.HitT = RayQ.CommittedRayT();
		TraceRayResult.InstanceID = RayQ.CommittedInstanceID();
		TraceRayResult.InstanceIndex = RayQ.CommittedInstanceIndex();
		TraceRayResult.PrimitiveIndex = RayQ.CommittedPrimitiveIndex();
		TraceRayResult.GeometryIndex = RayQ.CommittedGeometryIndex();
		TraceRayResult.Barycentrics = ProcBarycentrics;
		TraceRayResult.bIsFrontFace = true; // TODO
		TraceRayResult.InstanceContributionToHitGroupIndex = RayQ.CommittedInstanceContributionToHitGroupIndex();

		// placeholder
		TraceRayResult.WorldGeometryNormal = RayQ.WorldRayDirection();

		TraceRayResult.Bookmark[0] = asuint(TraceRayResult.HitT);
		TraceRayResult.Bookmark[1] = asuint(TraceRayResult.HitT);

#if PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX
		TraceRayResult.ObjectToWorld3x4 = RayQ.CommittedObjectToWorld3x4();
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX

#if ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
		TraceRayResult.TraversalStatistics = ProcTraversalStatistics;
#endif // ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
		break;
	}
#endif // ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
	}

	return TraceRayResult;
}

#endif // OVERRIDE_TRACERAYINLINE_USH

#ifndef PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_NORMALS
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_NORMALS 0
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_NORMALS

#ifndef PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS 0
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS

#ifndef PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_ATTRIBUTES
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_ATTRIBUTES 0
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_ATTRIBUTES

#ifndef PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX
#define PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX 0
#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX

#ifndef FRayTracingSceneMetadataRecord
// Not used, but must be a valid structure declaration as it may appear in interfaces, resource declarations, etc.
struct FRayTracingSceneMetadataRecord { uint Dummy; };
#endif // FRayTracingSceneMetadataRecord

#endif // PLATFORM_SUPPORTS_INLINE_RAY_TRACING
