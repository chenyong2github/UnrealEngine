// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "LumenOctahedralProbe.ush"
#include "LumenScreenProbeCommon.ush"
#include "../SHCommon.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

RWTexture2D<float3> RWScreenProbeRadiance;
RWTexture2D<float> RWScreenProbeHitDistance;
RWTexture2D<UNORM float> RWScreenProbeTraceMoving;

Texture2D TraceRadiance;
float MaxRayIntensity;

groupshared uint SharedAccumulators[THREADGROUP_SIZE * THREADGROUP_SIZE][6];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeCompositeTracesWithScatterCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0 && SceneDepth < 1000000.0f)
		{
			uint2 ProbeTexelCoord = GroupThreadId.xy;

			if (all(ProbeTexelCoord < ScreenProbeGatherOctahedronResolution))
			{
				uint ThreadIndex = ProbeTexelCoord.y * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord.x;
				SharedAccumulators[ThreadIndex][0] = 0;
				SharedAccumulators[ThreadIndex][1] = 0;
				SharedAccumulators[ThreadIndex][2] = 0;
				SharedAccumulators[ThreadIndex][3] = 0;
				SharedAccumulators[ThreadIndex][4] = 0;
				SharedAccumulators[ThreadIndex][5] = asuint(GetProbeMaxHitDistance());
			}

			GroupMemoryBarrierWithGroupSync();

			uint2 TracingTexelCoord = GroupThreadId.xy;

			if (all(TracingTexelCoord < ScreenProbeTracingOctahedronResolution))
			{
				uint2 TraceCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TracingTexelCoord);

				#if STRUCTURED_IMPORTANCE_SAMPLING
					uint RayInfo = StructuredImportanceSampledRayInfosForTracing[TraceCoord];
					uint2 RayTexelCoord;
					uint RayLevel;
					UnpackRayInfo(RayInfo, RayTexelCoord, RayLevel);

					uint MipSize = MaxImportanceSamplingOctahedronResolution >> RayLevel;
				#else
					uint2 RayTexelCoord = TracingTexelCoord;
					uint MipSize = ScreenProbeTracingOctahedronResolution;
				#endif

				float2 ProbeUV = (RayTexelCoord + float2(.5f, .5f)) / (float)MipSize;

				float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, MipSize);
				float Weight = SolidAngle;

				float3 Lighting = TraceRadiance.Load(int3(TraceCoord, 0)).xyz;
				float MaxLighting = max3(Lighting.x, Lighting.y, Lighting.z);

				if (MaxLighting > MaxRayIntensity)
				{
					Lighting *= MaxRayIntensity / MaxLighting;
				}

				uint2 GatherTexelCoord = RayTexelCoord * ScreenProbeGatherOctahedronResolution / MipSize;
				uint ThreadIndex = GatherTexelCoord.y * ScreenProbeGatherOctahedronResolution + GatherTexelCoord.x;

				if (ScreenProbeGatherOctahedronResolution > ScreenProbeTracingOctahedronResolution)
				{
					// Visual Assert - upsampling not currently supported
					Lighting = float3(0.0f, 0.0f, 10.0f);
				}

				float MaxValuePerThread = (float)0xFFFFFFFF / ((float)ScreenProbeTracingOctahedronResolution * ScreenProbeTracingOctahedronResolution);
				float LightingQuantizeScale = MaxValuePerThread / MaxRayIntensity;
				uint3 QuantizedLighting = Lighting * Weight * LightingQuantizeScale;

				InterlockedAdd(SharedAccumulators[ThreadIndex][0], QuantizedLighting.x);
				InterlockedAdd(SharedAccumulators[ThreadIndex][1], QuantizedLighting.y);
				InterlockedAdd(SharedAccumulators[ThreadIndex][2], QuantizedLighting.z);
				float WeightQuantizeScale = MaxValuePerThread;
				InterlockedAdd(SharedAccumulators[ThreadIndex][3], (uint)(Weight * WeightQuantizeScale));

				bool bHit;
				bool bMoving;
				float HitDistance = DecodeProbeRayDistance(TraceHit.Load(int3(TraceCoord, 0)).x, bHit, bMoving);

				InterlockedAdd(SharedAccumulators[ThreadIndex][4], (uint)((bMoving ? 1 : 0) * Weight * WeightQuantizeScale));
				InterlockedMin(SharedAccumulators[ThreadIndex][5], asuint(HitDistance));
			}

			GroupMemoryBarrierWithGroupSync();

			if (all(ProbeTexelCoord < ScreenProbeGatherOctahedronResolution))
			{
				float InvMaxValuePerThread = ((float)ScreenProbeTracingOctahedronResolution * ScreenProbeTracingOctahedronResolution) / (float)0xFFFFFFFF;
				float InvLightingQuantizeScale = MaxRayIntensity * InvMaxValuePerThread;
				uint ThreadIndex = ProbeTexelCoord.y * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord.x;
				float3 Lighting = float3(SharedAccumulators[ThreadIndex][0], SharedAccumulators[ThreadIndex][1], SharedAccumulators[ThreadIndex][2]) * InvLightingQuantizeScale;
				float InvWeightQuantizeScale = InvMaxValuePerThread;
				float Weight = SharedAccumulators[ThreadIndex][3] * InvWeightQuantizeScale;
				float TexelMoving = SharedAccumulators[ThreadIndex][4] * InvWeightQuantizeScale;
				float MinHitDistance = asfloat(SharedAccumulators[ThreadIndex][5]);

				if (Weight > 0.0f)
				{
					Lighting /= Weight;
					TexelMoving /= Weight;
				}
				else
				{
					MinHitDistance = -1;
				}

				uint2 GatherTexelCoord = ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
				RWScreenProbeRadiance[GatherTexelCoord] = Lighting;
				RWScreenProbeHitDistance[GatherTexelCoord] = EncodeProbeHitDistanceForFiltering(MinHitDistance);
				RWScreenProbeTraceMoving[GatherTexelCoord] = TexelMoving;
			}
		}
	}
}

Texture2D<float3> ScreenProbeRadiance;
Texture2D<float> ScreenProbeHitDistance;

float SpatialFilterMaxRadianceHitAngle;
float SpatialFilterPositionWeightScale;
int SpatialFilterHalfKernelSize;

void GatherNeighborRadiance(
	float2 ScreenUV,
	uint2 ScreenProbeScreenCoord,
	int2 Offset,
	uint2 ProbeTexelCoord,
	float3 WorldPosition,
	float3 WorldConeDirection,
	float InvSceneDepthSq, 
	float HitDistance, 
	inout float3 TotalRadiance, 
	inout float TotalWeight)
{
	int2 NeighborScreenProbeScreenCoord = ScreenProbeScreenCoord + Offset;

	if (all(NeighborScreenProbeScreenCoord >= 0 && NeighborScreenProbeScreenCoord < (int2)ScreenProbeViewSize))
	{
		float NeighborSceneDepth = DownsampledDepth.Load(int3(NeighborScreenProbeScreenCoord, 0)).x;

		if (NeighborSceneDepth > 0.0f)
		{
			float2 NeighborScreenUV = ScreenUV + (float2)Offset * ScreenProbeDownsampleFactor * View.BufferSizeAndInvSize.zw;
			float3 NeighborWorldPosition = GetWorldPositionFromScreenUV(NeighborScreenUV, NeighborSceneDepth);

			float DistanceSq = dot(NeighborWorldPosition - WorldPosition, NeighborWorldPosition - WorldPosition);
			float PositionWeight = saturate(exp2(-DistanceSq * InvSceneDepthSq * SpatialFilterPositionWeightScale));

			if (PositionWeight > 0.0f)
			{
				uint2 NeighborTraceCoord = NeighborScreenProbeScreenCoord * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
				float NeighborRadianceDepth = DecodeProbeHitDistanceForFiltering(ScreenProbeHitDistance.Load(int3(NeighborTraceCoord, 0)).x);

				if (NeighborRadianceDepth >= 0)
				{
					// Clamp neighbor's hit distance to our own.  This helps preserve contact shadows, as a long neighbor hit distance will cause a small NeighborAngle and bias toward distant lighting.
					if (HitDistance >= 0)
					{
						NeighborRadianceDepth = min(NeighborRadianceDepth, HitDistance);
					}
					float3 NeighborHitPosition = NeighborWorldPosition + WorldConeDirection * NeighborRadianceDepth;
					float3 ToNeighborHit = NeighborHitPosition - WorldPosition;
					float NeighborAngle = acosFast(dot(ToNeighborHit, WorldConeDirection) / length(ToNeighborHit));
					float AngleWeight = 1.0f - saturate(NeighborAngle / SpatialFilterMaxRadianceHitAngle);

					float Weight = PositionWeight * AngleWeight;
					TotalRadiance += ScreenProbeRadiance.Load(int3(NeighborTraceCoord, 0)).xyz * Weight;
					TotalWeight += Weight;
				}
			}
		}
	}
}

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void ScreenProbeFilterGatherTracesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / ScreenProbeGatherOctahedronResolution;
	uint2 ProbeTexelCoord = DispatchThreadId.xy - ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolution;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0.0f)
		{
			float InvSceneDepthSq = 1.0f / (SceneDepth * SceneDepth);
			float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / (float)ScreenProbeGatherOctahedronResolution;
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);
			float HitDistance = DecodeProbeHitDistanceForFiltering(ScreenProbeHitDistance.Load(int3(DispatchThreadId.xy, 0)).x);
			float3 TotalRadiance = 0;
			float TotalWeight = 0;

			{
				TotalRadiance = ScreenProbeRadiance.Load(int3(DispatchThreadId.xy, 0)).xyz;
				TotalWeight = 1.0f;
			}
#if 0
			for (int YOffset = -SpatialFilterHalfKernelSize; YOffset <= SpatialFilterHalfKernelSize; YOffset++)
			{
				for (int XOffset = -SpatialFilterHalfKernelSize; XOffset <= SpatialFilterHalfKernelSize; XOffset++)
				{
					int2 Offset = int2(XOffset, YOffset);

					if (any(Offset != int2(0, 0)))
					{
						GatherNeighborRadiance(ScreenUV, ScreenProbeScreenCoord, Offset, ProbeTexelCoord, WorldPosition, WorldConeDirection, InvSceneDepthSq, HitDistance, TotalRadiance, TotalWeight);
					}
				}
			}
#else
			int2 Offsets[4];
			Offsets[0] = int2(-1, 0);
			Offsets[1] = int2(1, 0);
			Offsets[2] = int2(0, -1);
			Offsets[3] = int2(0, 1);

			LOOP
			for (uint OffsetIndex = 0; OffsetIndex < 4; OffsetIndex++)
			{
				GatherNeighborRadiance(ScreenUV, ScreenProbeScreenCoord, Offsets[OffsetIndex], ProbeTexelCoord, WorldPosition, WorldConeDirection, InvSceneDepthSq, HitDistance, TotalRadiance, TotalWeight);
			}
#endif

			if (TotalWeight > 0)
			{
				TotalRadiance /= TotalWeight;
			}

			RWScreenProbeRadiance[DispatchThreadId.xy] = TotalRadiance;
		}
	}
}

RWBuffer<float3> RWScreenProbeRadianceSHAmbient;
RWBuffer<float4> RWScreenProbeRadianceSHDirectional;

#define NUM_LIGHTING_SH_COEFFICIENTS 9
groupshared float SharedSHBasisFunctions[THREADGROUP_SIZE * THREADGROUP_SIZE][NUM_LIGHTING_SH_COEFFICIENTS];
groupshared float SharedLightingRadiance[THREADGROUP_SIZE * THREADGROUP_SIZE][4];
groupshared float SharedSums[NUM_LIGHTING_SH_COEFFICIENTS * 4];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeConvertToSphericalHarmonicCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0 && SceneDepth < 1000000.0f)
		{
			uint ThreadIndex = GroupThreadId.y * ScreenProbeGatherOctahedronResolution + GroupThreadId.x;
			uint2 ProbeTexelCoord = GroupThreadId.xy;

			// Write out (SH3 + Radiance) x 64 to groupshared
			// Read 64 values and accumulate
			// Write out final SH

			if (all(ProbeTexelCoord < ScreenProbeGatherOctahedronResolution))
			{
				float2 ProbeTexelCenter = float2(0.5, 0.5);
				float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / (float)ScreenProbeGatherOctahedronResolution;
				float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

				float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, ScreenProbeGatherOctahedronResolution);
				uint2 ReadIndex = ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
				float3 Radiance = ScreenProbeRadiance.Load(int3(ReadIndex, 0)).xyz;

				FThreeBandSHVector BasisFunction = SHBasisFunction3(WorldConeDirection);
#if WAVE_OPS
				FThreeBandSHVectorRGB LightingSH = MulSH3(BasisFunction, Radiance * SolidAngle);

				float NormalizeWeight = 1.0f / WaveActiveSum(SolidAngle);
				float3 AmbientRGB = float3(WaveActiveSum(float3(LightingSH.R.V0.x, LightingSH.G.V0.x, LightingSH.B.V0.x))) * NormalizeWeight;

				if (ThreadIndex == 0)
				{
					uint WriteIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x);
					RWScreenProbeRadianceSHAmbient[WriteIndex] = AmbientRGB;
				}

				float4 DirectionalSH0[3];
				DirectionalSH0[0] = WaveActiveSum(float4(LightingSH.R.V0.yzw, LightingSH.R.V1.x)) * NormalizeWeight;
				DirectionalSH0[1] = WaveActiveSum(float4(LightingSH.G.V0.yzw, LightingSH.G.V1.x)) * NormalizeWeight;
				DirectionalSH0[2] = WaveActiveSum(float4(LightingSH.B.V0.yzw, LightingSH.B.V1.x)) * NormalizeWeight;

				float4 DirectionalSH1[3];
				DirectionalSH1[0] = WaveActiveSum(float4(LightingSH.R.V1.yzw, LightingSH.R.V2)) * NormalizeWeight;
				DirectionalSH1[1] = WaveActiveSum(float4(LightingSH.G.V1.yzw, LightingSH.G.V2)) * NormalizeWeight;
				DirectionalSH1[2] = WaveActiveSum(float4(LightingSH.B.V1.yzw, LightingSH.B.V2)) * NormalizeWeight;

				if (ThreadIndex < 3)
				{
					float4 ThreadDirectionalSH0 = DirectionalSH0[ThreadIndex];
					float4 ThreadDirectionalSH1 = DirectionalSH1[ThreadIndex];

					#if SH_QUANTIZE_DIRECTIONAL_COEFFICIENTS

						float4 CoefficientNormalizationScale0 = float4(
							0.282095f / 0.488603f,
							0.282095f / 0.488603f,
							0.282095f / 0.488603f,
							0.282095f / 1.092548f);

						float4 CoefficientNormalizationScale1 = float4(
							0.282095f / 1.092548f,
							0.282095f / (4.0f * 0.315392f),
							0.282095f / 1.092548f,
							0.282095f / (2.0f * 0.546274f));

						ThreadDirectionalSH0 = ThreadDirectionalSH0 * CoefficientNormalizationScale0 / max(AmbientRGB[ThreadIndex], .00001f) * .5f + .5f;
						ThreadDirectionalSH1 = ThreadDirectionalSH1 * CoefficientNormalizationScale1 / max(AmbientRGB[ThreadIndex], .00001f) * .5f + .5f;
					#endif

					uint WriteIndex = ((ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * 3 + ThreadIndex) * 2;
					RWScreenProbeRadianceSHDirectional[WriteIndex + 0] = ThreadDirectionalSH0;
					RWScreenProbeRadianceSHDirectional[WriteIndex + 1] = ThreadDirectionalSH1;
				}
#else
				SharedSHBasisFunctions[ThreadIndex][0] = BasisFunction.V0.x;
				SharedSHBasisFunctions[ThreadIndex][1] = BasisFunction.V0.y;
				SharedSHBasisFunctions[ThreadIndex][2] = BasisFunction.V0.z;
				SharedSHBasisFunctions[ThreadIndex][3] = BasisFunction.V0.w;
				SharedSHBasisFunctions[ThreadIndex][4] = BasisFunction.V1.x;
				SharedSHBasisFunctions[ThreadIndex][5] = BasisFunction.V1.y;
				SharedSHBasisFunctions[ThreadIndex][6] = BasisFunction.V1.z;
				SharedSHBasisFunctions[ThreadIndex][7] = BasisFunction.V1.w;
				SharedSHBasisFunctions[ThreadIndex][8] = BasisFunction.V2;
				SharedLightingRadiance[ThreadIndex][0] = Radiance.x * SolidAngle;
				SharedLightingRadiance[ThreadIndex][1] = Radiance.y * SolidAngle;
				SharedLightingRadiance[ThreadIndex][2] = Radiance.z * SolidAngle;
				SharedLightingRadiance[ThreadIndex][3] = SolidAngle;
#endif
			}

#if !WAVE_OPS
			GroupMemoryBarrierWithGroupSync();

			uint NumValuesToSum = ScreenProbeGatherOctahedronResolution * ScreenProbeGatherOctahedronResolution;
			ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

			for (uint SumIndex = ThreadIndex; SumIndex < NUM_LIGHTING_SH_COEFFICIENTS * 4; SumIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
			{
				uint SHCoefficientIndex = SumIndex % NUM_LIGHTING_SH_COEFFICIENTS;
				uint RadianceCoefficientIndex = SumIndex % 4;
				float Sum = 0;

				for (uint SumThreadIndex = 0; SumThreadIndex < NumValuesToSum; SumThreadIndex++)
				{
					float SHCoefficient = (RadianceCoefficientIndex == 3) ? 1.0f : SharedSHBasisFunctions[SumThreadIndex][SHCoefficientIndex];
					Sum += SHCoefficient * SharedLightingRadiance[SumThreadIndex][RadianceCoefficientIndex];
				}

				SharedSums[RadianceCoefficientIndex * NUM_LIGHTING_SH_COEFFICIENTS + SHCoefficientIndex] = Sum;
			}

			GroupMemoryBarrierWithGroupSync();

			float NormalizeWeight = 1.0f / SharedSums[3 * NUM_LIGHTING_SH_COEFFICIENTS];
			float3 AmbientRGB = float3(SharedSums[0 * NUM_LIGHTING_SH_COEFFICIENTS], SharedSums[1 * NUM_LIGHTING_SH_COEFFICIENTS], SharedSums[2 * NUM_LIGHTING_SH_COEFFICIENTS]) * NormalizeWeight;

			if (ThreadIndex == 0)
			{
				uint WriteIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x);
				RWScreenProbeRadianceSHAmbient[WriteIndex] = AmbientRGB;
			}

			if (ThreadIndex < 3)
			{
				float4 DirectionalSH0 = float4(
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 1], 
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 2],
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 3],
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 4]) * NormalizeWeight;

				float4 DirectionalSH1 = float4(
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 5], 
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 6],
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 7],
					SharedSums[ThreadIndex * NUM_LIGHTING_SH_COEFFICIENTS + 8]) * NormalizeWeight;

				#if SH_QUANTIZE_DIRECTIONAL_COEFFICIENTS

					float4 CoefficientNormalizationScale0 = float4(
						0.282095f / 0.488603f,
						0.282095f / 0.488603f,
						0.282095f / 0.488603f,
						0.282095f / 1.092548f);

					float4 CoefficientNormalizationScale1 = float4(
						0.282095f / 1.092548f,
						0.282095f / (4.0f * 0.315392f),
						0.282095f / 1.092548f,
						0.282095f / (2.0f * 0.546274f));

					DirectionalSH0 = DirectionalSH0 * CoefficientNormalizationScale0 / max(AmbientRGB[ThreadIndex], .00001f) * .5f + .5f;
					DirectionalSH1 = DirectionalSH1 * CoefficientNormalizationScale1 / max(AmbientRGB[ThreadIndex], .00001f) * .5f + .5f;
				#endif

				uint WriteIndex = ((ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * 3 + ThreadIndex) * 2;
				RWScreenProbeRadianceSHDirectional[WriteIndex + 0] = DirectionalSH0;
				RWScreenProbeRadianceSHDirectional[WriteIndex + 1] = DirectionalSH1;
			}
#endif
		}
	}
}


RWBuffer<UNORM float> RWScreenProbeMoving;
Texture2D<float> ScreenProbeTraceMoving;

groupshared float SharedTexelMoving[THREADGROUP_SIZE * THREADGROUP_SIZE * 4];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeCalculateMovingCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0)
		{
			uint ThreadIndex = GroupThreadId.y * ScreenProbeGatherOctahedronResolution + GroupThreadId.x;
			if (ThreadIndex < ScreenProbeGatherOctahedronResolution * ScreenProbeGatherOctahedronResolution)
			{
				uint2 ProbeTexelCoord = GroupThreadId.xy;
				uint2 ReadIndex = ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
				SharedTexelMoving[ThreadIndex] = ScreenProbeTraceMoving[ReadIndex];
			}

			GroupMemoryBarrierWithGroupSync();

			uint NumValuesToAccumulate = ScreenProbeGatherOctahedronResolution * ScreenProbeGatherOctahedronResolution;
			uint Offset = 0;

			while (NumValuesToAccumulate > 1)
			{
				uint ThreadBaseIndex = ThreadIndex * 4;

				if (ThreadBaseIndex < NumValuesToAccumulate)
				{
					float Value = SharedTexelMoving[ThreadBaseIndex + Offset];

					if (ThreadBaseIndex + 1 < NumValuesToAccumulate)
					{
						Value += SharedTexelMoving[ThreadBaseIndex + 1 + Offset];
					}

					if (ThreadBaseIndex + 2 < NumValuesToAccumulate)
					{
						Value += SharedTexelMoving[ThreadBaseIndex + 2 + Offset];
					}

					if (ThreadBaseIndex + 3 < NumValuesToAccumulate)
					{
						Value += SharedTexelMoving[ThreadBaseIndex + 3 + Offset];
					}

					SharedTexelMoving[ThreadIndex + Offset + NumValuesToAccumulate] = Value;
				}

				Offset += NumValuesToAccumulate;
				NumValuesToAccumulate = (NumValuesToAccumulate + 3) / 4;

				GroupMemoryBarrierWithGroupSync();
			}

			float ProbeMoving = SharedTexelMoving[Offset] / (float)(ScreenProbeGatherOctahedronResolution * ScreenProbeGatherOctahedronResolution);
			
			if (ThreadIndex == 0)
			{
				uint WriteIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
				RWScreenProbeMoving[WriteIndex] = ProbeMoving;
			}
		}
	}
}

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void ScreenProbeFixupBordersCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / ScreenProbeGatherOctahedronResolutionWithBorder;
	uint2 ProbeTexelCoordWithBorder = DispatchThreadId.xy - ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolutionWithBorder;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	if (ScreenProbeIndex < GetNumScreenProbes() && all(ProbeTexelCoordWithBorder < ScreenProbeGatherOctahedronResolutionWithBorder))
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0.0f)
		{
			uint2 ProbeTexelCoord = OctahedralMapWrapBorder(ProbeTexelCoordWithBorder, ScreenProbeGatherOctahedronResolutionWithBorder, 1 << (uint)ScreenProbeGatherMaxMip);
			uint2 ReadIndex = ScreenProbeAtlasCoord * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
			RWScreenProbeRadiance[DispatchThreadId.xy] = ScreenProbeRadiance.Load(int3(ReadIndex, 0)).xyz;
		}
	}
}

RWTexture2D<float3> RWScreenProbeRadianceWithBorderMip;
Texture2D<float3> ScreenProbeRadianceWithBorderParentMip;
uint MipLevel; 

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeGenerateMipLevelCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ParentMipSize = ScreenProbeGatherOctahedronResolutionWithBorder >> (MipLevel - 1);
	uint MipSize = ScreenProbeGatherOctahedronResolutionWithBorder >> MipLevel;

	if (all(DispatchThreadId.xy < ScreenProbeAtlasViewSize * MipSize))
	{
		uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / MipSize;
		uint2 ProbeTexelCoord = DispatchThreadId.xy - ScreenProbeAtlasCoord * MipSize;
		uint2 ParentFinalAtlasCoord = ParentMipSize * ScreenProbeAtlasCoord + ProbeTexelCoord * 2;

		float InvParentMipSize = 1.0f / ParentMipSize;
		float2 ProbeUV00 = (ProbeTexelCoord * 2 + float2(0, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV10 = (ProbeTexelCoord * 2 + float2(1, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV01 = (ProbeTexelCoord * 2 + float2(0, 1) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV11 = (ProbeTexelCoord * 2 + float2(1, 1) + float2(.5f, .5f)) * InvParentMipSize;

		float4 Weights;
		Weights.x = OctahedralSolidAngleLUT(ProbeUV00, ParentMipSize);
		Weights.y = OctahedralSolidAngleLUT(ProbeUV10, ParentMipSize);
		Weights.z = OctahedralSolidAngleLUT(ProbeUV01, ParentMipSize);
		Weights.w = OctahedralSolidAngleLUT(ProbeUV11, ParentMipSize);

		//@todo - gather area around texel, not aligned to power of 2
		float3 Lighting = 0;
		Lighting += ScreenProbeRadianceWithBorderParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 0), 0)).xyz * Weights.x;
		Lighting += ScreenProbeRadianceWithBorderParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 0), 0)).xyz * Weights.y;
		Lighting += ScreenProbeRadianceWithBorderParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 1), 0)).xyz * Weights.z;
		Lighting += ScreenProbeRadianceWithBorderParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 1), 0)).xyz * Weights.w;

		uint2 WriteCoord = MipSize * ScreenProbeAtlasCoord + ProbeTexelCoord;
		RWScreenProbeRadianceWithBorderMip[WriteCoord] = Lighting / dot(Weights, 1);
	}
}
