// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenScreenProbeHardwareRayTracing.usf
=============================================================================*/

#pragma once

#ifndef ENABLE_TWO_SIDED_GEOMETRY
#define ENABLE_TWO_SIDED_GEOMETRY 0
#endif

#ifndef DIM_MISS_SHADER_LIGHTING
#define DIM_MISS_SHADER_LIGHTING 0
#endif

#ifndef SCENE_TRACE_CARDS
#define SCENE_TRACE_CARDS 1
#endif

#ifndef SINGLE_RAY_VISUALIZATION
#define SINGLE_RAY_VISUALIZATION 1
#endif

#ifndef LUMEN_HARDWARE_RAYTRACING
#define LUMEN_HARDWARE_RAYTRACING 1
#endif

#ifndef VISUALIZATION_BUFFER_ELEMENTS
#define VISUALIZATION_BUFFER_ELEMENTS 10
#endif

#ifndef CHS_GEOMETRY_NORMAL_ONLY
#define CHS_GEOMETRY_NORMAL_ONLY 0
#endif

#ifndef PRIMARY_VISUALIZATION_MODE
#define PRIMARY_VISUALIZATION_MODE 0
#endif

#define DEBUG_VISUALIZE_TRACE_TYPES 0

#if !LUMEN_HARDWARE_RAYTRACING
#ifdef SINGLE_RAY_VISUALIZATION
	#undef SINGLE_RAY_VISUALIZATION
#endif

#define SINGLE_RAY_VISUALIZATION 1
#endif

#define NORMAL_FROM_GEOMETRY_LIGHTING_FROM_SURFACE_CACHE	0
#define NORMAL_FROM_SDF_LIGHTING_FROM_SURFACE_CACHE			1
#define NORMAL_FROM_GEOMETRY_OR_MATERIAL					2
#define LIGHTING_FROM_SURFACE_CACHE							3
#define NORMAL_FROM_MATERIAL_LIGHTING_FROM_HIT				4

#include "../HairStrands/HairStrandsVoxelPageCommonStruct.ush"
#include "../Common.ush"
#if LUMEN_HARDWARE_RAYTRACING
#include "../RayTracing/RayTracingCommon.ush"
#endif

#define SUPPORT_CONTACT_SHADOWS		0
#define USE_SOURCE_TEXTURE			1
#define USE_SOURCE_TEXTURE_ARRAY	1

#define LTCMatTexture				RaytracingLightsDataPacked.LTCMatTexture
#define LTCMatSampler				RaytracingLightsDataPacked.LTCMatSampler
#define LTCAmpTexture				RaytracingLightsDataPacked.LTCAmpTexture
#define LTCAmpSampler				RaytracingLightsDataPacked.LTCAmpSampler
#define PreIntegratedGF				ReflectionStruct.PreIntegratedGF			
#define PreIntegratedGFSampler		ReflectionStruct.PreIntegratedGFSampler	

// When fetching the DFObject from the InstanceID, Use 0x7fffffff as invalid flag.
#define INVALID_CUBE_MAP_TREE_ID	0x7fffffff
#define INVALID_INSTANCE_ID			0x7fffffff

// Id reserved for direct material evaluation in visualization.  
#define CUBE_MAP_TREE_ID_RESERVED		-1
#define INSTANCE_ID_RESERVED			-1

struct FLumenHardwareDetailTracingContext
{
	uint RayFlags;
	//@todo, use macro for this four parameters if no two different traces are called.
	uint InstanceInclusionMask;
	uint RayContributionToHitGroupIndex;
	uint MultiplierForGeometryContributionToShaderIndex;
	uint MissShaderIndex;

#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_MATERIAL_LIGHTING_FROM_HIT
	bool bRayTraceSkyLightContribution;
	bool bDecoupleSampleGeneration;
	bool bEnableSkyLightContribution;
#endif

	uint2 ScreenCoord;
	float2 ScreenUV;
	uint ScreenProbeSubsampleIndex;
	float ConeHalfAngle;
	bool bHasScattered;
	bool bAllowSkySampling;

#if	 SINGLE_RAY_VISUALIZATION
	float3 RayOriginWithoutOffset;
	float3 RayOriginWithoutOffsetNormal;
	uint2 RayOriginWithoutOffsetTraceCoord;
	float3 PotentialHitPosition;
	float TraceDistance;
	bool  bIsVisualizationPixel;
#endif
};

#if SINGLE_RAY_VISUALIZATION
//-----------------------------------------
//Visualization parameters and function

#if LUMEN_HARDWARE_RAYTRACING
#define FDetailedTracingBufferType RWBuffer<float4>
#define DetailedTracingBuffer RWHardwareDetailTracingVisualizationBuffer
#else
#define FDetailedTracingBufferType Buffer<float4>
#define DetailedTracingBuffer HardwareDetailTracingVisualizationBuffer
#endif

float4 HardwareTracesVisualizationParams;				// x: Mode,  yz: DispatchThreadId.xy, w: freeze 
FDetailedTracingBufferType DetailedTracingBuffer;

#define VISUALIZATION_MODE_SCREEN_CENTER_HIT			0
#define VISUALIZATION_MODE_ANY_SCREEN_HIT_FROM_CENTER	1
#define VISUALIZATION_MODE_PROBE_DEFAULT_DIRECTION      2
#define VISUALIZATION_MODE_INVALID						-1

#define VISUALIZATION_FLAG_DRAW_RAY					(VISUALIZATION_MODE_ANY_SCREEN_HIT_FROM_CENTER|VISUALIZATION_MODE_PROBE_DEFAULT_DIRECTION)
#define VISUALIZATION_FLAG_DRAW_HIT_ONLY			VISUALIZATION_MODE_SCREEN_CENTER_HIT

bool IsVisualizationModeValid()
{
	return (HardwareTracesVisualizationParams.x != VISUALIZATION_MODE_INVALID);
}

int GetHardwareDetailTracingMode()
{
	return (int)HardwareTracesVisualizationParams.x;
}

bool IsHardwareDetailTracingFreezed()
{
	return HardwareTracesVisualizationParams.w != 0;
}

uint2 GetHardwareDetailTracingTargetCoordinate()
{
	return HardwareTracesVisualizationParams.yz;
}

struct FHardwareDetailTraceSnapshot
{
	int Mode;
	int InstanceID;
	int DFObjectID;
	int MaterialEvaluationType;
	float HitDistance;
	float TraceDistance;	//Max trace distance for screen probe gathering
	uint2 TargetTraceCoord;
	float3 RayHitPosition;
	float3 RayHitNormal;
	float3 RayOriginWithoutBiasOffset;
	float3 RayOriginNormal;
	uint2 RayOriginTraceCoord;
	float3 RayOrigin;
	float3 RayDirection;
	float3 RayPotentialHitPosition;

	bool IsRayHit() { return HitDistance > 0; }
};

FHardwareDetailTraceSnapshot DecodeHardwareDetailTraceSnapshot()
{
	FHardwareDetailTraceSnapshot Snapshot = (FHardwareDetailTraceSnapshot)0;

	Snapshot.Mode = DetailedTracingBuffer[0].x;
	Snapshot.TargetTraceCoord = DetailedTracingBuffer[0].yz;
	Snapshot.RayHitPosition = DetailedTracingBuffer[1].xyz;
	Snapshot.TraceDistance = DetailedTracingBuffer[1].w;
	Snapshot.RayHitNormal = DetailedTracingBuffer[2].xyz;
	Snapshot.MaterialEvaluationType = DetailedTracingBuffer[3].x;
	Snapshot.InstanceID = DetailedTracingBuffer[3].y;
	Snapshot.DFObjectID = DetailedTracingBuffer[3].z;
	Snapshot.HitDistance = DetailedTracingBuffer[3].w;
	Snapshot.RayOriginWithoutBiasOffset = DetailedTracingBuffer[4].xyz;
	Snapshot.RayOriginTraceCoord = DetailedTracingBuffer[5].xy;
	Snapshot.RayOriginNormal = DetailedTracingBuffer[8].xyz;
	Snapshot.RayOrigin = DetailedTracingBuffer[6].xyz;
	Snapshot.RayDirection = DetailedTracingBuffer[7].xyz;
	Snapshot.RayPotentialHitPosition = DetailedTracingBuffer[9].xyz;
	return Snapshot;
}

#if LUMEN_HARDWARE_RAYTRACING

void EncodeHardwareDetailTraceSnapshot(RayDesc Ray, FLumenHardwareDetailTracingContext Context, float HitDistance, float3 HitNormal, int InstanceID, int DFObjectIndex)
{
	if (Context.bIsVisualizationPixel)
	{
		float3 RayHitPosition = Ray.Origin + Ray.Direction * HitDistance;
		DetailedTracingBuffer[0] = HardwareTracesVisualizationParams;		// Determines how we visualize the parameters
		DetailedTracingBuffer[1] = float4(RayHitPosition, Context.TraceDistance);				// Position of ray hit.
		DetailedTracingBuffer[2] = float4(HitNormal, 0);				// Normal of ray hit.
		DetailedTracingBuffer[3] = float4(MATERIAL_EVALUATION_TYPE, InstanceID, DFObjectIndex, HitDistance);
		DetailedTracingBuffer[4] = float4(Context.RayOriginWithoutOffset, 0);
		DetailedTracingBuffer[5] = float4(Context.RayOriginWithoutOffsetTraceCoord, 0, 0);
		DetailedTracingBuffer[6] = float4(Ray.Origin, 0);
		DetailedTracingBuffer[7] = float4(Ray.Direction, 0);
		DetailedTracingBuffer[8] = float4(Context.RayOriginWithoutOffsetNormal, 0);
		DetailedTracingBuffer[9] = float4(Context.PotentialHitPosition, 0);
	}

#if VISUALIZATION_BUFFER_ELEMENTS != (9+1)
#error "visualization buffer size VISUALIZATION_NUM_BUFFER_ELEMENTS does not match between usf and cpp"
#endif
}

#endif //LUMEN_HARDWARE_RAYTRACING
#endif //SINGLE_RAY_VISUALIZATION

#if LUMEN_HARDWARE_RAYTRACING

#include "../DeferredShadingCommon.ush"
#include "../DeferredLightingCommon.ush"
#include "../ReflectionEnvironmentShared.ush"
#include "../Montecarlo.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush" 
#include "../HeightFogCommon.ush"
#include "../SobolRandom.ush"
#include "../SceneTextureParameters.ush"
#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"
#include "../RayTracing/RayTracingDirectionalLight.ush"
#include "../RayTracing/RayTracingRectLight.ush"
#include "../RayTracing/RayTracingSphereLight.ush"
#include "../RayTracing/RayTracingSpotLight.ush"
#include "../RayTracing/RayTracingPointLight.ush"
#include "../RayTracing/RayTracingLightingCommon.ush"

#define	ERayTracingPrimaryRaysFlag_None                               0
#define	ERayTracingPrimaryRaysFlag_UseGBufferForMaxDistance    (1u << 0)
#define	ERayTracingPrimaryRaysFlag_ConsiderSurfaceScatter	   (1u << 1)
#define	ERayTracingPrimaryRaysFlag_AllowSkipSkySample		   (1u << 2)

#ifndef PROBE_HIERARCHY_ID
#define PROBE_HIERARCHY_ID 0
#endif

#include "../DeferredShadingCommon.ush"
#include "LumenCardCommon.ush"
// Depth weighted OIT doesn't cover enough depth range for ConeTraceLumenDistantScene
// This has the side effect that card tracing for detail traces in this file don't get blended
#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenScreenProbeCommon.ush"

//----------------------------------------
float MinTraceDistance;
float MaxTraceDistance;
float SurfaceBias;
int GeometryNormalOnlyForCHS;
//------------------------------------------
//Pass parameters
RWTexture2D<float4> GeometryNormalCache;

//-----------------------------------------
//ray tracing parameters.

int ReflectedShadowsType;
uint PrimaryRayFlags;
float MaxNormalBias;
RaytracingAccelerationStructure TLAS;

struct FRaySetupParams
{
	float3 RayOrigin;
	float ConeHalfAngle;
	float3 RayOriginWithoutOffsetNormal;
	float3 RayOriginWithoutOffset;
	uint2 RayOriginWithoutOffsetTraceCoord;

#if SINGLE_RAY_VISUALIZATION
	float3 PotentialHitPosition;
	float3 RayDirection;
#endif

	void Init(float3 SamplePosition, float3 SceneNormal, uint2 TraceCoord)
	{
		RayOrigin = SamplePosition;
		RayOriginWithoutOffset = SamplePosition;
		RayOriginWithoutOffsetTraceCoord = TraceCoord;
		RayOriginWithoutOffsetNormal = SceneNormal;
	}
};

void ReadRayOriginInfoIfFreeze(inout FRaySetupParams RaySetupParam)
{
	bool bTracesFreezed = IsHardwareDetailTracingFreezed();

	if (bTracesFreezed)
	{ // update the source info
		FHardwareDetailTraceSnapshot Snapshot = DecodeHardwareDetailTraceSnapshot();
		RaySetupParam.RayOriginWithoutOffset = Snapshot.RayOriginWithoutBiasOffset;
		RaySetupParam.RayOriginWithoutOffsetNormal = Snapshot.RayOriginNormal;
		RaySetupParam.RayDirection = Snapshot.RayDirection;
	}
}

void UpdatePotentialHitOrRayDirection(inout FRaySetupParams RaySetupParam, inout float3 WorldConeDirection)
{
	bool bTracesFreezed = IsHardwareDetailTracingFreezed();
	int VisualizationMode = GetHardwareDetailTracingMode();

	if (bTracesFreezed)
	{
		FHardwareDetailTraceSnapshot Snapshot = DecodeHardwareDetailTraceSnapshot();
		RaySetupParam.PotentialHitPosition = Snapshot.RayPotentialHitPosition;

		if (VisualizationMode == VISUALIZATION_MODE_PROBE_DEFAULT_DIRECTION)
		{
			WorldConeDirection = RaySetupParam.RayDirection;
		}

		if (VisualizationMode == VISUALIZATION_MODE_ANY_SCREEN_HIT_FROM_CENTER)
		{
			WorldConeDirection = normalize(RaySetupParam.PotentialHitPosition - RaySetupParam.RayOriginWithoutOffset);//@todo, when the overlap.
		}
	}
	else
	{
		if (GetHardwareDetailTracingMode() == VISUALIZATION_MODE_ANY_SCREEN_HIT_FROM_CENTER)
		{
			uint2 DispatchThreadId = GetHardwareDetailTracingTargetCoordinate();

			uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / ScreenProbeTracingOctahedronResolution;
			uint2 TraceTexelCoord = DispatchThreadId.xy - ScreenProbeAtlasCoord * ScreenProbeTracingOctahedronResolution;
			uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

			uint2 ScreenProbeScreenCoord;
			uint ScreenProbeSubsampleIndex;
			GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

			if (all(ScreenProbeIndex < GetNumScreenProbes() && TraceTexelCoord < ScreenProbeTracingOctahedronResolution))
			{
				float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
				float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

				if (SceneDepth > 0)
				{
					RaySetupParam.PotentialHitPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
					WorldConeDirection = normalize(RaySetupParam.PotentialHitPosition - RaySetupParam.RayOriginWithoutOffset);//@todo, when the overlap.
					
				}
			}
		} // else use default world cone direction.
	}
}

RayDesc SetupRay(float2 UV, float3 WorldConeDirection, float TraceDistance, 
				inout FRaySetupParams RaySetupParam,
				bool bVisualizePixel)
{
	RayDesc Ray;
	
	if (!bVisualizePixel)
	{

		Ray.Origin = RaySetupParam.RayOriginWithoutOffset;
		Ray.Direction = WorldConeDirection;
		Ray.TMin = 0.001f;
		Ray.TMax = TraceDistance;

#if !PRIMARY_VISUALIZATION_MODE
		ApplyPositionBias(Ray, RaySetupParam.RayOriginWithoutOffsetNormal, max(MaxNormalBias, SurfaceBias * 0.5f));

		// Update the sample position before and after bias update for later tracing usage. 
		RaySetupParam.RayOriginWithoutOffset = RaySetupParam.RayOrigin;
		RaySetupParam.RayOrigin = Ray.Origin;
#endif
		return Ray;
	}

#if SINGLE_RAY_VISUALIZATION
	//coherent branch except the thread group where we need a visualization and we need 
	// to visualize.
	int VisualizationMode = GetHardwareDetailTracingMode();
	bool bTracesFreezed = IsHardwareDetailTracingFreezed();
	
	// update the source info
	ReadRayOriginInfoIfFreeze(RaySetupParam);

	BRANCH
	if (VisualizationMode == VISUALIZATION_MODE_SCREEN_CENTER_HIT)
	{
		Ray = CreatePrimaryRay(UV);
		
		if (bTracesFreezed)
		{  
			//overwrite the origin and directon to use the one when we freeze.
			Ray.Origin = RaySetupParam.RayOriginWithoutOffset;
			Ray.Direction = RaySetupParam.RayDirection;//normalize(RaySetupParam.PotentialHitPosition - Ray.Origin);
		}

		RaySetupParam.ConeHalfAngle = View.EyeToPixelSpreadAngle;
		RaySetupParam.RayOriginWithoutOffset = Ray.Origin;
		RaySetupParam.RayOriginWithoutOffsetNormal = 0;
		RaySetupParam.RayOriginWithoutOffsetTraceCoord = ScreenProbeViewSize / 2;
		RaySetupParam.RayOrigin = Ray.Origin;
	}
	else
	{
		//update the potential hit info
		UpdatePotentialHitOrRayDirection(RaySetupParam, WorldConeDirection);

		Ray.Origin = RaySetupParam.RayOriginWithoutOffset;
		Ray.Direction = WorldConeDirection;
		Ray.TMin = 0.01f;
		Ray.TMax = TraceDistance;
		ApplyPositionBias(Ray, RaySetupParam.RayOriginWithoutOffsetNormal, max(MaxNormalBias, SurfaceBias * 0.5f));

		// Update the sample position after bias update for later tracing usage. 
		RaySetupParam.RayOrigin = Ray.Origin;
	}
#endif

	return Ray;
}

struct FLumenTracingResult
{
	float4 RadianceAndOpacity;
	float HitT;

	bool IsMiss() { return HitT < 0; }
	bool IsHit() { return !IsMiss(); }
};

float3 GetSkyRadiance(float3 Direction, float ConehalfAngle)
{
	float SkyAverageBrightness = 1.0f;
	float Roughness = TanConeAngleToRoughness(tan(ConehalfAngle));
	return GetSkyLightReflection(Direction, Roughness, SkyAverageBrightness);
}

struct FHitObjectResult
{
	int HitObject;
	bool IsValid() { return HitObject != INVALID_CUBE_MAP_TREE_ID; }
};

 void QueryHitObject(uint InstanceID,out FHitObjectResult HitObjectResult)
{
	HitObjectResult.HitObject = LumenCardScene.PrimitiveToDFObjectIndexBuffer.Load(4 * InstanceID);
}

 void SampleCubeMapTree(float HitDistance, int HitObject, float3 HitNormal, bool bAccurateHit, RayDesc Ray, inout float4 RadianceAndOpacity, float ConeHalfAngle, inout float3 Debug)
 {
#if SCENE_TRACE_CARDS

	 //@todo - derive from card texel size
	 float CardInterpolateDepthVisibilityRadius = 10;

	 float3 InterpolatePosition = Ray.Origin + Ray.Direction * HitDistance;

	 float InterpolateRadius = HitDistance * tan(ConeHalfAngle);

	 uint AtlasId = FINAL_LIGHTING_ATLAS_ID;
	 RadianceAndOpacity.xyz +=
		 SampleLumenCubeMapTree(
			 HitObject,
			 InterpolatePosition,
			 HitNormal,
			 InterpolateRadius,
			 bAccurateHit,
			 CardInterpolateDepthVisibilityRadius,
			 AtlasId);

	 if (any(isnan(HitNormal)))
	 {
		 Debug = float3(1.0f, 0.0f, 0.0f);
		 RadianceAndOpacity = float4(1.0f,0.0f, 0.0f,1.0f);
	 }

	 RadianceAndOpacity.w = 1.0f;

#endif
 }

#if (MATERIAL_EVALUATION_TYPE == NORMAL_FROM_SDF_LIGHTING_FROM_SURFACE_CACHE) || \
	(MATERIAL_EVALUATION_TYPE == LIGHTING_FROM_SURFACE_CACHE )
#define FLumenPayLoadType FDefaultPayload
#elif (MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_LIGHTING_FROM_SURFACE_CACHE)|| \
	(MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_OR_MATERIAL)
#define FLumenPayLoadType  FPackedMaterialClosestHitPayload
#else 
// The define here is used as placeholder for max compatibility
#define FLumenPayLoadPlaceHolderType FPackedMaterialClosestHitPayload
#define FLumenPayLoadType FLumenPayLoadPlaceHolderType
#endif

 uint GetRayContributionToHitGroupIndex()
 {

#if (MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_OR_MATERIAL) || \
	 (MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_LIGHTING_FROM_SURFACE_CACHE)
	 return RAY_TRACING_SHADER_SLOT_MATERIAL;
#else
	 return RAY_TRACING_SHADER_SLOT_SHADOW;
#endif

 }

 uint LumenGetInstanceID(FDefaultPayload Payload)
 {
	 return Payload.InstanceID;
 }

 uint LumenGetInstanceID(FPackedMaterialClosestHitPayload Payload)
 {
	 return Payload.GetInstanceID();
 }

 void LumenSetMinimalPayload(inout FPackedMaterialClosestHitPayload Payload)
 {
	 // Indicate that we only query geometry normal.
	 Payload.SetMinimalPayloadMode();
	 Payload.SetLumenPayload();
 }

 void LumenSetMinimalPayload(FDefaultPayload Payload)
 {
 }

 float3 LumenGetMinimalPayloadNormal(FPackedMaterialClosestHitPayload Payload)
 {
	 float3 Normal = 0;

	 if (Payload.IsLumenPayload())
	 {
		 Normal = Payload.GetGeometryNormal();
	 }
	 else
	 {
		 Normal = Payload.GetWorldNormal();
	 }
	 return Normal;
 }

 float3 LumenGetMinimalPayloadNormal(FDefaultPayload Payload)
 {
	 return float3(0.0f, 0.0f, 0.0f);
 }

#define FTraceMeshNormal FTraceMeshSDFDerivedData

 FTraceMeshNormal LumenGetNormal(FLumenPayLoadType Payload, FHitObjectResult HitObjectResult, RayDesc Ray, uint2 ScreenCoord)
 {
	 float3 HitNormal = float3(0.0f,0.0f,0.0f);
	 float HitDistance = Payload.HitT;
	 bool bAccurateHit = false;
#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_SDF_LIGHTING_FROM_SURFACE_CACHE
	 
	 if (HitObjectResult.IsValid())
	 {
		 FTraceMeshSDFResult TraceMeshSDFResult;
		 TraceMeshSDFResult.HitDistance = HitDistance;
		 TraceMeshSDFResult.HitObject = HitObjectResult.HitObject;

		 FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(Ray.Origin, Ray.Direction, HitDistance, TraceMeshSDFResult);
		 HitNormal = TraceSDFData.HitNormal;
		 bAccurateHit = TraceSDFData.bAccurateHit;
	 }

#elif MATERIAL_EVALUATION_TYPE == LIGHTING_FROM_SURFACE_CACHE
	 HitNormal = GeometryNormalCache[ScreenCoord].xyz;
#elif MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_LIGHTING_FROM_SURFACE_CACHE
	 HitNormal = Payload.GetGeometryNormal();
	 HitNormal = dot(Ray.Direction, HitNormal) < 0 ? HitNormal : -HitNormal;
#endif
	 FTraceMeshNormal TraceMeshNormal;
	 TraceMeshNormal.bAccurateHit = bAccurateHit;
	 TraceMeshNormal.HitNormal = HitNormal;
	 return TraceMeshNormal;
 }


void LumenContextSetup(inout FLumenHardwareDetailTracingContext TracingContext, 
			float InConeHalfAngle, uint2 InScreenCoord, float2 InScreenUV, uint InScreenProbeSubsampleIndex, bool bInHasScattered, bool bInAllowSkySampling)
{

#if !ENABLE_TWO_SIDED_GEOMETRY
	TracingContext.RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif 
	TracingContext.InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE | RAY_TRACING_MASK_THIN_SHADOW | RAY_TRACING_MASK_SHADOW;
	TracingContext.RayContributionToHitGroupIndex = GetRayContributionToHitGroupIndex();
	TracingContext.MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	TracingContext.MissShaderIndex = 0;

#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_MATERIAL_LIGHTING_FROM_HIT
	TracingContext.bRayTraceSkyLightContribution = false;
	TracingContext.bDecoupleSampleGeneration = true;
	TracingContext.bEnableSkyLightContribution = false;
#endif
	TracingContext.ScreenCoord = InScreenCoord;
	TracingContext.ScreenUV = InScreenUV;
	TracingContext.ConeHalfAngle = InConeHalfAngle;
	TracingContext.bHasScattered = bInHasScattered;
	TracingContext.bAllowSkySampling = bInAllowSkySampling;
	TracingContext.ScreenProbeSubsampleIndex = InScreenProbeSubsampleIndex;
}



void LumenSetupVisualizationParam(inout FLumenHardwareDetailTracingContext TracingContext, FRaySetupParams RaySetupParams, 
			float inTraceDistance, bool inIsVisualizationPixel)
{
#if	 SINGLE_RAY_VISUALIZATION
	TracingContext.RayOriginWithoutOffset = RaySetupParams.RayOriginWithoutOffset;
	TracingContext.RayOriginWithoutOffsetTraceCoord = RaySetupParams.RayOriginWithoutOffsetTraceCoord;
	TracingContext.RayOriginWithoutOffsetNormal = RaySetupParams.RayOriginWithoutOffsetNormal;
	TracingContext.PotentialHitPosition = RaySetupParams.PotentialHitPosition;
	TracingContext.bIsVisualizationPixel = inIsVisualizationPixel;
	TracingContext.TraceDistance = inTraceDistance;
#endif
}

void TraceGeometryOrMaterialNormal(RayDesc Ray, FLumenHardwareDetailTracingContext TracingContext)
{
	float3 Normal = 0.0f;

	FLumenPayLoadType Payload = (FLumenPayLoadType)0; 

	// true for geometry normal, otherwise material normal
	if (GeometryNormalOnlyForCHS == 1)
	{
		LumenSetMinimalPayload(Payload);
	}

	TraceRay(
		TLAS,   // AccelerationStructure
		TracingContext.RayFlags,
		TracingContext.InstanceInclusionMask,             // InstanceInclusionMask
		TracingContext.RayContributionToHitGroupIndex, // RayContributionToHitGroupIndex
		TracingContext.MultiplierForGeometryContributionToShaderIndex,     // MultiplierForGeometryContributionToShaderIndex
		TracingContext.MissShaderIndex,      // MissShaderIndex
		Ray,    // RayDesc
		Payload // Payload
	);

	Normal = LumenGetMinimalPayloadNormal(Payload);
	Normal = dot(Ray.Direction, Normal) < 0 ? Normal : -Normal;
	GeometryNormalCache[TracingContext.ScreenCoord] = float4(Normal, 0.0f); // w unused
}

FLumenTracingResult HardwareDetailTracing(RayDesc Ray, FLumenHardwareDetailTracingContext TracingContext)
{
	FLumenTracingResult LumenTracingResult = (FLumenTracingResult)0;
	float3 Debug = 0.0f;
	uint InstanceID = INVALID_INSTANCE_ID;
	uint DFObjectIndex = INVALID_CUBE_MAP_TREE_ID;
	float3 HitNormal = 0.0f;

#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_MATERIAL_LIGHTING_FROM_HIT
	
	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = TracingContext.ConeHalfAngle;

	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, TracingContext.ScreenProbeSubsampleIndex, View.StateFrameIndex);

	FMaterialClosestHitPayload Payload = TraceRayAndAccumulateResults(
		Ray,
		TLAS,
		TracingContext.RayFlags,
		TracingContext.	InstanceInclusionMask,
		RandSequence,
		TracingContext.ScreenCoord,
		MaxNormalBias,
		ReflectedShadowsType,
		true/*ShouldDoDirectLighting*/,
		true/*ShouldDoEmissiveAndIndirectLighting*/,
		TracingContext.bRayTraceSkyLightContribution,
		TracingContext.bDecoupleSampleGeneration,
		RayCone,
		TracingContext.bEnableSkyLightContribution,
		LumenTracingResult.RadianceAndOpacity.xyz);

	LumenTracingResult.HitT = Payload.HitT;
	LumenTracingResult.RadianceAndOpacity.w = Payload.Opacity;

#if SINGLE_RAY_VISUALIZATION
	InstanceID = INSTANCE_ID_RESERVED;
	DFObjectIndex = CUBE_MAP_TREE_ID_RESERVED;
	HitNormal = Payload.WorldNormal;
#endif

#elif MATERIAL_EVALUATION_TYPE != NORMAL_FROM_GEOMETRY_OR_MATERIAL

	FLumenPayLoadType LumenPayload = (FLumenPayLoadType)0;

	LumenSetMinimalPayload(LumenPayload);

	TraceRay(
		TLAS,   // AccelerationStructure
		TracingContext.RayFlags,
		TracingContext.InstanceInclusionMask,             // InstanceInclusionMask
		TracingContext.RayContributionToHitGroupIndex, // RayContributionToHitGroupIndex
		TracingContext.MultiplierForGeometryContributionToShaderIndex,     // MultiplierForGeometryContributionToShaderIndex
		TracingContext.MissShaderIndex,      // MissShaderIndex
		Ray,    // RayDesc
		LumenPayload // Payload
	);

	InstanceID = LumenGetInstanceID(LumenPayload);
	FHitObjectResult HitObjectResult = (FHitObjectResult) 0;

	if (LumenPayload.IsHit())
	{	
		QueryHitObject(InstanceID, HitObjectResult);
		
		DFObjectIndex = HitObjectResult.HitObject;
		FTraceMeshNormal TraceMeshNormal = LumenGetNormal(LumenPayload, HitObjectResult, Ray, TracingContext.ScreenCoord);
		
		BRANCH
		if (HitObjectResult.IsValid())
		{
			
			SampleCubeMapTree(LumenPayload.HitT, DFObjectIndex,
				TraceMeshNormal.HitNormal, TraceMeshNormal.bAccurateHit,Ray, LumenTracingResult.RadianceAndOpacity,
				TracingContext.ConeHalfAngle, Debug);
		}
		else
		{
			const float4 BlackRadiance = float4(0.0f, 0.0f, 0.0f, 1.0f);
			// If the hit object does not have a surface cache mapping, explicitly set it to black and opaque.
			LumenTracingResult.RadianceAndOpacity = BlackRadiance;
		}

#if SINGLE_RAY_VISUALIZATION && !PRIMARY_VISUALIZATION_MODE
		HitNormal = TraceMeshNormal.HitNormal;
#endif

	}
	LumenTracingResult.HitT = LumenPayload.HitT;
#endif

#if SINGLE_RAY_VISUALIZATION && !PRIMARY_VISUALIZATION_MODE
	EncodeHardwareDetailTraceSnapshot(Ray, TracingContext, LumenTracingResult.HitT, HitNormal, InstanceID, DFObjectIndex);
#endif

	return LumenTracingResult;
}

RAY_TRACING_ENTRY_RAYGEN(LumenCardHardwareRayTracingRGS)
{
	float3 Debug = float3(0.0f, 0.0f, 0.0f);
	uint2 DispatchThreadId = DispatchRaysIndex().xy;
	
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / ScreenProbeTracingOctahedronResolution;
	uint2 TraceTexelCoord = DispatchThreadId.xy - ScreenProbeAtlasCoord * ScreenProbeTracingOctahedronResolution;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	uint2 TraceCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TraceTexelCoord);

	if (all(ScreenProbeIndex < GetNumScreenProbes() && TraceTexelCoord < ScreenProbeTracingOctahedronResolution))
	{
		float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		bool bHit;
		float TraceHitDistance = DecodeProbeRayDistance(TraceHit[TraceCoord].x, bHit);
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
		float3 SceneNormal = DecodeNormal(GBufferATexture.Load(int3(ScreenUV * View.BufferSizeAndInvSize.xy, 0)).xyz);
		
		if (SceneDepth > 0 && !bHit)
		{
			float2 ProbeUV;
			float ConeHalfAngle;
			GetProbeTracingUV(ScreenProbeAtlasCoord, TraceTexelCoord, GetProbeTexelCenter(ScreenProbeScreenCoord), 1, ProbeUV, ConeHalfAngle);

			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

			//@todo the sampling position might not be the best for RTX
			float3 SamplePosition = WorldPosition;

			bool bAllowSkySampling = false; // Sky sampling is handled at the last step by voxel tracing. Keep it here for testing. 

			// Check if the Sky Light should affect reflection rays within translucency.
			// const bool bSkyLightAffectReflection = ShouldSkyLightAffectReflection();

			bool bHasScattered = (ERayTracingPrimaryRaysFlag_ConsiderSurfaceScatter & PrimaryRayFlags) != 0;

			float TraceDistance = MaxTraceDistance;
			
#if RADIANCE_CACHE
			bool bCoveredByRadianceCache = false;
			float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(WorldPosition, WorldConeDirection, bCoveredByRadianceCache);
			TraceDistance = min(TraceDistance, ProbeOcclusionDistance);
#endif

			bool bIsVisualizationPixel = all(ScreenProbeViewSize / 2 == ScreenProbeAtlasCoord) && IsVisualizationModeValid();

			FRaySetupParams RaySetupParams = (FRaySetupParams)0;
			RaySetupParams.Init(SamplePosition, SceneNormal, TraceCoord);

			RayDesc Ray = SetupRay(ScreenUV, WorldConeDirection, TraceDistance, RaySetupParams, bIsVisualizationPixel);

			FLumenHardwareDetailTracingContext TracingContext=(FLumenHardwareDetailTracingContext)0;

			LumenContextSetup(TracingContext,ConeHalfAngle, TraceCoord, ScreenUV, ScreenProbeSubsampleIndex, bHasScattered, bAllowSkySampling);
			LumenSetupVisualizationParam(TracingContext, RaySetupParams, TraceDistance, bIsVisualizationPixel);

			FLumenTracingResult Result = (FLumenTracingResult)0;

			#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_OR_MATERIAL
				TraceGeometryOrMaterialNormal(Ray, TracingContext);
			#else
				Result = HardwareDetailTracing(Ray, TracingContext);

				// If we should handle the miss locally, sample the sky radiance and emit a hit.
				if (Result.IsMiss())
				{
					if (bHasScattered && bAllowSkySampling)
					{
						Result.RadianceAndOpacity= float4( GetSkyRadiance(Ray.Direction, ConeHalfAngle), 1.0f);
					}
				}
			#endif

			float3 Lighting =  Result.RadianceAndOpacity.xyz;
			float Transparency = 1 - Result.RadianceAndOpacity.w;
			float OpaqueHitDistance = Result.HitT;

			Lighting *= View.PreExposure;

#if DEBUG_VISUALIZE_TRACE_TYPES
			RWTraceRadiance[TraceCoord] = float3(0.0f,0.5f,0.0f)*View.PreExposure;
#else
			RWTraceRadiance[TraceCoord] = Lighting;
#endif
			//@todo - dither to handle fractional Transparency for fade
			if (Transparency < .5f)
			{
				// write only when we are not just retrieving normal
				#if MATERIAL_EVALUATION_TYPE != NORMAL_FROM_GEOMETRY_OR_MATERIAL
					bHit = true;
					TraceHitDistance = OpaqueHitDistance + length(WorldPosition - SamplePosition);
				#endif
			}
			else //write the distance even when there is no hit.
			{
				TraceHitDistance = TraceDistance;
			}
		}

		// This shader must always write hit distance even if no hit
		//@todo - set bMoving based on hit object velocity
		RWTraceHit[TraceCoord] = EncodeProbeRayDistance(TraceHitDistance, bHit, false);
	}
}

#if PRIMARY_VISUALIZATION_MODE
RWTexture2D<float4> RWSceneColor;
uint4 ViewDimensions;


RAY_TRACING_ENTRY_RAYGEN(LumenCardHardwarePrimaryRayTracingRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy;
	uint2 TraceCoord = DispatchRaysIndex().xy + ViewDimensions.xy;
	float2 ScreenUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ScreenUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;
	float3 CameraVector = normalize(ScreenVector);
	
	float ConeHalfAngle = View.EyeToPixelSpreadAngle;

	//@todo the sampling position might not be the best for RTX
	float3 WorldPosition = View.WorldCameraOrigin;
	float3 SamplePosition = WorldPosition;

	bool bAllowSkySampling = true; // Need this in visualization mode

	// Check if the Sky Light should affect reflection rays within translucency.
	// const bool bSkyLightAffectReflection = ShouldSkyLightAffectReflection();

	bool bHasScattered = (ERayTracingPrimaryRaysFlag_ConsiderSurfaceScatter & PrimaryRayFlags) != 0;

	float TraceDistance = 1.0e27;

	bool bIsVisualizationPixel = false;

	FRaySetupParams RaySetupParams = (FRaySetupParams)0;
	RaySetupParams.Init(SamplePosition, 0.0f, TraceCoord);

	RayDesc Ray = SetupRay(ScreenUV, CameraVector, TraceDistance, RaySetupParams, bIsVisualizationPixel);

	FLumenHardwareDetailTracingContext TracingContext = (FLumenHardwareDetailTracingContext)0;

	LumenContextSetup(TracingContext, ConeHalfAngle, TraceCoord, ScreenUV, 0, bHasScattered, bAllowSkySampling);
	
	FLumenTracingResult Result = (FLumenTracingResult)0;

#if MATERIAL_EVALUATION_TYPE == NORMAL_FROM_GEOMETRY_OR_MATERIAL
	TraceGeometryOrMaterialNormal(Ray, TracingContext);
#else
	Result = HardwareDetailTracing(Ray, TracingContext);

	// If we should handle the miss locally, sample the sky radiance and emit a hit.
	if (Result.IsMiss())
	{
		if (bHasScattered && bAllowSkySampling)
		{
			Result.RadianceAndOpacity = float4(GetSkyRadiance(Ray.Direction, ConeHalfAngle), 1.0f);
		}
	}
#endif

	float3 Lighting = Result.RadianceAndOpacity.xyz;
	float Transparency = 1 - Result.RadianceAndOpacity.w;
	float OpaqueHitDistance = Result.HitT;

	Lighting *= View.PreExposure;

#if DEBUG_VISUALIZE_TRACE_TYPES
	RWSceneColor[TraceCoord] = float4(float3(0.0f, 0.5f, 0.0f) * View.PreExposure, 1.0f);
#else
	RWSceneColor[TraceCoord] = float4(Lighting, 1);
#endif

}
#endif

#endif // end LUMEN_HARDWARE_RAYTRACING

#if !LUMEN_HARDWARE_RAYTRACING

#include "../Montecarlo.ush"
#include "../DeferredShadingCommon.ush"

float3 GetVertexOfRectFromNormal(float3 CenterPoint, float3 RectNormal, float2 HalfWidth, int VertexIndex)
{
	const float4x2 Vertex = { float2(-1, -1), float2(-1,1), float2(1,1),float2(1,-1) };
	const float2x3 TriangleList = { float3(0, 1, 2),float3(0,2,3) };

	int TriangleVertexIndex = VertexIndex % 3;
	int TriangleId = (VertexIndex % 6) / 3;
	float3x3 Basis = GetTangentBasis(RectNormal);

	float2 VertexPosition = Vertex[TriangleList[TriangleId][TriangleVertexIndex]];
	return CenterPoint + Basis[0] * VertexPosition.x * HalfWidth.x + Basis[1] * VertexPosition.y * HalfWidth.y;
}

float3 GetVertexOfRectFromLineSegment(float3 RectLeftCenter, float3 RectRightCenter, float HalfWidth, int VertexIndex)
{
	const float2x3 TrianglePositionOffset = { float3(-1, -1, 1),float3(-1,1,1) };
	const float2x3 TriangleIndex = {float3(0,1,1),float3(0,1,0)};

	int TriangleVertexIndex = VertexIndex % 3;
	int TriangleId = (VertexIndex % 6) / 3;

	float2x3 LineSegmentData = { RectLeftCenter , RectRightCenter};
	float3x3 Basis = GetTangentBasis(normalize(RectRightCenter - RectLeftCenter));
	float3 PerpendicularBasis = Basis[1];

	return LineSegmentData[TriangleIndex[TriangleId][TriangleVertexIndex]] + 
		TrianglePositionOffset[TriangleId][TriangleVertexIndex] * PerpendicularBasis * HalfWidth;
}

// Google colors 10, used to maximally distinguish the visualization ID visually.
static const float3 ColorTemplates[10] = {
	float3(0.200, 0.400, 0.800),
	float3(0.863, 0.224, 0.0706),
	float3(1.00, 0.600, 0.00),
	float3(0.0627, 0.588, 0.0941),
	float3(0.600, 0.00, 0.600),
	float3(0.00, 0.600, 0.776),
	float3(0.867, 0.267, 0.467),
	float3(0.400, 0.667, 0.00),
	float3(0.722, 0.180, 0.180),
	float3(0.192, 0.388, 0.584)
};

float3 GetColorFromID(int Integer)
{
	float3 Color = float3(1.0f, 1.0f, 1.0f);
	if (Integer != CUBE_MAP_TREE_ID_RESERVED && Integer != INSTANCE_ID_RESERVED)
	{
		Color = ColorTemplates[Integer % 10];
	}
	return Color;
}

// Differentiate the start from the end of a LineSegment.
float3 EmbedDirection(float3 Color, int VertexIndex)
{
	float3 Ycc = RGBToYCoCg(Color);
	const int TriangleIndexColorMapping[6] = { 0, 1, 1, 0, 1, 0 };
	const float alpha = 0.1f;
	float EmbeddedY = Ycc.x * (alpha + (1 - alpha) * TriangleIndexColorMapping[VertexIndex % 6]);
	return YCoCgToRGB(float3(EmbeddedY, Ycc.y, Ycc.z));
}

// Hit normal color reflect the DFObjectID
float3 GetHitNormalColor(FHardwareDetailTraceSnapshot Snapshot, int VertexIndex)
{
	float3 Color = float3(0.01f, 0.01f, 0.01f);
	if (Snapshot.DFObjectID != INVALID_CUBE_MAP_TREE_ID)
	{
		Color = GetColorFromID(Snapshot.DFObjectID);
		Color = EmbedDirection(Color,VertexIndex);
	}
	return Color;
}

float3 GetHitSurfaceColor(FHardwareDetailTraceSnapshot Snapshot)
{
	//Set surface color to dark to indicate there is no valid id.
	//Make it a little brighter to distinguish black background.
	float3 Color = float3(0.01f, 0.01f, 0.01f);
	if (Snapshot.InstanceID != INVALID_INSTANCE_ID)
	{
		Color = GetColorFromID(Snapshot.InstanceID);
	}
	return Color;
}

// Hit surface with surface id.
// If the surface does not have a normal, it happens when the DF object is black, we use
// the inverse ray direction to draw the surface.
float3 DrawHitSurface(FHardwareDetailTraceSnapshot Snapshot, int VertexIndex)
{
	const float SurfaceHalfWidth = 5.0f;

	//Use the inverse ray direction if there is no surface normal.
	float3 SurfaceNormal = length(Snapshot.RayHitNormal) == 0 ? normalize(-Snapshot.RayDirection) : Snapshot.RayHitNormal;

	// Apply offset to avoid draw intersection with the hit geometry.
	float3 HitPositionWithOffset = Snapshot.RayHitPosition + Snapshot.RayHitNormal * 0.1f;	
	return GetVertexOfRectFromNormal(HitPositionWithOffset, SurfaceNormal, float2(SurfaceHalfWidth, SurfaceHalfWidth),VertexIndex);
}

float3 DrawLineSegment(float3 LineSegmentStartPoint, float3 LineSegmentEndPoint, float Thickness, int VertexIndex)
{
	return GetVertexOfRectFromLineSegment(LineSegmentStartPoint, LineSegmentEndPoint, Thickness, VertexIndex);
}

struct FVisualizeHardwareTracesVertexOutput
{
	float3 TraceLighting : TEXCOORD0;
};

void VisualizeHardwareTracesVS(
	uint VertexIndex : SV_VertexID,
	out FVisualizeHardwareTracesVertexOutput Output,
	out float4 OutPosition : SV_POSITION
)
{
	int PrimitiveID = VertexIndex / 6;
	float3 WorldPosition = float3(0,0,0);
	float3 LineSegmentColor = float3(1.0f, 0.0f, 0.0f);

	FHardwareDetailTraceSnapshot Snapshot = DecodeHardwareDetailTraceSnapshot();
	float LineSegmentThickness = 1.0f;
	float NormalLength = 10.0f;

	if (Snapshot.Mode == (Snapshot.Mode & VISUALIZATION_FLAG_DRAW_HIT_ONLY))
	{
		if (Snapshot.IsRayHit())
		{
			//draw the surface with InstanceID
			if (PrimitiveID == 0)
			{
				LineSegmentColor = GetHitSurfaceColor(Snapshot);
				WorldPosition = DrawHitSurface(Snapshot, VertexIndex);
			}
			
			if (PrimitiveID == 1)
			{
				// draw the surface normal with default red color.
				LineSegmentColor = GetHitNormalColor(Snapshot, VertexIndex);
				WorldPosition = DrawLineSegment(Snapshot.RayHitPosition, 
										Snapshot.RayHitPosition + Snapshot.RayHitNormal * NormalLength, LineSegmentThickness, VertexIndex);
			}
		}
	}
	else if (Snapshot.Mode == (Snapshot.Mode & VISUALIZATION_FLAG_DRAW_RAY))
	{
		//Surface: Surface rectangle of ray hit. Used to show the surface DF HitObject. 
		// It's black if there is no DF object Valid.
		if (PrimitiveID == 0 && Snapshot.IsRayHit())
		{
			LineSegmentColor = GetHitSurfaceColor(Snapshot);
			WorldPosition = DrawHitSurface(Snapshot, VertexIndex);
		}

		//LineSegment 1. Visualize the ray from the ray origin to the hitpoint or max reaching point if there is no hit
		if (PrimitiveID == 1)
		{
			//From actual hit to potential hit
			if (Snapshot.IsRayHit())
			{
				LineSegmentColor = float3(0.6f, 0.7f, 1.0f);
				LineSegmentColor = EmbedDirection(LineSegmentColor, VertexIndex);
				WorldPosition = DrawLineSegment(Snapshot.RayOrigin, Snapshot.RayHitPosition, LineSegmentThickness, VertexIndex);
			}
			else
			{
				LineSegmentColor = float3(0.0f, 0.0f, 1.0f);
				LineSegmentColor = EmbedDirection(LineSegmentColor, VertexIndex);
				WorldPosition = DrawLineSegment(Snapshot.RayOrigin,
					Snapshot.RayOrigin + Snapshot.RayDirection * Snapshot.TraceDistance, LineSegmentThickness, VertexIndex);
			}
			
		}

		//LineSegment 2. Visualize the normal at the ray origin without offset.
		if (PrimitiveID == 2)
		{
			LineSegmentColor = EmbedDirection(LineSegmentColor, VertexIndex);
			WorldPosition = DrawLineSegment(Snapshot.RayOrigin,
				Snapshot.RayOrigin + Snapshot.RayOriginNormal * NormalLength, LineSegmentThickness, VertexIndex);
		}

		//LineSegment 3. Visualize the bias offset starting from OriginwithoutOffset
		if (PrimitiveID == 3)
		{
			LineSegmentColor = float3(0.0f, 1.0f, 0.0f);
			LineSegmentColor = EmbedDirection(LineSegmentColor, VertexIndex);
			WorldPosition = DrawLineSegment(Snapshot.RayOriginWithoutBiasOffset, Snapshot.RayOrigin, LineSegmentThickness, VertexIndex);
		}

		//LineSegment 4. Visualize the normal at ray hit.
		if (PrimitiveID == 4 && Snapshot.IsRayHit())
		{
			LineSegmentColor = GetHitNormalColor(Snapshot,VertexIndex);
			WorldPosition = DrawLineSegment(Snapshot.RayHitPosition, 
							Snapshot.RayHitPosition + Snapshot.RayHitNormal * NormalLength, LineSegmentThickness, VertexIndex);
		}
	}

	OutPosition = mul(float4(WorldPosition, 1), View.WorldToClip);
	Output.TraceLighting = LineSegmentColor *View.PreExposure;
}

void VisualizeHardwareTracesPS(
	FVisualizeHardwareTracesVertexOutput Input,
	in float4 SVPos : SV_POSITION,
	out float4 OutColor : SV_Target0
)
{
	OutColor = float4(Input.TraceLighting, 0);
}

#endif
