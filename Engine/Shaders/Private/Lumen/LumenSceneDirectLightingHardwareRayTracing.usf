// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../MortonCode.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"

#ifndef LUMEN_HARDWARE_RAYTRACING
#define LUMEN_HARDWARE_RAYTRACING 0
#endif // LUMEN_HARDWARE_RAYTRACING

#ifndef LUMEN_HARDWARE_INLINE_RAYTRACING
#define LUMEN_HARDWARE_INLINE_RAYTRACING 0
#endif // LUMEN_HARDWARE_INLINE_RAYTRACING

#if LUMEN_HARDWARE_RAYTRACING || LUMEN_HARDWARE_INLINE_RAYTRACING
#include "LumenHardwareRayTracingCommon.ush"
#endif // LUMEN_HARDWARE_RAYTRACING || LUMEN_HARDWARE_INLINE_RAYTRACING

#include "LumenCardTile.ush"
#define SUPPORT_CONTACT_SHADOWS 0
#include "../DeferredLightingCommon.ush"
#include "LumenSceneDirectLighting.ush"

Buffer<uint> DispatchLightTilesIndirectArgs;
RWBuffer<uint> RWHardwareRayTracingIndirectArgs;

[numthreads(1, 1, 1)]
void LumenDirectLightingHardwareRayTracingIndirectArgsCS()
{
	RWHardwareRayTracingIndirectArgs[0] = CARD_TILE_SIZE * CARD_TILE_SIZE;
	RWHardwareRayTracingIndirectArgs[1] = DispatchLightTilesIndirectArgs[0];
	RWHardwareRayTracingIndirectArgs[2] = 1;

#if DIM_INLINE_RAYTRACING
	// For RayTraceDispatchIndirect we dispatch in threads but for DispatchIndirectComputeShader we dispatch in thread groups.
	// We need to adjust it to get the same number of threads running.
	RWHardwareRayTracingIndirectArgs[0] = (RWHardwareRayTracingIndirectArgs[0] + INLINE_RAY_TRACING_THREAD_GROUP_SIZE_X - 1) / INLINE_RAY_TRACING_THREAD_GROUP_SIZE_X;
	RWHardwareRayTracingIndirectArgs[1] = (RWHardwareRayTracingIndirectArgs[1] + INLINE_RAY_TRACING_THREAD_GROUP_SIZE_Y - 1) / INLINE_RAY_TRACING_THREAD_GROUP_SIZE_Y;
#endif
}

#if LUMEN_HARDWARE_RAYTRACING || LUMEN_HARDWARE_INLINE_RAYTRACING

RaytracingAccelerationStructure TLAS;

Buffer<uint2> ShadowTraceTileData;
Buffer<int> VirtualShadowMapIds;

uint TranslucentSkipCount;
uint MaxTraversalIterations;
uint GroupCount;
uint LightOffset;

uint LumenLightType;
float MaxTraceDistance;
float FarFieldMaxTraceDistance;
float3 FarFieldReferencePos;

float SurfaceBias;
float SlopeScaledSurfaceBias;

#if LUMEN_HARDWARE_INLINE_RAYTRACING
StructuredBuffer<FHitGroupRootConstants> HitGroupData;
#endif // LUMEN_HARDWARE_INLINE_RAYTRACING

StructuredBuffer<uint> LightTileAllocator;
StructuredBuffer<uint2> LightTiles;

LUMEN_HARDWARE_RAY_TRACING_ENTRY(LumenSceneDirectLightingHardwareRayTracing)
{
	uint2 CoordInCardTile = uint2(DispatchThreadIndex.x % CARD_TILE_SIZE, DispatchThreadIndex.x / CARD_TILE_SIZE);

#if DIM_INDIRECT_DISPATCH
	uint LightTileIndex = DispatchThreadIndex.y;
#else
	for (uint LightTileIndex = DispatchThreadIndex.y; LightTileIndex < LightTileAllocator[0]; LightTileIndex += GroupCount)
#endif
	{
		const FLightTile LightTile = UnpackLightTile(LightTiles[LightTileIndex]);
		uint2 TexelInCardPageCoord = LightTile.TileCoord * CARD_TILE_SIZE + CoordInCardTile;

		const FLumenLight LumenLight = LoadLumenLight(LightTile.LightIndex);

		if (all(CoordInCardTile < CARD_TILE_SIZE))
		{
			FShadowMaskRay ShadowMaskRay;
			ReadShadowMaskRayRW(LightTileIndex, CoordInCardTile, ShadowMaskRay);

			// Trace visibility ray
			if (!ShadowMaskRay.bShadowFactorComplete)
			{
				FLumenCardPageData CardPage = GetLumenCardPageData(LightTile.CardPageIndex);
				FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
				float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * (TexelInCardPageCoord + 0.5f);
				float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * (TexelInCardPageCoord + 0.5f);

				float Depth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;
				float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);
				float3 WorldNormal = DecodeSurfaceCacheNormal(Card, Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalPointClampedSampler, AtlasUV, 0).xy);
				float3 TranslatedWorldPosition = WorldPosition - LWCHackToFloat(PrimaryView.PreViewTranslation);

				float3 L = LumenLight.DeferredLightData.Direction;
				float3 ToLight = L;
				float NearFieldTMax = MaxTraceDistance;
				float FarFieldTMax = FarFieldMaxTraceDistance;

				if (LumenLight.Type != LIGHT_TYPE_DIRECTIONAL)
				{
					ToLight = LumenLight.DeferredLightData.TranslatedWorldPosition - TranslatedWorldPosition;
					float LengthToLight = length(ToLight);
					NearFieldTMax = min(NearFieldTMax, LengthToLight);
					FarFieldTMax = min(FarFieldTMax, LengthToLight);
					L = normalize(ToLight);
				}

				RayDesc Ray;
				const float2 RandSample = 0.5;

#if 0
				bool bIsValid = GenerateOcclusionRay(LumenLight.Type, LightParameters, WorldPosition, WorldNormal, RandSample,
					Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
#else

				const float BiasScale = 1.0;
				Ray.Origin = GetCardWorldPositionForShadowing(WorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, BiasScale);
				Ray.Direction = L;
#endif

				{
					FRayCone RayCone = (FRayCone)0;
					bool bCullBackFacingTriangles = false;
					FRayTracedLightingContext Context = CreateRayTracedLightingContext(
						TLAS,
						RayCone,
						CoordInCardTile,
						CoordInCardTile.x, // dummy coordinate
						bCullBackFacingTriangles,
						TranslucentSkipCount,
						MaxTraversalIterations);

					// Shadows don't need closest hit distance
					Context.bAcceptFirstHitAndEndSearch = true;

#if LUMEN_HARDWARE_INLINE_RAYTRACING
					Context.HitGroupData = HitGroupData;
#endif // LUMEN_HARDWARE_INLINE_RAYTRACING

					FLumenMinimalPayload Payload;

					bool bHit = false;
#if ENABLE_FAR_FIELD_TRACING
					{
						// Rebase origin and point-source direction for far-field rays
						RayDesc FarFieldRay;
						FarFieldRay.Origin = WorldPosition + FarFieldReferencePos;
						FarFieldRay.Direction = Ray.Direction;
						FarFieldRay.TMin = NearFieldTMax;
						FarFieldRay.TMax = FarFieldTMax;

						Context.InstanceMask = RAY_TRACING_MASK_FAR_FIELD;
						Context.bSkipClosestHitShader = true;
						FLumenMinimalRayResult MinimalRayResult = TraceLumenMinimalRay(FarFieldRay, Context, Payload);
						bHit = MinimalRayResult.bHit || !MinimalRayResult.bCompleted;

						Context.bSkipClosestHitShader = false;
					}
#endif // ENABLE_FAR_FIELD_TRACING
					if (!bHit)
					{
						Ray.TMin = 0;
						Ray.TMax = NearFieldTMax;
						Context.InstanceMask = RAY_TRACING_MASK_OPAQUE;
						FLumenMinimalRayResult MinimalRayResult = TraceLumenMinimalRay(Ray, Context, Payload);
						bHit = MinimalRayResult.bHit || !MinimalRayResult.bCompleted;
					}

					ShadowMaskRay.ShadowFactor = bHit ? 0.0f : 1.0f;
				}

				ShadowMaskRay.bShadowFactorComplete = true;

				WriteShadowMaskRay(ShadowMaskRay, LightTileIndex, CoordInCardTile);
			}
		}
	}
}

#endif // LUMEN_HARDWARE_RAYTRACING