// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../MortonCode.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenCardUpdate.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"

#ifndef LUMEN_HARDWARE_RAYTRACING
#define LUMEN_HARDWARE_RAYTRACING 0
#endif // LUMEN_HARDWARE_RAYTRACING

#if LUMEN_HARDWARE_RAYTRACING
#include "LumenHardwareRayTracingCommon.ush"
#endif // LUMEN_HARDWARE_RAYTRACING

#include "LumenCardTile.ush"
#define SUPPORT_CONTACT_SHADOWS 0
#include "../DeferredLightingCommon.ush"
#include "LumenSceneDirectLighting.ush"

#if LUMEN_HARDWARE_RAYTRACING

RaytracingAccelerationStructure TLAS;

Buffer<uint2> ShadowTraceTileData;
Buffer<int> VirtualShadowMapIds;

uint TranslucentSkipCount;
uint GroupCount;
uint LightOffset;

uint LumenLightType;
float MaxTraceDistance;
float SurfaceBias;
float SlopeScaledSurfaceBias;

StructuredBuffer<uint> CardTileAllocator;
StructuredBuffer<uint> CardTileData;
uint MaxCardTilesPerScatterInstance;
uint CardScatterInstanceIndex;

RAY_TRACING_ENTRY_RAYGEN(LumenSceneDirectLightingHardwareRayTracingRGS)
{
	uint ThreadIndex = DispatchRaysIndex().x;
	uint GroupIndex = DispatchRaysIndex().y * CARD_TILE_SIZE * CARD_TILE_SIZE;
	uint GroupStride = GroupCount * CARD_TILE_SIZE * CARD_TILE_SIZE;

	uint2 CoordInCardTile = uint2(ThreadIndex % CARD_TILE_SIZE, ThreadIndex / CARD_TILE_SIZE);

	for (uint CardTileIndex = DispatchRaysIndex().y; CardTileIndex < CardTileAllocator[CardScatterInstanceIndex]; CardTileIndex += GroupCount)
	{
		FCardTileData CardTile = UnpackCardTileData(CardTileData[CardScatterInstanceIndex * MaxCardTilesPerScatterInstance + CardTileIndex]);
		uint2 TexelInCardPageCoord = CardTile.TileCoord * CARD_TILE_SIZE + CoordInCardTile;

		if (all(CoordInCardTile < CARD_TILE_SIZE))
		{
			FShadowMaskRay ShadowMaskRay;
			ReadShadowMaskRayRW(CardTileIndex, CoordInCardTile, ShadowMaskRay);

			// Trace visibility ray
			if (!ShadowMaskRay.bShadowFactorComplete)
			{
				FLumenCardPageData CardPage = GetLumenCardPageData(CardTile.CardPageIndex);
				FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
				float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * (TexelInCardPageCoord + 0.5f);
				float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * (TexelInCardPageCoord + 0.5f);

				float Depth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;
				float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);
				float3 WorldNormal = DecodeSurfaceCacheNormal(Card, Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalPointClampedSampler, AtlasUV, 0).xy);

				FDeferredLightData LightData = LoadLightData(LumenLightType);

				float3 L = LightData.Direction;
				float3 ToLight = L;
				float TMax = MaxTraceDistance;

				if (LumenLightType != LIGHT_TYPE_DIRECTIONAL && LightData.bRadialLight)
				{
					ToLight = LightData.Position - WorldPosition;
					TMax = min(TMax, length(ToLight));
					L = normalize(ToLight);
				}

				RayDesc Ray;
				const float2 RandSample = 0.5;

#if 0
				bool bIsValid = GenerateOcclusionRay(LumenLightType, LightParameters, WorldPosition, WorldNormal, RandSample,
					Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
#else

				const float BiasScale = 1.0;
				Ray.Origin = GetCardWorldPositionForShadowing(WorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, BiasScale);
				Ray.Direction = L;
				Ray.TMin = 0;
				Ray.TMax = TMax;
#endif

				{
					FRayCone RayCone = (FRayCone)0;
					bool bCullBackFacingTriangles = false;
					FRayTracedLightingContext Context = CreateRayTracedLightingContext(
						TLAS,
						RayCone,
						CoordInCardTile,
						CoordInCardTile.x, // dummy coordinate
						bCullBackFacingTriangles,
						TranslucentSkipCount);

					FLumenMinimalPayload Payload;
					bool bHit = TraceLumenMinimalRay(Ray, Context, Payload);
					ShadowMaskRay.ShadowFactor = bHit ? 0.0f : 1.0f;
				}

				ShadowMaskRay.bShadowFactorComplete = true;

				WriteShadowMaskRay(ShadowMaskRay, CardTileIndex, CoordInCardTile);
			}
		}
	}
}

#endif // LUMEN_HARDWARE_RAYTRACING