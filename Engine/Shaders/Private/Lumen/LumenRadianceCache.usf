// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadianceCache.usf
=============================================================================*/

#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../FastMath.ush"
#include "../DeferredShadingCommon.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheTracingCommon.ush"
#include "LumenScreenProbeCommon.ush"
#include "LumenScreenProbeImportanceSamplingShared.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void ClearProbeIndirectionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
}

RWBuffer<int> RWProbeFreeListAllocator;
RWBuffer<uint> RWProbeFreeList;
RWBuffer<uint> RWProbeLastUsedFrame;
RWStructuredBuffer<float4> RWProbeWorldOffset;
uint MaxNumProbes;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearProbeFreeListCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;

	if (ThreadIndex == 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (ThreadIndex < MaxNumProbes)
	{
		RWProbeFreeList[ThreadIndex] = 0;
		RWProbeLastUsedFrame[ThreadIndex] = 0;
		RWProbeWorldOffset[ThreadIndex] = 0;
	}
}

[numthreads(1, 1, 1)]
void MarkRadianceProbesUsedByVisualizeCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;
	
	// For visualize mode, generate probes around the camera position
	uint ClipmapIndex = GetRadianceProbeClipmap(View.WorldCameraOrigin);
	MarkPositionUsedInIndirectionTexture(View.WorldCameraOrigin, ClipmapIndex);
}

Texture3D<uint> LastFrameRadianceProbeIndirectionTexture;
float LastFrameRadianceProbeCoordToWorldPositionScale[RADIANCE_PROBE_MAX_CLIPMAPS];
float3 LastFrameRadianceProbeCoordToWorldPositionBias[RADIANCE_PROBE_MAX_CLIPMAPS];
uint FrameNumber;
uint NumFramesToKeepCachedProbes;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void UpdateCacheForUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		uint3 LastFrameProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);
		uint3 LastFrameProbeIndirectionTextureCoord = uint3(LastFrameProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, LastFrameProbeCoord.yz);
		uint LastFrameProbeIndex = LastFrameRadianceProbeIndirectionTexture.Load(uint4(LastFrameProbeIndirectionTextureCoord, 0));

		if (LastFrameProbeIndex != INVALID_PROBE_INDEX)
		{
			float3 ProbeWorldPosition = LastFrameProbeCoord * LastFrameRadianceProbeCoordToWorldPositionScale[ClipmapIndex] + LastFrameRadianceProbeCoordToWorldPositionBias[ClipmapIndex];
			int3 ProbeCoord = ProbeWorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

			bool bReused = false;

			if (all(ProbeCoord > 0) && all(ProbeCoord < (int3)RadianceProbeClipmapResolution))
			{
				uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
				uint ProbeUsedMarker = RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord];
				uint LastUsedFrameNumber = RWProbeLastUsedFrame[LastFrameProbeIndex];

				if (ProbeUsedMarker == USED_PROBE_INDEX || FrameNumber - LastUsedFrameNumber < NumFramesToKeepCachedProbes)
				{
					bReused = true;

					if (ProbeUsedMarker == USED_PROBE_INDEX)
					{
						RWProbeLastUsedFrame[LastFrameProbeIndex] = FrameNumber;
					}
					RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord] = LastFrameProbeIndex;
				}
			}

			if (!bReused)
			{
				int FreeIndex;
				InterlockedAdd(RWProbeFreeListAllocator[0], 1, FreeIndex);
				RWProbeFreeList[FreeIndex] = LastFrameProbeIndex;
			}
		}
	}
}

RWBuffer<uint> RWProbeAllocator;
RWBuffer<uint> RWProbeTraceAllocator;
RWBuffer<float4> RWProbeTraceData;
Buffer<uint> ProbeFreeList;
uint ProbesUpdateEveryNFrames;
uint NumProbeTracesBudget;

bool ShouldUpdateProbeThisFrame(uint ProbeIndex, float3 ProbeWorldPosition)
{
	uint EffectiveProbesUpdateEveryNFrames = ProbesUpdateEveryNFrames;

	// If the new probes already exceeded the trace budget, greatly lower the update rate for existing probes
	if (RWProbeTraceAllocator[0] > NumProbeTracesBudget)
	{
		EffectiveProbesUpdateEveryNFrames *= 10;
	}
#define PROBE_UPDATE_BASED_ON_VIEWER_DISTANCE 1
#if PROBE_UPDATE_BASED_ON_VIEWER_DISTANCE
	float DistanceFromViewerSq = dot(View.WorldCameraOrigin - ProbeWorldPosition, View.WorldCameraOrigin - ProbeWorldPosition);
	uint ProbeUpdateFrequency = clamp((uint)pow(DistanceFromViewerSq * .001f, .25f), EffectiveProbesUpdateEveryNFrames, 100);

	return ProbeIndex % ProbeUpdateFrequency == FrameNumber % ProbeUpdateFrequency;
#else
	return ProbeIndex % EffectiveProbesUpdateEveryNFrames == FrameNumber % EffectiveProbesUpdateEveryNFrames;
#endif
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void AllocateUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		uint ProbeUsedMarker = RWRadianceProbeIndirectionTexture[DispatchThreadId];

		uint3 ProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);
		float3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPositionScale[ClipmapIndex] + RadianceProbeCoordToWorldPositionBias[ClipmapIndex];

		bool bTraceProbe;

		#if UPDATE_NEW_PROBES_PASS
			// Trace cache misses in the first pass
			bTraceProbe = ProbeUsedMarker == USED_PROBE_INDEX;
		#else
			// Retrace cache hits in the second pass
			bTraceProbe = ProbeUsedMarker != INVALID_PROBE_INDEX && ProbeUsedMarker != USED_PROBE_INDEX && ShouldUpdateProbeThisFrame(ProbeUsedMarker, ProbeWorldPosition);
		#endif

		if (bTraceProbe)
		{
			uint ProbeIndex;

			if (ProbeUsedMarker == USED_PROBE_INDEX)
			{
			#if PERSISTENT_CACHE
				int NumFree;
				InterlockedAdd(RWProbeFreeListAllocator[0], -1, NumFree);

				if (NumFree > 0)
				{
					ProbeIndex = ProbeFreeList[NumFree - 1];
				}
				else
				{
					InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
				}
			#else
				InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
			#endif
				RWProbeLastUsedFrame[ProbeIndex] = FrameNumber;
			}
			else
			{
				ProbeIndex = ProbeUsedMarker;
			}

			if (ProbeIndex < MaxNumProbes)
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = ProbeIndex;

				uint TraceIndex;
				InterlockedAdd(RWProbeTraceAllocator[0], 1, TraceIndex);

				RWProbeTraceData[TraceIndex] = float4(ProbeWorldPosition, asfloat((ClipmapIndex << 24) | ProbeIndex));
			}
			else
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
			}
		}
	}
}

RWBuffer<uint> RWNumNewProbes;

[numthreads(1, 1, 1)]
void StoreNumNewProbesCS()
{
	RWNumNewProbes[0] = RWProbeTraceAllocator[0];
}

[numthreads(1, 1, 1)]
void ClampProbeFreeListAllocatorCS()
{
	if (RWProbeFreeListAllocator[0] < 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (RWProbeFreeListAllocator[0] > (int)MaxNumProbes)
	{
		RWProbeFreeListAllocator[0] = (int)MaxNumProbes;
	}
}

// Must match C++
#define NUM_RADIANCE_PROBE_PDF_COEFFICIENTS (NUM_PDF_SH_COEFFICIENTS + 1)

RWBuffer<uint> RWClearProbePDFsIndirectArgs;
RWBuffer<uint> RWGenerateProbeTraceTilesIndirectArgs;
RWBuffer<uint> RWProbeTraceTileAllocator;
RWBuffer<uint> RWFilterProbesIndirectArgs;
RWBuffer<uint> RWCalculateProbeIrradianceIndirectArgs;
RWBuffer<uint> RWPrepareProbeOcclusionIndirectArgs;
RWBuffer<uint> RWFixupProbeBordersIndirectArgs;
Buffer<uint> ProbeTraceAllocator;
uint ClearProbePDFGroupSize;
uint TraceFromProbesGroupSizeXY;
uint FilterProbesGroupSizeXY;

[numthreads(1, 1, 1)]
void SetupProbeIndirectArgsCS()
{
	uint NumProbesToTrace = ProbeTraceAllocator[0];

	RWClearProbePDFsIndirectArgs[0] = (NumProbesToTrace * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS + ClearProbePDFGroupSize - 1) / ClearProbePDFGroupSize;
	RWClearProbePDFsIndirectArgs[1] = 1;
	RWClearProbePDFsIndirectArgs[2] = 1;

	RWGenerateProbeTraceTilesIndirectArgs[0] = 1;
	RWGenerateProbeTraceTilesIndirectArgs[1] = 1;
	RWGenerateProbeTraceTilesIndirectArgs[2] = NumProbesToTrace;

	RWProbeTraceTileAllocator[0] = 0;

	RWFilterProbesIndirectArgs[0] = (RadianceProbeResolution + FilterProbesGroupSizeXY - 1) / FilterProbesGroupSizeXY;
	RWFilterProbesIndirectArgs[1] = (RadianceProbeResolution + FilterProbesGroupSizeXY - 1) / FilterProbesGroupSizeXY;
	RWFilterProbesIndirectArgs[2] = NumProbesToTrace;

	RWCalculateProbeIrradianceIndirectArgs[0] = 1;
	RWCalculateProbeIrradianceIndirectArgs[1] = 1;
	RWCalculateProbeIrradianceIndirectArgs[2] = NumProbesToTrace;

	uint FinalOcclusionProbeResolution = OcclusionProbeResolution + 2 * (1 << FinalRadianceAtlasMaxMip);
	RWPrepareProbeOcclusionIndirectArgs[0] = (FinalOcclusionProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWPrepareProbeOcclusionIndirectArgs[1] = (FinalOcclusionProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWPrepareProbeOcclusionIndirectArgs[2] = NumProbesToTrace;

	RWFixupProbeBordersIndirectArgs[0] = (FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWFixupProbeBordersIndirectArgs[1] = (FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWFixupProbeBordersIndirectArgs[2] = NumProbesToTrace;
}

groupshared float4 SharedBestOffset[THREADGROUP_SIZE];
groupshared float4 SharedBestOffset2[THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ComputeProbeWorldOffsetsCS(
	uint3 GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;
	float3 ProbeWorldCenter;
	uint ClipmapIndex;
	uint ProbeIndex;
	GetProbeTraceDataNoOffset(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

	float DistanceToSurface = GetDistanceToNearestSurfaceGlobal(ProbeWorldCenter);
	float TooCloseThreshold = .05f * RadianceProbeCoordToWorldPositionScale[ClipmapIndex];

	if (DistanceToSurface < TooCloseThreshold)
	{
		float MaxVoxelOffset = .25f;

		uint X = GroupThreadId % 4;
		uint Y = (GroupThreadId % 16) / 4;
		uint Z = GroupThreadId / 16;
		{
			float3 Offset = (float3(X, Y, Z) * 2.0f / 3.0f - 1.0f) * MaxVoxelOffset * RadianceProbeCoordToWorldPositionScale[ClipmapIndex];
			float SampleDistanceToSurface = GetDistanceToNearestSurfaceGlobal(ProbeWorldCenter + Offset);
			SharedBestOffset[GroupThreadId] = float4(Offset, SampleDistanceToSurface);
		}

		GroupMemoryBarrierWithGroupSync();

		if (GroupThreadId < 8)
		{
			float4 BestOffset = SharedBestOffset[GroupThreadId * 8];

			for (uint i = 1; i < 8; i++)
			{
				if (SharedBestOffset[GroupThreadId * 8 + i].w > BestOffset.w)
				{
					BestOffset = SharedBestOffset[GroupThreadId * 8 + i];
				}
			}
		
			SharedBestOffset2[GroupThreadId] = BestOffset;
		}

		GroupMemoryBarrierWithGroupSync();

		if (GroupThreadId == 0)
		{
			float4 BestOffset = SharedBestOffset2[0];

			for (uint i = 1; i < 8; i++)
			{
				if (SharedBestOffset2[i].w > BestOffset.w)
				{
					BestOffset = SharedBestOffset2[i];
				}
			}

			if (BestOffset.w >= TooCloseThreshold)
			{
				RWProbeWorldOffset[ProbeIndex] = float4(BestOffset.xyz, 1);
			}
			else
			{
				RWProbeWorldOffset[ProbeIndex] = 0;
			}
		}
	}
	else
	{
		RWProbeWorldOffset[ProbeIndex] = 0;
	}
}

RWBuffer<int> RWRadianceProbeSH_PDF;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearProbePDFs(uint DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId / NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceIndex);
	uint CoefficientIndex = DispatchThreadId - ProbeTraceIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;

	RWRadianceProbeSH_PDF[ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS + CoefficientIndex] = 0;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScatterScreenProbeBRDFToRadianceProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	// PDF pass: Accumulate BRDF SH from screen probes
	// 	Scatter: Scatter BRDF SH into 8 radiance probes using atomics to buffer
	// 		Threadgroup per probe

	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);
		float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);

		if (SceneDepth > 0)
		{
			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

			uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

			if (ClipmapIndex < NumRadianceProbeClipmaps)
			{
				int3 BottomCornerProbeCoord = WorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex] - .5f;
				int3 IndirectionTextureCoord = BottomCornerProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);
				uint ProbeIndex = RadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(GroupThreadId.x & 0x1, (GroupThreadId.x & 0x2) >> 1, (GroupThreadId.x & 0x4) >> 2)];

				//@todo - skip probes which are cached this frame
				if (ProbeIndex != INVALID_PROBE_INDEX)
				{
					uint SHBaseIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * NUM_PDF_SH_COEFFICIENTS;
					uint ProbeSHBaseCoord = ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;

					for (uint CoefficientIndex = GroupThreadId.y; CoefficientIndex < NUM_RADIANCE_PROBE_PDF_COEFFICIENTS; CoefficientIndex += THREADGROUP_SIZE)
					{
						float Coefficient = 1.0f;
						float MaxValuePerThread = 1.0f;

						if (CoefficientIndex < NUM_PDF_SH_COEFFICIENTS)
						{
							Coefficient = BRDFProbabilityDensityFunctionSH[SHBaseIndex + CoefficientIndex];
							MaxValuePerThread = (float)0xFFFFFFFF / 100000.0f;
						}
						
						int QuantizedCoefficient = Coefficient * MaxValuePerThread;
						InterlockedAdd(RWRadianceProbeSH_PDF[ProbeSHBaseCoord + CoefficientIndex], QuantizedCoefficient);
					}
				}
			}
		}
	}
}

bool ShouldRefineTraceTile(uint2 TraceTileCoord, uint TraceTileResolution, float LevelPDFThreshold, FThreeBandSHVector BRDF)
{
	float2 ProbeUV = (TraceTileCoord + float2(.5f, .5f)) / float(TraceTileResolution);
	float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);
	FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
	float PDF = max(DotSH3(BRDF, DirectionSH), 0);

	bool bRefineTraceTile = PDF > LevelPDFThreshold;
	return bRefineTraceTile;
}

RWBuffer<uint2> RWProbeTraceTileData;
Buffer<int> RadianceProbeSH_PDF;
Buffer<uint> NumNewProbes;
float SupersampleTileBRDFThreshold;
float SupersampleDistanceFromCameraSq;
float DownsampleDistanceFromCameraSq;

RWTexture2D<float> RWDebugBRDFProbabilityDensityFunction;
uint DebugProbeBRDFOctahedronResolution;

groupshared uint SharedNumPendingTraceTiles;
groupshared uint2 PendingTraceTileList[THREADGROUP_SIZE * THREADGROUP_SIZE * 4];

groupshared uint SharedNumCompletedTraceTiles;
groupshared uint2 CompletedTraceTileList[THREADGROUP_SIZE * THREADGROUP_SIZE * 4];

groupshared uint GlobalTraceOffset;

FThreeBandSHVector GetBRDF_PDF(uint ProbeIndex)
{
	uint SHBaseIndex = ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;
	float DequantizeScale = 100000.0f / (float)0xFFFFFFFF;

	float TotalWeight = RadianceProbeSH_PDF[SHBaseIndex + 9];
	float DecodeScale = 0.0f;

	if (TotalWeight > 0.0f)
	{
		DecodeScale = DequantizeScale / TotalWeight;
	}

	FThreeBandSHVector BRDF;
	BRDF.V0.x = RadianceProbeSH_PDF[SHBaseIndex + 0] * DecodeScale;
	BRDF.V0.y = RadianceProbeSH_PDF[SHBaseIndex + 1] * DecodeScale;
	BRDF.V0.z = RadianceProbeSH_PDF[SHBaseIndex + 2] * DecodeScale;
	BRDF.V0.w = RadianceProbeSH_PDF[SHBaseIndex + 3] * DecodeScale;
	BRDF.V1.x = RadianceProbeSH_PDF[SHBaseIndex + 4] * DecodeScale;
	BRDF.V1.y = RadianceProbeSH_PDF[SHBaseIndex + 5] * DecodeScale;
	BRDF.V1.z = RadianceProbeSH_PDF[SHBaseIndex + 6] * DecodeScale;
	BRDF.V1.w = RadianceProbeSH_PDF[SHBaseIndex + 7] * DecodeScale;
	BRDF.V2.x = RadianceProbeSH_PDF[SHBaseIndex + 8] * DecodeScale;
	return BRDF;
}

void SubdivideTraceTileTree(
	uint ThreadIndex,
	uint BaseTraceTileResolution,
	uint NumLevels,
	uint ProbeTraceIndex,
	FThreeBandSHVector BRDF)
{
	uint PendingTraceListStartIndex = 0;

	// NumLevels must be a literal to allow the loop to unroll, otherwise we get this incorrect compile error from the DXC compiler:
	// error X3663: thread sync operation found in varying flow control, consider reformulating your algorithm so all threads will hit the sync simultaneously

	UNROLL
	for (uint Level = 1; Level < NumLevels; Level++)
	{
		uint TraceTileResolution = BaseTraceTileResolution << Level;
		uint NumPendingTraceTiles = SharedNumPendingTraceTiles;

		for (uint PendingTraceTileIndex = PendingTraceListStartIndex + ThreadIndex; PendingTraceTileIndex < NumPendingTraceTiles; PendingTraceTileIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
		{
			uint2 TraceTileCoord = UnpackTraceTileInfo(PendingTraceTileList[PendingTraceTileIndex]);

			if (Level < (NumLevels - 1) && ShouldRefineTraceTile(TraceTileCoord, TraceTileResolution, SupersampleTileBRDFThreshold, BRDF))
			{
				uint TileBaseIndex;
				InterlockedAdd(SharedNumPendingTraceTiles, 4, TileBaseIndex);
				PendingTraceTileList[TileBaseIndex + 0] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 0), Level + 1, ProbeTraceIndex);
				PendingTraceTileList[TileBaseIndex + 1] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 0), Level + 1, ProbeTraceIndex);
				PendingTraceTileList[TileBaseIndex + 2] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 1), Level + 1, ProbeTraceIndex);
				PendingTraceTileList[TileBaseIndex + 3] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 1), Level + 1, ProbeTraceIndex);
			}
			else
			{
				uint TileIndex;
				InterlockedAdd(SharedNumCompletedTraceTiles, 1, TileIndex);
				CompletedTraceTileList[TileIndex] = PackTraceTileInfo(TraceTileCoord, Level, ProbeTraceIndex);
			}
		}

		GroupMemoryBarrierWithGroupSync();

		PendingTraceListStartIndex = NumPendingTraceTiles;
	}
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateProbeTraceTilesCS(
	uint3 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;
	float3 ProbeWorldCenter;
	uint Unused;
	uint ProbeIndex;
	GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, Unused, ProbeIndex);

	float DistanceFromCameraSq = dot(View.WorldCameraOrigin - ProbeWorldCenter, View.WorldCameraOrigin - ProbeWorldCenter);


#define DEBUG_UNIFORM_TRACES 0
#if FORCE_UNIFORM_TRACES || DEBUG_UNIFORM_TRACES

	uint UniformLevel = 1;

#if FORCE_UNIFORM_TRACES
	if (DistanceFromCameraSq >= DownsampleDistanceFromCameraSq)
	{
		UniformLevel = 0;
	}
#endif
	
	uint TraceTileResolution = (RadianceProbeResolution / THREADGROUP_SIZE / 2) << UniformLevel;

	if (TraceTileResolution == 0)
	{
		TraceTileResolution = 1;
		UniformLevel = 1;
	}

	uint NumTraceTiles = TraceTileResolution * TraceTileResolution;
	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	if (ThreadIndex == 0)
	{
		InterlockedAdd(RWProbeTraceTileAllocator[0], NumTraceTiles, GlobalTraceOffset);
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint TraceTileIndex = ThreadIndex; TraceTileIndex < NumTraceTiles; TraceTileIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
	{
		uint2 TraceTileCoord = uint2(TraceTileIndex % TraceTileResolution, TraceTileIndex / TraceTileResolution);
		RWProbeTraceTileData[GlobalTraceOffset + TraceTileIndex] = PackTraceTileInfo(TraceTileCoord, UniformLevel, ProbeTraceIndex);
	}

#else

	// Ray gen pass:
	// 	Clear trace tile list
	// 	For each level [0 - 2] test PDF at tile center, issue trace tile if below threshold, otherwise subdivide and queue for next level
	// 	Write out all trace tiles for indirect dispatch

	if (all(GroupThreadId.xy == 0))
	{
		SharedNumCompletedTraceTiles = 0;
		SharedNumPendingTraceTiles = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint NumLevels = 1;

	// Calculate subdivision level for the probe
	// Level 0 is half of RadianceProbeResolution
	if ((ProbeTraceIndex < NumProbeTracesBudget || ProbeTraceIndex >= NumNewProbes[0]) && DistanceFromCameraSq < DownsampleDistanceFromCameraSq)
	{
		NumLevels = DistanceFromCameraSq < SupersampleDistanceFromCameraSq ? 3 : 2;
	}

	FThreeBandSHVector BRDF = GetBRDF_PDF(ProbeIndex);

	uint BaseTraceTileResolution = RadianceProbeResolution / THREADGROUP_SIZE / 2;

	// Queue trace tiles for level 0
	if (all(GroupThreadId.xy < BaseTraceTileResolution))
	{
		uint2 TraceTileCoord = GroupThreadId.xy;
		uint Level = 0;

		if (Level < (NumLevels - 1) && ShouldRefineTraceTile(TraceTileCoord, BaseTraceTileResolution, 0.0f, BRDF))
		{
			uint TileBaseIndex;
			InterlockedAdd(SharedNumPendingTraceTiles, 4, TileBaseIndex);

			PendingTraceTileList[TileBaseIndex + 0] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 0), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 1] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 0), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 2] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 1), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 3] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 1), 1, ProbeTraceIndex);
		}
		else
		{
			uint TileIndex;
			InterlockedAdd(SharedNumCompletedTraceTiles, 1, TileIndex);
			CompletedTraceTileList[TileIndex] = PackTraceTileInfo(TraceTileCoord, 0, ProbeTraceIndex);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	// Queue trace tiles for remaining levels
	if (NumLevels == 3)
	{
		SubdivideTraceTileTree(ThreadIndex, BaseTraceTileResolution, 3, ProbeTraceIndex, BRDF);
	}
	else if (NumLevels == 2)
	{
		SubdivideTraceTileTree(ThreadIndex, BaseTraceTileResolution, 2, ProbeTraceIndex, BRDF);
	}

	if (ThreadIndex == 0)
	{
		InterlockedAdd(RWProbeTraceTileAllocator[0], SharedNumCompletedTraceTiles, GlobalTraceOffset);
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint TraceTileIndex = ThreadIndex; TraceTileIndex < SharedNumCompletedTraceTiles; TraceTileIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
	{
		RWProbeTraceTileData[GlobalTraceOffset + TraceTileIndex] = CompletedTraceTileList[TraceTileIndex];
	}
	

	// 'vis DebugBRDFProbabilityDensityFunction uv1'
	#define VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC 0
	#if VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC
		uint2 TexelCoord = GroupThreadId.xy;

		if (all(TexelCoord < DebugProbeBRDFOctahedronResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (TexelCoord + ProbeTexelCenter) / (float)DebugProbeBRDFOctahedronResolution;
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

			FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
			float PDF = max(DotSH3(BRDF, DirectionSH), 0) * .001f;

			uint2 ProbeAtlasBaseCoord = DebugProbeBRDFOctahedronResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
			RWDebugBRDFProbabilityDensityFunction[ProbeAtlasBaseCoord + TexelCoord] = PDF;
		}
	#endif
#endif
}

RWBuffer<uint> RWTraceProbesIndirectArgs;
RWBuffer<uint> RWSortProbeTraceTilesIndirectArgs;
RWBuffer<uint> RWRadianceCacheHardwareRayTracingIndirectArgs;
uint SortTraceTilesGroupSize;

[numthreads(1, 1, 1)]
void SetupTraceFromProbesCS()
{
	uint NumProbeTraceTiles = ProbeTraceTileAllocator[0];

	// Decompose the dispatch group layout into 2d to work around hitting D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65k) with a 1d layout,
	// which manifests as flickering during Force Full Update

	RWTraceProbesIndirectArgs[0] = TRACE_TILE_GROUP_STRIDE;
	RWTraceProbesIndirectArgs[1] = (NumProbeTraceTiles + TRACE_TILE_GROUP_STRIDE - 1) / TRACE_TILE_GROUP_STRIDE;
	RWTraceProbesIndirectArgs[2] = 1;

	RWSortProbeTraceTilesIndirectArgs[0] = (NumProbeTraceTiles + SortTraceTilesGroupSize - 1) / SortTraceTilesGroupSize;
	RWSortProbeTraceTilesIndirectArgs[1] = 1;
	RWSortProbeTraceTilesIndirectArgs[2] = 1;

	RWRadianceCacheHardwareRayTracingIndirectArgs[0] = RADIANCE_CACHE_TRACE_TILE_SIZE_1D;
	RWRadianceCacheHardwareRayTracingIndirectArgs[1] = NumProbeTraceTiles;
	RWRadianceCacheHardwareRayTracingIndirectArgs[2] = 1;
}

#ifndef SORT_TILES_THREADGROUP_SIZE
#define SORT_TILES_THREADGROUP_SIZE 1
#endif

#define NUM_DIRECTION_BINS_2D 8
#define NUM_DIRECTION_BINS_1D (NUM_DIRECTION_BINS_2D * NUM_DIRECTION_BINS_2D)
groupshared uint SharedNumTraceTileBins[NUM_DIRECTION_BINS_1D];
groupshared uint SharedTraceTileBinOffset[NUM_DIRECTION_BINS_1D];

[numthreads(SORT_TILES_THREADGROUP_SIZE, 1, 1)]
void SortProbeTraceTilesCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	// Clear bins to 0
	for (uint BinIndex = GroupThreadId; BinIndex < NUM_DIRECTION_BINS_1D; BinIndex += SORT_TILES_THREADGROUP_SIZE)
	{
		SharedNumTraceTileBins[BinIndex] = 0; 
		SharedTraceTileBinOffset[BinIndex] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint TraceTileIndex = GroupId * SORT_TILES_THREADGROUP_SIZE + GroupThreadId;

	// Count how many trace tiles in each direction bin
	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D;
		uint2 DirectionalBin = ProbeTexelCoord * NUM_DIRECTION_BINS_2D / TraceResolution;

		//@todo - also bin by Morton encoded position
		uint FinalBinIndex = DirectionalBin.y * NUM_DIRECTION_BINS_2D + DirectionalBin.x;

		InterlockedAdd(SharedNumTraceTileBins[FinalBinIndex], 1);
	}

	GroupMemoryBarrierWithGroupSync();

	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileData = ProbeTraceTileData[TraceTileIndex];

		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(TraceTileData, TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D;
		uint2 DirectionalBin = ProbeTexelCoord * NUM_DIRECTION_BINS_2D / TraceResolution;

		uint FinalBinIndex = DirectionalBin.y * NUM_DIRECTION_BINS_2D + DirectionalBin.x;

		uint SortedTraceTileOffset;

		// Calculate our sorted offset by adding up all the bins before us
		{
			InterlockedAdd(SharedTraceTileBinOffset[FinalBinIndex], 1, SortedTraceTileOffset);

			for (uint BinIndex = 0; BinIndex < FinalBinIndex; BinIndex++)
			{
				SortedTraceTileOffset += SharedNumTraceTileBins[BinIndex];
			}
		}

		// Write out to the sorted position
		RWProbeTraceTileData[GroupId * SORT_TILES_THREADGROUP_SIZE + SortedTraceTileOffset] = TraceTileData;
	}
}

float StepFactor;
float VoxelStepFactor;
float MinSampleRadius;
float MaxMeshSDFTraceDistance;

FConeTraceResult TraceForProbeTexel(FConeTraceInput TraceInput)
{
	FConeTraceResult TraceResult;
	TraceResult = (FConeTraceResult)0;
	TraceResult.Lighting = 0.0;
	TraceResult.Transparency = 1.0;
	TraceResult.OpaqueHitDistance = TraceInput.MaxTraceDistance;

	ConeTraceLumenSceneVoxels(TraceInput, TraceResult);

#if TRACE_DISTANT_SCENE
	if (TraceResult.Transparency > .01f)
	{
		FConeTraceResult DistantTraceResult;
		ConeTraceLumenDistantScene(TraceInput, DistantTraceResult);
		TraceResult.Lighting += DistantTraceResult.Lighting * TraceResult.Transparency;
		TraceResult.Transparency *= DistantTraceResult.Transparency;
	}
#endif

#if ENABLE_DYNAMIC_SKY_LIGHT
	if (ReflectionStruct.SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;
		float Roughness = TanConeAngleToRoughness(tan(TraceInput.ConeAngle));

		TraceResult.Lighting = TraceResult.Lighting + GetSkyLightReflection(TraceInput.ConeDirection, Roughness, SkyAverageBrightness) * TraceResult.Transparency;
	}
#endif

	return TraceResult;
}

groupshared float3 SharedTraceRadiance[RADIANCE_CACHE_TRACE_TILE_SIZE_2D][RADIANCE_CACHE_TRACE_TILE_SIZE_2D];
groupshared float SharedTraceHitDistance[RADIANCE_CACHE_TRACE_TILE_SIZE_2D][RADIANCE_CACHE_TRACE_TILE_SIZE_2D];

[numthreads(RADIANCE_CACHE_TRACE_TILE_SIZE_2D, RADIANCE_CACHE_TRACE_TILE_SIZE_2D, 1)]
void TraceFromProbesCS(
	uint3 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint TraceTileIndex = GroupId.y * TRACE_TILE_GROUP_STRIDE + GroupId.x;

	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;


		float3 ProbeWorldCenter;
		uint ClipmapIndex;
		uint ProbeIndex;
		GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

		if (all(ProbeTexelCoord < TraceResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(TraceResolution);
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

			float FinalMinTraceDistance = max(MinTraceDistance, GetRadianceProbeTMin(ClipmapIndex));
			float FinalMaxTraceDistance = MaxTraceDistance;
			float EffectiveStepFactor = StepFactor;

			// Evenly distributing the sphere solid angle among all cones instead of based on Octahedron distortion
			float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(TraceResolution * TraceResolution));

			FConeTraceInput TraceInput;
			TraceInput.Setup(
				ProbeWorldCenter, WorldConeDirection,
				ConeHalfAngle, MinSampleRadius,
				FinalMinTraceDistance, FinalMaxTraceDistance,
				EffectiveStepFactor);
			TraceInput.VoxelStepFactor = VoxelStepFactor;

			bool bContinueCardTracing = false;

			TraceInput.VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(FinalMinTraceDistance, FinalMaxTraceDistance, MaxMeshSDFTraceDistance, bContinueCardTracing);

			FConeTraceResult TraceResult = TraceForProbeTexel(TraceInput);

			SharedTraceRadiance[GroupThreadId.y][GroupThreadId.x] = TraceResult.Lighting;

			#if RADIANCE_CACHE_STORE_DEPTHS
				SharedTraceHitDistance[GroupThreadId.y][GroupThreadId.x] = TraceResult.OpaqueHitDistance;
			#endif
		}

		GroupMemoryBarrierWithGroupSync();

		uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

		if (TraceResolution < RadianceProbeResolution)
		{
			uint UpsampleFactor = RadianceProbeResolution / TraceResolution;
			ProbeAtlasBaseCoord += (RADIANCE_CACHE_TRACE_TILE_SIZE_2D * TraceTileCoord + GroupThreadId.xy) * UpsampleFactor;

			float3 Lighting = SharedTraceRadiance[GroupThreadId.y][GroupThreadId.x];

			for (uint Y = 0; Y < UpsampleFactor; Y++)
			{
				for (uint X = 0; X < UpsampleFactor; X++)
				{
					RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = Lighting;
				}
			}

			#if RADIANCE_CACHE_STORE_DEPTHS
				float HitDistance = min(SharedTraceHitDistance[GroupThreadId.y][GroupThreadId.x], MaxHalfFloat);

				for (uint Y = 0; Y < UpsampleFactor; Y++)
				{
					for (uint X = 0; X < UpsampleFactor; X++)
					{
						RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = HitDistance;
					}
				}
			#endif
		}
		else
		{
			uint DownsampleFactor = TraceResolution / RadianceProbeResolution;
			uint WriteTileSize = RADIANCE_CACHE_TRACE_TILE_SIZE_2D / DownsampleFactor;

			if (all(GroupThreadId.xy < WriteTileSize))
			{
				float3 Lighting = 0;

				for (uint Y = 0; Y < DownsampleFactor; Y++)
				{
					for (uint X = 0; X < DownsampleFactor; X++)
					{
						Lighting += SharedTraceRadiance[GroupThreadId.y * DownsampleFactor + Y][GroupThreadId.x * DownsampleFactor + X];
					}
				}

				ProbeAtlasBaseCoord += WriteTileSize * TraceTileCoord + GroupThreadId.xy;
				RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord] = Lighting / (float)(DownsampleFactor * DownsampleFactor);

				#if RADIANCE_CACHE_STORE_DEPTHS
					float HitDistance = MaxHalfFloat;

					for (uint Y = 0; Y < DownsampleFactor; Y++)
					{
						for (uint X = 0; X < DownsampleFactor; X++)
						{
							HitDistance = min(HitDistance, SharedTraceHitDistance[GroupThreadId.y * DownsampleFactor + Y][GroupThreadId.x * DownsampleFactor + X]);
						}
					}

					RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord] = HitDistance;
				#endif
			}
		}
	}
}

#define MAX_RAY_INTENSITY 10000.0f

Texture2D<float3> RadianceProbeAtlasTexture;
Texture2D<float> DepthProbeAtlasTexture;
float SpatialFilterMaxRadianceHitAngle;

groupshared uint SharedRadiance[4][THREADGROUP_SIZE][THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void FilterProbeRadianceWithGatherCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = GroupId.z;
	float3 ProbeWorldCenter;
	uint ClipmapIndex;
	uint ProbeIndex;
	GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

	uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

#define LOCAL_SCATTER_FILTER 0
#if LOCAL_SCATTER_FILTER

	// Load current radiance, store to groupshared
	// For each neighbor
	//	Load in matching tile, reproject, depth weight, accumulate with atomics
	//	Load in randomly sampled outlier regions, etc
	// Normalize and write out

	if (all(DispatchThreadId.xy < RadianceProbeResolution))
	{
		uint2 ProbeTexelCoord = DispatchThreadId.xy;
		float3 Lighting = RadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord].xyz;

		float MaxValuePerThread = (float)0xFFFFFFFF / ((float)THREADGROUP_SIZE * THREADGROUP_SIZE);
		float LightingQuantizeScale = MaxValuePerThread / MAX_RAY_INTENSITY;
		uint3 QuantizedLighting = Lighting * LightingQuantizeScale;
		uint QuantizedWeight = 1.0f * MaxValuePerThread;
		SharedRadiance[0][GroupThreadId.y][GroupThreadId.x] = QuantizedLighting.x;
		SharedRadiance[1][GroupThreadId.y][GroupThreadId.x] = QuantizedLighting.y;
		SharedRadiance[2][GroupThreadId.y][GroupThreadId.x] = QuantizedLighting.z;
		SharedRadiance[3][GroupThreadId.y][GroupThreadId.x] = QuantizedWeight;
	}

	GroupMemoryBarrierWithGroupSync();

	int3 ProbeCoord = ProbeWorldCenter * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];
	uint2 RandSeed = Rand3DPCG16(int3(ProbeWorldCenter / 10.0f)).xy;
	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	int3 Offsets[6];
	Offsets[0] = int3(-1, 0, 0);
	Offsets[1] = int3(1, 0, 0);
	Offsets[2] = int3(0, -1, 0);
	Offsets[3] = int3(0, 1, 0);
	Offsets[4] = int3(0, 0, -1);
	Offsets[5] = int3(0, 0, 1);

	for (uint OffsetIndex = 0; OffsetIndex < 6; OffsetIndex++)
	{
		int3 NeighborCoord = ProbeCoord + Offsets[OffsetIndex];

		if (all(NeighborCoord >= 0) && all(NeighborCoord < (int3)RadianceProbeClipmapResolution))
		{
			uint NeighborProbeIndex = GetProbeIndexFromIndirectionTexture(NeighborCoord, ClipmapIndex);

			if (NeighborProbeIndex != INVALID_PROBE_INDEX)
			{
				uint2 NeighborProbeAtlasBaseCoord = RadianceProbeResolution * uint2(NeighborProbeIndex % ProbeAtlasResolutionInProbes.x, NeighborProbeIndex / ProbeAtlasResolutionInProbes.x);
				float2 GroupCenter = (GroupId.xy + .5f) * (float)THREADGROUP_SIZE;
				float ExtraKernelTexels = 2.0f;
				//int2 SampleCoord = GroupCenter + (Hammersley16(ThreadIndex, THREADGROUP_SIZE * THREADGROUP_SIZE, RandSeed) - .5f) * (THREADGROUP_SIZE + 2.0f * ExtraKernelTexels);
				int2 SampleCoord = DispatchThreadId.xy;
				uint2 ProbeTexelCoord = (SampleCoord + RadianceProbeResolution) % RadianceProbeResolution;
				float NeighborRadianceDepth = DepthProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord];

				float2 ProbeTexelCenter = float2(0.5, 0.5);
				float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / (float)RadianceProbeResolution;
				float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

				float3 NeighborWorldPosition = GetProbeWorldPosition(NeighborCoord, ClipmapIndex, NeighborProbeIndex);
				float3 NeighborHitPosition = NeighborWorldPosition + WorldConeDirection * NeighborRadianceDepth;
				float3 ToNeighborHit = NeighborHitPosition - ProbeWorldCenter;
				uint2 ProbeTexelCoordForNeighborHit = DirectionToOctahedralMap(ToNeighborHit) * RadianceProbeResolution;
				float ProbeDepthForNeighborHit = DepthProbeAtlasTexture[ProbeTexelCoordForNeighborHit + ProbeAtlasBaseCoord];
				float VoxelRadius = sqrt(3.0f) / WorldPositionToRadianceProbeCoordScale[ClipmapIndex];

				float DistanceWeight = 1.0f;

				if (ProbeDepthForNeighborHit < 1.0f * (RadianceProbeCoordToWorldPositionScale[ClipmapIndex] + VoxelRadius))
				{
					//@todo - need to trace through neighbor probe depths to see if the ray is occluded near the origin to stop leaking
					DistanceWeight = 0;
				}

				float Weight = DistanceWeight;
				float3 Lighting = RadianceProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord].xyz * Weight;
				int2 SharedMemoryCoord = ProbeTexelCoordForNeighborHit - GroupId.xy * THREADGROUP_SIZE;

				if (Weight > 0.0f && all(SharedMemoryCoord >= 0 && SharedMemoryCoord < THREADGROUP_SIZE))
				{
					float MaxValuePerThread = (float)0xFFFFFFFF / ((float)THREADGROUP_SIZE * THREADGROUP_SIZE);
					float LightingQuantizeScale = MaxValuePerThread / MAX_RAY_INTENSITY;
					uint3 QuantizedLighting = Lighting * LightingQuantizeScale;
					uint QuantizedWeight = Weight * MaxValuePerThread;

					InterlockedAdd(SharedRadiance[0][SharedMemoryCoord.y][SharedMemoryCoord.x], QuantizedLighting.x);
					InterlockedAdd(SharedRadiance[1][SharedMemoryCoord.y][SharedMemoryCoord.x], QuantizedLighting.y);
					InterlockedAdd(SharedRadiance[2][SharedMemoryCoord.y][SharedMemoryCoord.x], QuantizedLighting.z);
					InterlockedAdd(SharedRadiance[3][SharedMemoryCoord.y][SharedMemoryCoord.x], QuantizedWeight);
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint2 ProbeTexelCoord = DispatchThreadId.xy;

	if (all(ProbeTexelCoord < RadianceProbeResolution))
	{
		uint3 QuantizedLighting = uint3(
			SharedRadiance[0][GroupThreadId.y][GroupThreadId.x],
			SharedRadiance[1][GroupThreadId.y][GroupThreadId.x],
			SharedRadiance[2][GroupThreadId.y][GroupThreadId.x]);

		float MaxValuePerThread = (float)0xFFFFFFFF / ((float)THREADGROUP_SIZE * THREADGROUP_SIZE);
		float LightingDequantizeScale = MAX_RAY_INTENSITY / MaxValuePerThread;
		float3 Lighting = QuantizedLighting * LightingDequantizeScale;
		float TotalWeight = SharedRadiance[3][GroupThreadId.y][GroupThreadId.x] / MaxValuePerThread;
		RWRadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord] = Lighting / TotalWeight;
	}
#else

	uint2 ProbeTexelCoord = DispatchThreadId.xy;

	if (all(ProbeTexelCoord < RadianceProbeResolution))
	{
		float3 ProbeWorldCenter;
		uint ClipmapIndex;
		uint ProbeIndex;
		GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

		uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
		float3 Lighting = RadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord].xyz;
		float HitDistance = DepthProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord];
		float TotalWeight = 1.0f;

		float2 ProbeTexelCenter = float2(0.5, 0.5);
		float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / (float)RadianceProbeResolution;
		float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

		int3 ProbeCoord = ProbeWorldCenter * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		int3 Offsets[6];
		Offsets[0] = int3(-1, 0, 0);
		Offsets[1] = int3(1, 0, 0);
		Offsets[2] = int3(0, -1, 0);
		Offsets[3] = int3(0, 1, 0);
		Offsets[4] = int3(0, 0, -1);
		Offsets[5] = int3(0, 0, 1);

		for (uint OffsetIndex = 0; OffsetIndex < 6; OffsetIndex++)
		{
			int3 NeighborCoord = ProbeCoord + Offsets[OffsetIndex];

			if (all(NeighborCoord >= 0) && all(NeighborCoord < (int3)RadianceProbeClipmapResolution))
			{
				uint NeighborProbeIndex = GetProbeIndexFromIndirectionTexture(NeighborCoord, ClipmapIndex);

				if (NeighborProbeIndex != INVALID_PROBE_INDEX)
				{
					uint2 NeighborProbeAtlasBaseCoord = RadianceProbeResolution * uint2(NeighborProbeIndex % ProbeAtlasResolutionInProbes.x, NeighborProbeIndex / ProbeAtlasResolutionInProbes.x);
					float NeighborRadianceDepth = DepthProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord];
					float3 NeighborWorldPosition = GetProbeWorldPosition(NeighborCoord, ClipmapIndex, NeighborProbeIndex);

					float OcclusionWeight = 1.0f;

					{
						// Test a nearby position along the neighbor ray's path, if occluded then discard the neighbor radiance to reduce leaking
						// We can't test occlusion of the neighbor probe, because it is closer than GetRadianceProbeTMin
						float VoxelRadius = sqrt(3.0f) / WorldPositionToRadianceProbeCoordScale[ClipmapIndex];
						float OcclusionDistance = max(GetRadianceProbeTMin(ClipmapIndex), VoxelRadius);
						float3 NeighborOcclusionTestPosition = NeighborWorldPosition + 2 * OcclusionDistance * WorldConeDirection;
						float3 ToNeighborOcclusionPosition = NeighborOcclusionTestPosition - ProbeWorldCenter;
						uint2 ProbeTexelCoordForNeighborOcclusionPosition = DirectionToOctahedralMap(ToNeighborOcclusionPosition) * RadianceProbeResolution;
						float ProbeDepthForNeighborOcclusionPosition = DepthProbeAtlasTexture[ProbeTexelCoordForNeighborOcclusionPosition + ProbeAtlasBaseCoord];

						if (ProbeDepthForNeighborOcclusionPosition * ProbeDepthForNeighborOcclusionPosition < dot(ToNeighborOcclusionPosition, ToNeighborOcclusionPosition))
						{
							OcclusionWeight = 0.0f;
						}
					}

					// Clamp neighbor's hit distance to our own.  This helps preserve contact shadows, as a long neighbor hit distance will cause a small NeighborAngle and bias toward distant lighting.
					if (HitDistance >= 0)
					{
						NeighborRadianceDepth = min(NeighborRadianceDepth, HitDistance);
					}

					float3 NeighborHitPosition = NeighborWorldPosition + WorldConeDirection * NeighborRadianceDepth;
					float3 ToNeighborHit = NeighborHitPosition - ProbeWorldCenter;
					float NeighborAngle = acosFast(dot(ToNeighborHit, WorldConeDirection) / length(ToNeighborHit));
					float AngleWeight = 1.0f - saturate(NeighborAngle / SpatialFilterMaxRadianceHitAngle);

					float Weight = AngleWeight * OcclusionWeight;
					Lighting += RadianceProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord].xyz * Weight;
					TotalWeight += Weight;
				}
			}
		}

		RWRadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord] = Lighting / TotalWeight;
	}
#endif
}

RWTexture2D<float3> RWFinalIrradianceAtlas;

#define DOWNSAMPLED_RADIANCE_SIZE 8
groupshared float3 SharedDownsampledProbeRadiance[DOWNSAMPLED_RADIANCE_SIZE][DOWNSAMPLED_RADIANCE_SIZE];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CalculateProbeIrradianceCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;

	float3 ProbeWorldCenter;
	uint Unused;
	uint ProbeIndex;
	GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, Unused, ProbeIndex);

	uint DownsampleFactor = RadianceProbeResolution / DOWNSAMPLED_RADIANCE_SIZE;
	uint2 AtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

#define DOWNSAMPLE_TO_SHARED_MEMORY 1
#if DOWNSAMPLE_TO_SHARED_MEMORY
	for (uint DestY = GroupThreadId.y; DestY < DOWNSAMPLED_RADIANCE_SIZE; DestY += THREADGROUP_SIZE)
	{
		for (uint DestX = GroupThreadId.x; DestX < DOWNSAMPLED_RADIANCE_SIZE; DestX += THREADGROUP_SIZE)
		{
			float3 Radiance = 0;
			float TotalWeight = 0;

			for (uint YOffset = 0; YOffset < DownsampleFactor; YOffset++)
			{
				for (uint XOffset = 0; XOffset < DownsampleFactor; XOffset++)
				{
					uint2 SourceTexelCoord = uint2(DestX * DownsampleFactor + XOffset, DestY * DownsampleFactor + YOffset);
					float2 ProbeUV = (SourceTexelCoord + float2(.5f, .5f)) / (float)RadianceProbeResolution;
					float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, RadianceProbeResolution);
					Radiance += RadianceProbeAtlasTexture.Load(uint3(AtlasBaseCoord + SourceTexelCoord, 0)).xyz * SolidAngle;
					TotalWeight += SolidAngle;
				}
			}

			SharedDownsampledProbeRadiance[DestY][DestX] = Radiance / TotalWeight;
		}
	}

	GroupMemoryBarrierWithGroupSync();
#endif

	uint IrradianceBorderSize = 1;
	uint OutputIrradianceProbeResolution = IrradianceProbeResolution + 2 * IrradianceBorderSize;

	for (uint DestY = GroupThreadId.y; DestY < OutputIrradianceProbeResolution; DestY += THREADGROUP_SIZE)
	{
		for (uint DestX = GroupThreadId.x; DestX < OutputIrradianceProbeResolution; DestX += THREADGROUP_SIZE)
		{
			uint2 IrradianceProbeTexelCoord = OctahedralMapWrapBorder(uint2(DestX, DestY), OutputIrradianceProbeResolution, IrradianceBorderSize);
			float2 IrradianceProbeUV = (IrradianceProbeTexelCoord + float2(0.5f, 0.5f)) / (float)IrradianceProbeResolution;
			float3 IrradianceDirection = OctahedralMapToDirection(IrradianceProbeUV);
			float3 Irradiance = 0;
			float TotalWeight = 0;

			uint SourceProbeResolution = DOWNSAMPLE_TO_SHARED_MEMORY ? DOWNSAMPLED_RADIANCE_SIZE : RadianceProbeResolution;

			for (uint Y = 0; Y < SourceProbeResolution; Y++)
			{
				for (uint X = 0; X < SourceProbeResolution; X++)
				{
					float2 RadianceProbeUV = (float2(X, Y) + float2(0.5, 0.5)) / (float)SourceProbeResolution;
					float3 RadianceDirection = OctahedralMapToDirection(RadianceProbeUV);

					float NdotL = dot(IrradianceDirection, RadianceDirection);

					if (NdotL > 0)
					{
						float SolidAngle = OctahedralSolidAngleLUT(RadianceProbeUV, SourceProbeResolution);
						float SampleWeight = NdotL * SolidAngle;
						#if DOWNSAMPLE_TO_SHARED_MEMORY
							float3 Radiance = SharedDownsampledProbeRadiance[Y][X];
						#else
							float3 Radiance = RadianceProbeAtlasTexture.Load(uint3(AtlasBaseCoord + uint2(X, Y), 0)).xyz;
						#endif
						
						Irradiance += Radiance * SampleWeight;
						TotalWeight += SampleWeight;
					}
				}
			}

			Irradiance *= 1.0f / TotalWeight;

			uint2 IrradianceAtlasCoord = uint2(DestX, DestY) + OutputIrradianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

			RWFinalIrradianceAtlas[IrradianceAtlasCoord] = Irradiance;
		}
	}
}

RWTexture2D<float2> RWRadianceCacheProbeOcclusionAtlas;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void PrepareProbeOcclusionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceIndex);

	uint2 FinalDepthTexelCoord = DispatchThreadId.xy;
	uint FinalOcclusionProbeResolution = OcclusionProbeResolution + 2 * (1 << FinalRadianceAtlasMaxMip);

	if (all(FinalDepthTexelCoord < FinalOcclusionProbeResolution))
	{
		uint2 ProbeDepthTexelCoord = OctahedralMapWrapBorder(FinalDepthTexelCoord, FinalOcclusionProbeResolution, 1 << FinalRadianceAtlasMaxMip);
		uint2 AtlasBaseCoord = uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);;
		uint DownsampleFactor = RadianceProbeResolution / OcclusionProbeResolution;
		uint DepthKernel = DownsampleFactor * 1;

		float AccumulatedDepth = 0;
		float AccumulatedDepthSq = 0;

		for (uint YOffset = 0; YOffset < DepthKernel; YOffset++)
		{
			for (uint XOffset = 0; XOffset < DepthKernel; XOffset++)
			{
				uint2 SourceTexelCoord = uint2(ProbeDepthTexelCoord.x * DepthKernel + XOffset, ProbeDepthTexelCoord.y * DepthKernel + YOffset) % RadianceProbeResolution;
				uint2 AtlasCoord = SourceTexelCoord + RadianceProbeResolution * AtlasBaseCoord;

				float Depth = DepthProbeAtlasTexture.Load(uint3(AtlasCoord, 0));
				AccumulatedDepth += Depth;
				AccumulatedDepthSq += Depth * Depth;
			}
		}

		float Normalization = 1.0f / max(DepthKernel * DepthKernel, 1);
		AccumulatedDepth *= Normalization;
		AccumulatedDepthSq *= Normalization;

		uint2 FinalAtlasCoord = FinalDepthTexelCoord + FinalOcclusionProbeResolution * AtlasBaseCoord;
		RWRadianceCacheProbeOcclusionAtlas[FinalAtlasCoord] = float2(AccumulatedDepth, AccumulatedDepthSq);
	}
}

RWTexture2D<float3> RWFinalRadianceAtlas;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CopyProbesAndFixupBordersCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceIndex);

	uint2 FinalProbeTexelCoord = DispatchThreadId.xy;

	if (all(FinalProbeTexelCoord < FinalProbeResolution))
	{
		uint2 ProbeTexelCoord = OctahedralMapWrapBorder(FinalProbeTexelCoord, FinalProbeResolution, 1 << FinalRadianceAtlasMaxMip);
		uint2 AtlasCoord = ProbeTexelCoord + RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

		float3 Lighting = RadianceProbeAtlasTexture.Load(uint3(AtlasCoord, 0)).xyz;

		uint2 FinalAtlasCoord = FinalProbeTexelCoord + FinalProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

		RWFinalRadianceAtlas[FinalAtlasCoord] = Lighting;
	}
}

RWTexture2D<float3> RWFinalRadianceAtlasMip;
Texture2D<float3> FinalRadianceAtlasParentMip;
uint MipLevel; 

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateMipLevelCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceIndex);

	uint2 FinalProbeTexelCoord = DispatchThreadId.xy;
	uint ParentMipSize = FinalProbeResolution >> (MipLevel - 1);
	uint MipSize = FinalProbeResolution >> MipLevel;

	if (all(FinalProbeTexelCoord < MipSize))
	{
		uint2 ProbeCoord = uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
		uint2 ParentProbeTexelCoordBase = FinalProbeTexelCoord * 2;
		uint2 ParentFinalAtlasCoord = ParentProbeTexelCoordBase + ParentMipSize * ProbeCoord;

		float InvParentMipSize = 1.0f / ParentMipSize;
		float2 ProbeUV00 = (ParentProbeTexelCoordBase + float2(0, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV10 = (ParentProbeTexelCoordBase + float2(1, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV01 = (ParentProbeTexelCoordBase + float2(0, 1) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV11 = (ParentProbeTexelCoordBase + float2(1, 1) + float2(.5f, .5f)) * InvParentMipSize;

		float4 Weights;
		Weights.x = OctahedralSolidAngle(ProbeUV00, InvParentMipSize);
		Weights.y = OctahedralSolidAngle(ProbeUV10, InvParentMipSize);
		Weights.z = OctahedralSolidAngle(ProbeUV01, InvParentMipSize);
		Weights.w = OctahedralSolidAngle(ProbeUV11, InvParentMipSize);

		float3 Lighting = 0;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 0), 0)).xyz * Weights.x;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 0), 0)).xyz * Weights.y;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 1), 0)).xyz * Weights.z;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 1), 0)).xyz * Weights.w;

		uint2 FinalAtlasCoord = FinalProbeTexelCoord + MipSize * ProbeCoord;
		RWFinalRadianceAtlasMip[FinalAtlasCoord] = Lighting / dot(Weights, 1);
	}
}