// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenSceneDirectLighting.ush
=============================================================================*/

#pragma once

// Must match ELumenLightType in LumenSceneDirectLighting.cpp
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2
#define LIGHT_TYPE_RECT 3

groupshared uint SharedShadowMask[4];

struct FShadowMaskRay
{
	float ShadowFactor;
	bool bShadowFactorComplete;
};

void ReadSharedShadowMaskRay(uint2 CoordInCardTile, inout FShadowMaskRay ShadowMaskRay)
{
	uint BitOffset = 2 * (CoordInCardTile.x + CoordInCardTile.y * CARD_TILE_SIZE);

	uint ShadowMask = SharedShadowMask[BitOffset / 32];
	ShadowMask = (ShadowMask >> (BitOffset % 32)) & 0x3;

	ShadowMaskRay.ShadowFactor = ShadowMask & 0x1 ? 0.0f : 1.0f;
	ShadowMaskRay.bShadowFactorComplete = ShadowMask & 0x2 ? true : false;
}

void ReadShadowMaskRay(RWStructuredBuffer<uint> ShadowMaskBuffer, uint CardTileIndex, uint2 CoordInCardTile, inout FShadowMaskRay ShadowMaskRay)
{
	uint BitOffset = 2 * (CoordInCardTile.x + CoordInCardTile.y * CARD_TILE_SIZE);

	uint ShadowMask = ShadowMaskBuffer[4 * CardTileIndex + BitOffset / 32];
	ShadowMask = (ShadowMask >> (BitOffset % 32)) & 0x3;

	ShadowMaskRay.ShadowFactor = ShadowMask & 0x1 ? 0.0f : 1.0f;
	ShadowMaskRay.bShadowFactorComplete = ShadowMask & 0x2 ? true : false;
}

void ReadShadowMaskRay(StructuredBuffer<uint> ShadowMaskBuffer, uint CardTileIndex, uint2 CoordInCardTile, inout FShadowMaskRay ShadowMaskRay)
{
	uint BitOffset = 2 * (CoordInCardTile.x + CoordInCardTile.y * CARD_TILE_SIZE);

	uint ShadowMask = ShadowMaskBuffer[4 * CardTileIndex + BitOffset / 32];
	ShadowMask = (ShadowMask >> (BitOffset % 32)) & 0x3;

	ShadowMaskRay.ShadowFactor = ShadowMask & 0x1 ? 0.0f : 1.0f;
	ShadowMaskRay.bShadowFactorComplete = ShadowMask & 0x2 ? true : false;
}

void WriteSharedShadowMaskRay(FShadowMaskRay Ray, uint2 CoordInCardTile)
{
	if (Ray.bShadowFactorComplete)
	{
		uint Mask = 0;
		if (Ray.ShadowFactor <= 0.5f)
		{
			// Set first bit
			Mask |= 0x1;
		}
		if (Ray.bShadowFactorComplete)
		{
			// Set second bit
			Mask |= 0x2;
		}

		uint BitOffset = 2 * (CoordInCardTile.x + CoordInCardTile.y * CARD_TILE_SIZE);
		InterlockedOr(SharedShadowMask[BitOffset / 32], Mask << (BitOffset % 32));
	}
}

void WriteShadowMaskRay(FShadowMaskRay Ray, uint CardTileIndex, uint2 CoordInCardTile, RWStructuredBuffer<uint> ShadowMaskBuffer)
{
	if (Ray.bShadowFactorComplete)
	{
		uint Mask = 0;
		if (Ray.ShadowFactor <= 0.5f)
		{
			// Set first bit
			Mask |= 0x1;
		}
		if (Ray.bShadowFactorComplete)
		{
			// Set second bit
			Mask |= 0x2;
		}

		uint BitOffset = 2 * (CoordInCardTile.x + CoordInCardTile.y * CARD_TILE_SIZE);
		InterlockedOr(ShadowMaskBuffer[4 * CardTileIndex + BitOffset / 32], Mask << (BitOffset % 32));
	}
}

FDeferredLightData LoadLightData(uint LightType)
{
	FDeferredLightData LightData = (FDeferredLightData)0;

	LightData.Position = DeferredLightUniforms.Position;
	LightData.InvRadius = DeferredLightUniforms.InvRadius;
	LightData.Color = DeferredLightUniforms.Color;
	LightData.FalloffExponent = DeferredLightUniforms.FalloffExponent;
	LightData.Direction = DeferredLightUniforms.Direction;
	LightData.Tangent = DeferredLightUniforms.Tangent;
	LightData.SpotAngles = DeferredLightUniforms.SpotAngles;
	LightData.SourceRadius = DeferredLightUniforms.SourceRadius;
	LightData.SourceLength = DeferredLightUniforms.SourceLength;
	LightData.SoftSourceRadius = DeferredLightUniforms.SoftSourceRadius;
	LightData.SpecularScale = DeferredLightUniforms.SpecularScale;
	LightData.ContactShadowLength = abs(DeferredLightUniforms.ContactShadowLength);
	LightData.ContactShadowLengthInWS = DeferredLightUniforms.ContactShadowLength < 0.0f;
	LightData.DistanceFadeMAD = DeferredLightUniforms.DistanceFadeMAD;
	LightData.ShadowMapChannelMask = DeferredLightUniforms.ShadowMapChannelMask;
	LightData.ShadowedBits = DeferredLightUniforms.ShadowedBits;
	LightData.RectLightBarnCosAngle = DeferredLightUniforms.RectLightBarnCosAngle;
	LightData.RectLightBarnLength = DeferredLightUniforms.RectLightBarnLength;

	LightData.bInverseSquared = LightData.FalloffExponent == 0.0f;
	LightData.bRadialLight = LightType != LIGHT_TYPE_DIRECTIONAL;
	LightData.bSpotLight = LightType == LIGHT_TYPE_SPOT;
	LightData.bRectLight = LightType == LIGHT_TYPE_RECT;

	return LightData;
}