// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	VisualizeLumenCardScene.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
// Depth weighted OIT doesn't cover enough depth range for ConeTraceLumenDistantScene
// This has the side effect that card tracing for detail traces in this file don't get blended
#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../SHCommon.ush"
#include "../ShaderPrintCommon.ush"

uint3 CullGridSize;
uint CardGridPixelSizeShift;
uint4 ViewDimensions;
float PreviewConeAngle;
float TanPreviewConeAngle;
float VisualizeStepFactor;
float VoxelStepFactor;
float MinTraceDistance;
float MaxTraceDistance;
float MaxCardTraceDistanceForVoxelTracing;
float MaxCardTraceDistance;
int VisualizeClipmapIndex;
int VisualizeVoxelFaceIndex;
float CardInterpolateInfluenceRadius;

RWTexture2D<float4> RWSceneColor;
Buffer<uint> CulledCardGridHeader;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VisualizeQuadsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelPos = DispatchThreadId.xy + ViewDimensions.xy;
	float2 ViewportUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ViewportUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;
	float3 CameraVector = normalize(ScreenVector);
	float Noise = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8);

	float TanConeAngle = tan(PreviewConeAngle);
	float TraceDistance = MaxTraceDistance;
	bool bCoveredByRadianceCache = false;

#if RADIANCE_CACHE
	float Noise2 = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8 + 1);
	float Noise3 = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8 + 2);
	float3 ProbeNoise = float3(Noise, Noise2, Noise3);
	float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(View.WorldCameraOrigin, CameraVector, bCoveredByRadianceCache);
	TraceDistance = min(TraceDistance, ProbeOcclusionDistance);
#endif

	FConeTraceInput TraceInput;
	TraceInput.Setup(View.WorldCameraOrigin, CameraVector, PreviewConeAngle, .01f, MinTraceDistance, TraceDistance, VisualizeStepFactor);
	TraceInput.VoxelStepFactor = VoxelStepFactor;
	TraceInput.SDFStepFactor = lerp(.8f, 1.0f, Noise);

	float3 Debug = -1;

	bool bContinueCardTracing = false;
#if TRACE_CARDS
	bContinueCardTracing = true;
#endif

	TraceInput.VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(MinTraceDistance, TraceDistance, MaxCardTraceDistance, bContinueCardTracing);

#if RADIANCE_CACHE
	TraceInput.VoxelTraceStartDistance = min(TraceInput.VoxelTraceStartDistance, TraceDistance);
#endif

	int2 CellCoord = clamp((int2)PixelPos >> CardGridPixelSizeShift, int2(0, 0), (int2)CullGridSize.xy - 1);
	uint CardGridCellIndex = CellCoord.x + CellCoord.y * CullGridSize.x;

	TraceInput.NumMeshSDFs = NumGridCulledMeshSDFObjects[CardGridCellIndex];
	TraceInput.MeshSDFStartOffset = GridCulledMeshSDFObjectStartOffsetArray[CardGridCellIndex];
	TraceInput.CardInterpolateInfluenceRadius = CardInterpolateInfluenceRadius;
	//@todo - compute based on SDF voxel size, or card texel size
	TraceInput.CardInterpolateDepthVisibilityRadius = 10.0f;
	//Debug = TraceInput.NumMeshSDFs / 20.0f;

	FConeTraceResult TraceResult;

#if TRACE_CARDS
#define TRACE_MODE 2
#else
#define TRACE_MODE 1
#endif

#if TRACE_MODE == 0
	ConeTraceLumenCards(TraceInput, TraceResult);
#elif TRACE_MODE == 1
	ConeTraceVoxels(TraceInput, TraceResult);
#elif TRACE_MODE == 2

	TraceResult = (FConeTraceResult)0;
	TraceResult.Transparency = 1;

	ConeTraceLumenScene(TraceInput, TraceResult);
#endif

#if RADIANCE_CACHE
	TraceResult.Lighting += SampleRadianceCacheInterpolated(View.WorldCameraOrigin, CameraVector, PreviewConeAngle, ProbeNoise).xyz * TraceResult.Transparency;
	TraceResult.Transparency = 0.0f;
#else

	#define VISUALIZE_TRACE_DISTANT_SCENE 1
	#if VISUALIZE_TRACE_DISTANT_SCENE
		FConeTraceResult DistantTraceResult;
		ConeTraceLumenDistantScene(TraceInput, DistantTraceResult);
		TraceResult.Lighting += DistantTraceResult.Lighting * TraceResult.Transparency;
		TraceResult.Transparency *= DistantTraceResult.Transparency;
	#endif

	EvaluateSkyRadianceForCone(CameraVector, TanConeAngle, TraceResult);
#endif

	#if USE_PREEXPOSURE
		TraceResult.Lighting *= View.PreExposure;
	#endif

	float4 FinalColor = 0.0f;

	#define VISUALIZE_MODE 0
	#if VISUALIZE_MODE == 0
		FinalColor = float4(TraceResult.Lighting + float3(0 * (saturate(TraceResult.NumOverlaps / 20.0f)), 0, 0), 0);
	#elif VISUALIZE_MODE == 1
		FinalColor = float4(frac(TraceResult.OpaqueHitDistance.xxx / 100.0f), 0);
	#elif VISUALIZE_MODE == 2
		FinalColor = float4(TraceResult.Lighting + TraceResult.Debug, 0);
	#else 
		FinalColor = float4(TraceResult.NumSteps.xxx / 100.0f, 0);
	#endif

	if (any(Debug >= 0))
	{
		FinalColor = float4(Debug, 0);
	}

	RWSceneColor[PixelPos] = FinalColor;
}

StructuredBuffer<uint> GlobalDistanceFieldPageFreeListAllocatorBuffer;
uint GlobalDistanceFieldMaxPageNum;

[numthreads(1, 1, 1)]
void VisualizeStatsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	int NumFreePages = -1;
	if (GlobalDistanceFieldMaxPageNum > 0)
	{
		NumFreePages = GlobalDistanceFieldMaxPageNum - GlobalDistanceFieldPageFreeListAllocatorBuffer[0];
	}

	float2 Origin = float2(0.8, 0.2);
	float2 TextPos = Origin;
	TextPos = ShaderPrintSymbol(TextPos, _G_);
	TextPos = ShaderPrintSymbol(TextPos, _D_);
	TextPos = ShaderPrintSymbol(TextPos, _F_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _P_);
	TextPos = ShaderPrintSymbol(TextPos, _A_);
	TextPos = ShaderPrintSymbol(TextPos, _G_);
	TextPos = ShaderPrintSymbol(TextPos, _E_);
	TextPos = ShaderPrintSymbol(TextPos, _S_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintNewline(TextPos);
	TextPos.x = Origin.x;

	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _A_);
	TextPos = ShaderPrintSymbol(TextPos, _L_);
	TextPos = ShaderPrintSymbol(TextPos, _L_);
	TextPos = ShaderPrintSymbol(TextPos, _O_);
	TextPos = ShaderPrintSymbol(TextPos, _C_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, NumFreePages);
	TextPos = ShaderPrintNewline(TextPos);
	TextPos.x = Origin.x;

	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _M_);
	TextPos = ShaderPrintSymbol(TextPos, _A_);
	TextPos = ShaderPrintSymbol(TextPos, _X_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, GlobalDistanceFieldMaxPageNum);
}

uint3 VoxelLightingGridResolution;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VisualizeLumenVoxelsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelPos = DispatchThreadId.xy + ViewDimensions.xy;
	float2 ViewportUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ViewportUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;


	float4 LightingAndAlpha = float4(0, 0, 0, 1);
	uint TotalNumSteps = 0;

	float RayTime = 0.0f;
	float3 RayDirection = normalize(ScreenVector);
	float3 RayOrigin = View.WorldCameraOrigin + MinTraceDistance * RayDirection;
	int3 VoxelStep = (RayDirection < 0) ? int3(-1, -1, -1) : int3(1, 1, 1);

	uint VoxelClipmapIndex = VisualizeClipmapIndex >= 0 ? VisualizeClipmapIndex : 0;
	for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapLevels; ++ClipmapIndex)
	{
		bool bOutOfRange = any(abs(RayOrigin - ClipmapWorldCenter[ClipmapIndex].xyz) > ClipmapWorldExtent[ClipmapIndex].xyz);
		VoxelClipmapIndex = bOutOfRange ? ClipmapIndex + 1 : VoxelClipmapIndex;
	}

	float VoxelSize = ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].x;
	float3 ClipmapMin = ClipmapWorldCenter[VoxelClipmapIndex].xyz - ClipmapWorldExtent[VoxelClipmapIndex].xyz;
	float3 ClipmapMax = ClipmapWorldCenter[VoxelClipmapIndex].xyz + ClipmapWorldExtent[VoxelClipmapIndex].xyz;
	int3 VoxelCoord = VoxelLightingGridResolution * (RayOrigin - ClipmapMin) / (ClipmapMax - ClipmapMin);

	float3 VoxelMin = (VoxelCoord + 0.0f) * VoxelSize + ClipmapMin;
	float3 VoxelMax = (VoxelCoord + 1.0f) * VoxelSize + ClipmapMin;
	float3 MaxNegT = (VoxelMin - RayOrigin) / RayDirection;
	float3 MaxPosT = (VoxelMax - RayOrigin) / RayDirection;
	float3 NextVoxelFaceT = (RayDirection < 0) ? MaxNegT : MaxPosT;
	float3 VoxelFaceStepT = abs(VoxelSize / RayDirection);

	uint RayVoxelEntryFace = 6;
	uint StepIndex = 0;

	while (StepIndex < 512 && LightingAndAlpha.a > MIN_VOXEL_TRACE_TRANSPARENCY && VoxelClipmapIndex < NumClipmapLevels)
	{
		if (VoxelClipmapIndex >= NumClipmapLevels || (VisualizeClipmapIndex >= 0 && (uint)VisualizeClipmapIndex != VoxelClipmapIndex))
		{
			break;
		}

		if (RayTime > MaxTraceDistance)
		{
			break;
		}


		if (RayVoxelEntryFace < 6)
		{
			int3 LightingVolumeCoord = VoxelCoord;
			LightingVolumeCoord.y += VoxelLightingGridResolution * VoxelClipmapIndex;
			LightingVolumeCoord.z += VoxelLightingGridResolution * RayVoxelEntryFace;

			float4 StepLighting;
			StepLighting = VoxelLighting.Load(int4(LightingVolumeCoord, 0));

			if (StepLighting.w > 0.0f)
			{
				LightingAndAlpha.xyz = StepLighting.xyz;
				LightingAndAlpha.w = 0.0f;
				break;
			}
		}


		// Next step
		float VoxelFaceT = min3(NextVoxelFaceT.x, NextVoxelFaceT.y, NextVoxelFaceT.z);
		uint3 StepInc = int3(NextVoxelFaceT == VoxelFaceT.xxx);
		RayVoxelEntryFace = VoxelFaceFromStep(StepInc, VoxelStep);
		RayTime = VoxelFaceT;
		NextVoxelFaceT += StepInc * VoxelFaceStepT;
		VoxelCoord += StepInc * VoxelStep;


		// Next clipmap if we are out of bounds
		if (any(VoxelCoord < 0) || any(VoxelCoord >= VoxelLightingGridResolution))
		{
			++VoxelClipmapIndex;

			// #lumen_todo: it should just go back to the last face of the higher climap level
			float3 SamplePosition = RayOrigin + (RayTime - 2.0f * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w) * RayDirection;

			VoxelSize = ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].x;
			ClipmapMin = ClipmapWorldCenter[VoxelClipmapIndex].xyz - ClipmapWorldExtent[VoxelClipmapIndex].xyz;
			ClipmapMax = ClipmapWorldCenter[VoxelClipmapIndex].xyz + ClipmapWorldExtent[VoxelClipmapIndex].xyz;
			VoxelCoord = VoxelLightingGridResolution * (SamplePosition - ClipmapMin) / (ClipmapMax - ClipmapMin);

			VoxelMin = (VoxelCoord + 0.0f) * VoxelSize + ClipmapMin;
			VoxelMax = (VoxelCoord + 1.0f) * VoxelSize + ClipmapMin;
			MaxNegT = (VoxelMin - RayOrigin) / RayDirection;
			MaxPosT = (VoxelMax - RayOrigin) / RayDirection;
			NextVoxelFaceT = (RayDirection < 0) ? MaxNegT : MaxPosT;
			VoxelFaceStepT = abs(VoxelSize / RayDirection);
		}

		++StepIndex;
	}

	FConeTraceResult TraceResult = (FConeTraceResult)0;
	TraceResult.Lighting = LightingAndAlpha.xyz;
	TraceResult.Transparency = LightingAndAlpha.w;

	EvaluateSkyRadianceForCone(RayDirection, .01f, TraceResult);

	RWSceneColor[PixelPos] = float4(TraceResult.Lighting, 1.0f);
}