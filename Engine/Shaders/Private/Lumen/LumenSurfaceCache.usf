// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardSceneLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "../BRDF.ush"
#include "LumenCardCommon.ush"
#include "../BlockCompressionCommon.ush"
#include "../BCCompressionCommon.ush"

RWBuffer<uint> RWQuadAllocator;
RWBuffer<uint> RWQuadData;

float4 InfluenceSphere;
float3 LightPosition;
float3 LightDirection;
float LightRadius;
float CosConeAngle;
float SinConeAngle;

bool SphereIntersectCone(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin)
{
	float3 U = ConeVertex - (SphereCenterAndRadius.w / ConeAngleSin) * ConeAxis;
	float3 D = SphereCenterAndRadius.xyz - U;
	float DSizeSq = dot(D, D);
	float E = dot(ConeAxis, D);

	if (E > 0 && E * E >= DSizeSq * ConeAngleCos * ConeAngleCos)
	{
		D = SphereCenterAndRadius.xyz - ConeVertex;
		DSizeSq = dot(D, D);
		E = -dot(ConeAxis, D);

		if (E > 0 && E * E >= DSizeSq * ConeAngleSin * ConeAngleSin)
		{
			return DSizeSq <= SphereCenterAndRadius.w * SphereCenterAndRadius.w;
		}
		else
		{
			return true;
		}
	}

	return false;
}

void GetCardAABB(FLumenCardData LumenCardData, out float3 WorldCardCenter, out float3 WorldCardExtent)
{
	WorldCardCenter = LumenCardData.Origin;
	WorldCardExtent = mul(abs(LumenCardData.WorldToLocalRotation), LumenCardData.LocalExtent);
}

bool DoesLightAffectCardPage(FLumenCardPageData CardPage, FLumenCardData Card)
{
	float3 CardPageLocalCenter;
	float3 CardPageLocalExtent;
	GetCardPageLocalBBox(CardPage, Card, CardPageLocalCenter, CardPageLocalExtent);

	float3 CardPageWorldCenter = mul(Card.WorldToLocalRotation, CardPageLocalCenter) + Card.Origin;
	float3 CardPageWorldExtent = mul(abs(Card.WorldToLocalRotation), CardPageLocalExtent);
	float CardPageWorldBoundingSphere = length(CardPageLocalExtent);

	float3 LightInfluenceSphereLocalCenter = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);
	const float BoxDistanceSq = ComputeSquaredDistanceFromBoxToPoint(CardPageLocalCenter, CardPageLocalExtent, LightInfluenceSphereLocalCenter);	
	const bool bCardAffectedByInfluenceSphere = BoxDistanceSq < InfluenceSphere.w * InfluenceSphere.w;

#if SHAPE_TYPE == 0
	
	return true;

#elif SHAPE_TYPE == 1

	// Point light
	return bCardAffectedByInfluenceSphere;

#elif SHAPE_TYPE == 2

	float ConeAxisDistance = dot(CardPageWorldCenter - LightPosition, LightDirection);
	float2 ConeAxisDistanceMinMax = float2(ConeAxisDistance + CardPageWorldBoundingSphere, ConeAxisDistance - CardPageWorldBoundingSphere);

	// Spot light
	return bCardAffectedByInfluenceSphere
		&& SphereIntersectCone(float4(CardPageWorldCenter, CardPageWorldBoundingSphere), LightPosition, LightDirection, CosConeAngle, SinConeAngle)
		&& ConeAxisDistanceMinMax.x > 0 && ConeAxisDistanceMinMax.y < LightRadius;

#elif SHAPE_TYPE == 3

	// Rect light
	float4 BackPlane = float4(LightDirection, dot(LightPosition, LightDirection));
	float DistanceFromBoxCenterToPlane = dot(BackPlane.xyz, CardPageWorldCenter) - BackPlane.w;
	float MaxExtent = dot(CardPageWorldExtent, abs(BackPlane.xyz));
	bool bInFrontOfPlane = DistanceFromBoxCenterToPlane + MaxExtent > 0.0f;
	return bCardAffectedByInfluenceSphere && bInFrontOfPlane;

#endif
}

uint NumCardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderHashMap;
uint FrameId;
float CardLightingUpdateFrequencyScale;
uint CardLightingUpdateMinFrequency;

#define OPERATE_ON_CARD_TILES_TO_RENDER 0
#define OPERATE_ON_SCENE 1
#define OPERATE_ON_SCENE_FORCE_UPDATE_FOR_CARD_TILES_TO_RENDER 2

bool ShouldUpdateCardPageLighting(uint CardPageId, FLumenCardData Card)
{
#if OPERATE_ON_CARD_TILES_MODE == OPERATE_ON_CARD_TILES_TO_RENDER
	// Explicit list - update everything
	return true;
#else 

#if OPERATE_ON_CARD_TILES_MODE == OPERATE_ON_SCENE_FORCE_UPDATE_FOR_CARD_TILES_TO_RENDER
	// Operating on the whole scene - CardIds contains cards that must have their lighting updated this frame due to recapture

	#if 1
	{
		uint HashMapBucketId = CardPageId % (NUM_CARD_TILES_TO_RENDER_HASH_MAP_BUCKET_UINT32 * 32);
		uint HashMapUInt32Id = HashMapBucketId / 32;
		uint HashMapBitId = HashMapBucketId - HashMapUInt32Id * 32;

		uint HashMapUInt32 = CardPagesToRenderHashMap[HashMapUInt32Id];

		if (HashMapUInt32 & (1 << HashMapBitId))
		{
			return true;
		}
	}
	#else
	{
		for (uint i = 0; i < NumCardPagesToRenderIndices; i++)
		{
			if (CardPageId == CardPagesToRenderIndices[i])
			{
				return true;
			}
		}
	}
	#endif
#endif

	float3 CardSpaceViewPosition = mul(View.WorldCameraOrigin - Card.Origin, Card.WorldToLocalRotation);
	float DistanceFromViewerSq = ComputeSquaredDistanceFromBoxToPoint(0, Card.LocalExtent, CardSpaceViewPosition);
	uint CardLightingUpdateFrequency = clamp((uint)pow(DistanceFromViewerSq * CardLightingUpdateFrequencyScale, .25f), CardLightingUpdateMinFrequency, 100);

	//@todo - Better guarantees on even distribution of texels lit each frame
	return CardPageId % CardLightingUpdateFrequency == FrameId % CardLightingUpdateFrequency;
	
#endif
}

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 0
#endif

uint ScatterInstanceIndex;
uint MaxQuadsPerScatterInstance;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void CullCardPagesToShapeCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

#if OPERATE_ON_CARD_TILES_MODE == OPERATE_ON_CARD_TILES_TO_RENDER
	if (IndexInIndexBuffer < NumCardPagesToRenderIndices)
	{
		uint CardPageIndex = CardPagesToRenderIndices[IndexInIndexBuffer];
#else
	if (IndexInIndexBuffer < LumenCardScene.NumCardPages)
	{
		uint CardPageIndex = IndexInIndexBuffer;
#endif
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			if (Card.bVisible
				&& DoesLightAffectCardPage(CardPage, Card)
				&& ShouldUpdateCardPageLighting(CardPageIndex, Card))
			{
				uint QuadDataInsertIndex;
				InterlockedAdd(RWQuadAllocator[ScatterInstanceIndex], 1, QuadDataInsertIndex);

				QuadDataInsertIndex += MaxQuadsPerScatterInstance * ScatterInstanceIndex;

				uint Packed = CardPageIndex;
				RWQuadData[QuadDataInsertIndex] = Packed;
			}
		}
	}
}

Buffer<uint> QuadAllocator;
RWBuffer<uint> RWCardIndirectArgs;

uint TilesPerInstance;
uint MaxScatterInstanceCount;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void InitializeCardScatterIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ScatterInstanceIndex = DispatchThreadId.x;

	if (ScatterInstanceIndex < MaxScatterInstanceCount)
	{
		// sizeof(FRHIDrawIndexedIndirectParameters) / sizeof(uint32) == 5
		uint ArgOffset = ScatterInstanceIndex * 5;
		uint NumQuads = QuadAllocator[ScatterInstanceIndex];

		#if RECT_LIST_TOPOLOGY
		{
			// VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation
			RWCardIndirectArgs[0 + ArgOffset] = 4 * TilesPerInstance;
			RWCardIndirectArgs[1 + ArgOffset] = (NumQuads + TilesPerInstance - 1) / TilesPerInstance;
			RWCardIndirectArgs[2 + ArgOffset] = 0;
			RWCardIndirectArgs[3 + ArgOffset] = 0;
		}
		#else
		{
			// IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance
			RWCardIndirectArgs[0 + ArgOffset] = 6 * TilesPerInstance;
			RWCardIndirectArgs[1 + ArgOffset] = (NumQuads + TilesPerInstance - 1) / TilesPerInstance;
			RWCardIndirectArgs[2 + ArgOffset] = 0;
			RWCardIndirectArgs[3 + ArgOffset] = 0;
			RWCardIndirectArgs[4 + ArgOffset] = 0;
		}
		#endif
	}
}

Buffer<uint> QuadData;
float2 DownsampledInputAtlasSize;

Buffer<uint4> RectMinMaxBuffer;
float2 InvRectMinMaxResolution;

void RasterizeToCardsVS(
	float2 TexCoord : ATTRIBUTE0,
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	// Compute the actual instance id for when multiple tiles are packed into the vertex buffer
	uint EffectiveInstanceId = InstanceId * TilesPerInstance + VertexId / 4;

	uint BaseQuadOffset = MaxQuadsPerScatterInstance * ScatterInstanceIndex;
	uint NumQuads = QuadAllocator[ScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (EffectiveInstanceId < NumQuads)
	{
		uint QuadIndex = EffectiveInstanceId + BaseQuadOffset;
		uint CardPageIndex = QuadData[QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

		#if CLAMP_TO_INFLUENCE_SPHERE
		{
			float3 LocalSphereOrigin = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);

			float2 InvCardPageUVSize = 1.0f / (CardPage.CardUVRect.zw - CardPage.CardUVRect.xy);

			float2 SphereOriginCardUV = SamplePositonToCardUV(Card, LocalSphereOrigin.xy);
			float2 SphereOriginCardPageUV = (SphereOriginCardUV - CardPage.CardUVRect.xy) * InvCardPageUVSize;

			float2 SphereRadius = 0.5f * (InfluenceSphere.ww / Card.LocalExtent.xy) * InvCardPageUVSize;

			TexCoord = clamp(TexCoord, SphereOriginCardPageUV - SphereRadius, SphereOriginCardPageUV + SphereRadius);
		}
		#endif

		float2 ScreenUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		float2 AtlasUV = ScreenUV;

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[CardPageIndex].xyzw * InvRectMinMaxResolution.xyxy;
			AtlasUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[QuadIndex].xyzw * InvRectMinMaxResolution.xyxy;
			ScreenUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		// When sampling from a downsampled atlas we need to appropriately clamp input UVs to prevent bilinear reading outside of the valid area
		if (DownsampledInputAtlasSize.x > 0.0f)
		{
			float2 CardWidthInTexels = (CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy) * DownsampledInputAtlasSize;
			float2 ClampBorder = 0.5f / CardWidthInTexels;

			TexCoord = clamp(TexCoord, ClampBorder, 1.0f - ClampBorder);
			AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		}

		float2 ScreenPosition = float2(2.0f, -2.0f) * ScreenUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		float2 QuadCorner = -2.0f * TexCoord + 1.0f;
		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, TexCoord);
		CardInterpolants.CardPageIndex = CardPageIndex;
	}
}

RWTexture2D<uint4> RWAtlasBlock4;
RWTexture2D<uint2> RWAtlasBlock2;
Texture2D SourceAtlas;
float2 OneOverSourceAtlasSize;

#define SURFACE_LAYER_DEPTH 0
#define SURFACE_LAYER_ALBEDO 1
#define SURFACE_LAYER_OPACITY 2
#define SURFACE_LAYER_NORMAL 3
#define SURFACE_LAYER_EMISSIVE 4

void LumenCardCopyPS(
	float4 Position : SV_POSITION,
	float2 AtlasUV : TEXCOORD0
#if !COMPRESS
	, out float4 OutColor0 : SV_Target0
#endif
)
{
	uint2 WriteCoord = (uint2) Position.xy;

	#if SURFACE_LAYER == SURFACE_LAYER_DEPTH
	{
		#if COMPRESS
		{
			float BlockTexelsX[16];
			float BlockTexelsY[16];
			ReadBlockX(SourceAtlas, GlobalPointClampedSampler, AtlasUV - OneOverSourceAtlasSize, OneOverSourceAtlasSize, BlockTexelsX);

			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				// Reverse inverted Z from the HW depth buffer
				BlockTexelsX[TexelIndex] = 1.0f - BlockTexelsX[TexelIndex];

				// Store square depth for the variance depth test
				BlockTexelsY[TexelIndex] = BlockTexelsX[TexelIndex] * BlockTexelsX[TexelIndex];
			}

			RWAtlasBlock4[WriteCoord] = CompressBC5Block(BlockTexelsX, BlockTexelsY);
		}
		#else
		{
			float SourceDepth = Texture2DSampleLevel(SourceAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;
			// Reverse inverted Z from the HW depth buffer
			float Depth = 1.0f - SourceDepth;
			OutColor0 = float4(Depth, Depth * Depth, 0.0f, 0.0f);
		}
		#endif
	}
	#elif SURFACE_LAYER == SURFACE_LAYER_ALBEDO
	{
		#if COMPRESS
		{
			float3 BlockTexels[16];
			ReadBlockRGB(SourceAtlas, GlobalPointClampedSampler, AtlasUV - OneOverSourceAtlasSize, OneOverSourceAtlasSize, BlockTexels);
			RWAtlasBlock4[WriteCoord] = CompressBC7Block(BlockTexels);
		}
		#else
		{
			float3 Albedo = Texture2DSampleLevel(SourceAtlas, GlobalPointClampedSampler, AtlasUV, 0).xyz;
			OutColor0 = float4(Albedo, 0.0f);
		}
		#endif
	}
	#elif SURFACE_LAYER == SURFACE_LAYER_OPACITY
	{
		#if COMPRESS
		{
			float BlockTexels[16];
			ReadBlockAlpha(SourceAtlas, GlobalPointClampedSampler, AtlasUV - OneOverSourceAtlasSize, OneOverSourceAtlasSize, BlockTexels);
			RWAtlasBlock2[WriteCoord] = CompressBC4Block(BlockTexels);
		}
		#else
		{
			float3 Albedo = Texture2DSampleLevel(SourceAtlas, GlobalPointClampedSampler, AtlasUV, 0).xyz;
			OutColor0 = float4(Albedo, 0.0f);
		}
		#endif
	}
	#elif SURFACE_LAYER == SURFACE_LAYER_NORMAL
	{
		#if COMPRESS
		{
			float BlockTexelsX[16];
			float BlockTexelsY[16];
			ReadBlockXY(SourceAtlas, GlobalPointClampedSampler, AtlasUV - OneOverSourceAtlasSize, OneOverSourceAtlasSize, BlockTexelsX, BlockTexelsY);
			RWAtlasBlock4[WriteCoord] = CompressBC5Block(BlockTexelsX, BlockTexelsY);
		}
		#else
		{
			float3 Normal = Texture2DSampleLevel(SourceAtlas, GlobalPointClampedSampler, AtlasUV, 0).xyz;
			OutColor0 = float4(Normal.xy, 0.0f, 0.0f);
		}
		#endif
	}
	#elif SURFACE_LAYER == SURFACE_LAYER_EMISSIVE
	{
		#if COMPRESS
		{
			float3 BlockTexels[16];
			ReadBlockRGB(SourceAtlas, GlobalPointClampedSampler, AtlasUV - OneOverSourceAtlasSize, OneOverSourceAtlasSize, BlockTexels);
			RWAtlasBlock4[WriteCoord] = CompressBC6HBlock(BlockTexels);
		}
		#else
		{
			float3 Emissive = Texture2DSampleLevel(SourceAtlas, GlobalPointClampedSampler, AtlasUV, 0).xyz;
			OutColor0 = float4(Emissive, 0.0f);
		}
		#endif
	}
	#endif
}

float3 ClearValue;
uint2 OutputAtlasSize;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ClearCompressedAtlasCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 WriteCoord = DispatchThreadId.xy;
	if (all(WriteCoord < OutputAtlasSize))
	{
		#if SURFACE_LAYER == SURFACE_LAYER_DEPTH
		{
			float BlockTexelsX[16];
			float BlockTexelsY[16];
			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				BlockTexelsX[TexelIndex] = ClearValue.x;
				BlockTexelsY[TexelIndex] = ClearValue.y;
			}
			RWAtlasBlock4[WriteCoord] = CompressBC5Block(BlockTexelsX, BlockTexelsY);
		}
		#elif SURFACE_LAYER == SURFACE_LAYER_ALBEDO
		{
			float3 BlockTexels[16];
			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				BlockTexels[TexelIndex] = ClearValue;
			}
			RWAtlasBlock4[WriteCoord] = CompressBC7Block(BlockTexels);
		}
		#elif SURFACE_LAYER == SURFACE_LAYER_OPACITY
		{
			float BlockTexels[16];
			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				BlockTexels[TexelIndex] = ClearValue.x;
			}
			RWAtlasBlock2[WriteCoord] = CompressBC4Block(BlockTexels);
		}
		#elif SURFACE_LAYER == SURFACE_LAYER_NORMAL
		{
			float BlockTexelsX[16];
			float BlockTexelsY[16];
			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				BlockTexelsX[TexelIndex] = ClearValue.x;
				BlockTexelsY[TexelIndex] = ClearValue.y;
			}
			RWAtlasBlock4[WriteCoord] = CompressBC5Block(BlockTexelsX, BlockTexelsY);
		}
		#elif SURFACE_LAYER == SURFACE_LAYER_EMISSIVE
		{
			float3 BlockTexels[16];
			for (uint TexelIndex = 0; TexelIndex < 16; ++TexelIndex)
			{
				BlockTexels[TexelIndex] = ClearValue;
			}
			RWAtlasBlock4[WriteCoord] = CompressBC6HBlock(BlockTexels);
		}
		#endif
	}
}

Texture2D SourceDepthAtlas;

void LumenCardCopyDepthPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{
	float SourceDepth = Texture2DSampleLevel(SourceDepthAtlas, GlobalPointClampedSampler, CardInterpolants.AtlasUV, 0).x;

	// Reverse inverted Z from the HW depth buffer
	float Depth = 1.0f - SourceDepth;

	OutColor = float4(Depth, Depth * Depth, 0.0f, 0.0f);
}

Texture2D RadiosityAtlas;
Texture2D OpacityAtlas;

void LumenCardLightingInitializePS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{   
	float3 Radiosity = Texture2DSampleLevel(RadiosityAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	
	// Secure again strange values, as we are writing it to a persistent atlas with a feedback loop
	Radiosity = max(MakeFinite(Radiosity), float3(0.0f, 0.0f, 0.0f));
	OutColor = float4(Radiosity, 0);
}

Texture2D SrcAtlas;

void LumenCardCopyAtlasPS(
	FCardVSToPS CardInterpolants,
	out float4 OutValue : SV_Target0)
{
	float3 Value = Texture2DSampleLevel(SrcAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	OutValue = float4(Value, 0);
}

Texture2D AlbedoAtlas;
Texture2D EmissiveAtlas;
float DiffuseReflectivityOverride;

void LumenCardBlendAlbedoPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor0 : SV_Target0,
	out float4 OutColor1 : SV_Target1)
{
	float3 AlbedoSqr = Texture2DSampleLevel(AlbedoAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 DiffuseColor = AlbedoSqr * AlbedoSqr;

	if (DiffuseReflectivityOverride > 0.0f)
	{
		float DiffuseMaxComponent = max(DiffuseColor.r, max(DiffuseColor.g, DiffuseColor.b));
		DiffuseColor = saturate(DiffuseColor * max(DiffuseReflectivityOverride / max(DiffuseMaxComponent, .0001f), 1.0f));
	}

	float3 Emissive = Texture2DSampleLevel(EmissiveAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	OutColor0 = float4(Emissive, 0);
	OutColor1 = float4(Diffuse_Lambert(DiffuseColor), 0);
}

void ClearLumenCardsPS(
	out float4 OutAlbedo : SV_Target0,
	out float4 OutNormals : SV_Target1,
	out float4 OutEmissive : SV_Target2
)
{
	OutAlbedo = float4(0.0f, 0.0f, 0.0f, 0.0f);
	OutNormals = float4(0.0f, 0.0f, 0.0f, 0.0f);
	OutEmissive = float4(0.0f, 0.0f, 0.0f, 0.0f);
}