// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenOctahedralProbe.ush
=============================================================================*/

// Based on [Engelhardt et al. 2008, "Octahedron Environment Maps"]

float2 DirectionToOctahedralMap(float3 V)
{
	V /= (abs(V.x) + abs(V.y) + abs(V.z));
	V.xy = V.z >= 0.0f ? V.xy : ((1.0f - abs(V.yx)) * (V.xy >= 0.0f ? 1.0f : -1.0f));
	V.xy = V.xy * 0.5f + 0.5f;
	return V.xy;
}

float3 OctahedralMapToDirection(float2 UV)
{
	UV = UV * 2.0f - 1.0f;

	float3 V = float3(UV.x, UV.y, 1.0 - abs(UV.x) - abs(UV.y));
	float T = saturate(-V.z);
	V.xy += V.xy >= 0.0 ? -T : T;

	return normalize(V);
}

// Wrap around octahedral map for correct hardware bilinear filtering
uint2 OctahedralMapWrapBorder(uint2 TexelCoord, uint Resolution, uint BorderSize)
{
	if (TexelCoord.x < BorderSize)
	{
		TexelCoord.x = BorderSize - 1 + BorderSize - TexelCoord.x;
		TexelCoord.y = Resolution - 1 - TexelCoord.y;
	}
	if (TexelCoord.x >= Resolution - BorderSize)
	{
		TexelCoord.x = (Resolution - BorderSize) - (TexelCoord.x - (Resolution - BorderSize - 1));
		TexelCoord.y = Resolution - 1 - TexelCoord.y;
	}
	if (TexelCoord.y < BorderSize)
	{
		TexelCoord.y = BorderSize - 1 + BorderSize - TexelCoord.y;
		TexelCoord.x = Resolution - 1 - TexelCoord.x;
	}
	if (TexelCoord.y >= Resolution - BorderSize)
	{
		TexelCoord.y = (Resolution - BorderSize) - (TexelCoord.y - (Resolution - BorderSize - 1));
		TexelCoord.x = Resolution - 1 - TexelCoord.x;
	}

	return TexelCoord - BorderSize;
}

// Computes the spherical excess (solid angle) of a spherical triangle with vertices A, B, C as unit length vectors
// https://en.wikipedia.org/wiki/Spherical_trigonometry#Area_and_spherical_excess
float ComputeSphericalExcess(float3 A, float3 B, float3 C) {
    float CosAB = dot(A, B);
    float SinAB = 1.0f - CosAB * CosAB;
    float CosBC = dot(B, C);
    float SinBC = 1.0f - CosBC * CosBC;
    float CosCA = dot(C, A);
    float CosC = CosCA - CosAB * CosBC;
    float SinC = sqrt(SinAB * SinBC - CosC * CosC);
    float Inv = (1.0f - CosAB) * (1.0f - CosBC);
	return 2.0f * atan2(SinC, sqrt((SinAB * SinBC * (1.0f + CosBC) * (1.0f + CosAB)) / Inv) + CosC);
}

// TexelCoord should be centered on the octahedral texel, in the range [.5f, .5f + Resolution - 1]
float OctahedralSolidAngle(float2 TexelCoord, float InvResolution)
{
	float3 Direction10 = OctahedralMapToDirection(TexelCoord + float2(.5f, -.5f) * InvResolution);
	float3 Direction01 = OctahedralMapToDirection(TexelCoord + float2(-.5f, .5f) * InvResolution);

	float SolidAngle0 = ComputeSphericalExcess(
		OctahedralMapToDirection(TexelCoord + float2(-.5f, -.5f) * InvResolution), 
		Direction10,
		Direction01);

	float SolidAngle1 = ComputeSphericalExcess(
		OctahedralMapToDirection(TexelCoord + float2(.5f, .5f) * InvResolution), 
		Direction01,
		Direction10);

	return SolidAngle0 + SolidAngle1;
}
