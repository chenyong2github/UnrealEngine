// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadiosity.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "../MonteCarlo.ush"
#include "../FastMath.ush"
#include "LumenRadianceCacheCommon.ush"

#ifndef THREADGROUP_SIZE 
#define THREADGROUP_SIZE 0
#endif

Buffer<uint> QuadAllocator;
RWBuffer<uint> RWIndirectArgs;

[numthreads(1, 1, 1)]
void PlaceProbeIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	RWIndirectArgs[0] = (QuadAllocator[0] + THREADGROUP_SIZE - 1) / THREADGROUP_SIZE;
	RWIndirectArgs[1] = 1;
	RWIndirectArgs[2] = 1;
}

StructuredBuffer<float4> CardBuffer;
StructuredBuffer<float4> CardPageBuffer;
Buffer<uint> QuadData;

float StepFactor;
float MaxTraceDistance;
float VoxelStepFactor;
float MinTraceDistance;
float MaxMeshSDFTraceDistance;
float TanConeAngle;
float MinSampleRadius;
float SurfaceBias;
float DiffuseConeHalfAngle;
float TanDiffuseConeHalfAngle;

RWBuffer<uint> RWCardTraceBlockAllocator;
RWBuffer<uint4> RWCardTraceBlockData;
uint2 RadiosityAtlasSize;

// CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE * THREADS_PER_RADIOSITY_TEXEL must be <= THREADGROUP_SIZE
#define CARD_TRACE_BLOCK_SIZE 2

#if IRRADIANCE_CACHE
	#define THREADS_PER_RADIOSITY_TEXEL 1
#else
	#define THREADS_PER_RADIOSITY_TEXEL 8
#endif

#if THREADGROUP_SIZE > 0

groupshared uint NumBlocksShared[THREADGROUP_SIZE];
groupshared uint GlobalBlockStartOffset[THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SetupCardTraceBlocksCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
#define DISTRIBUTE_TRACEBLOCK_WRITES 1
#if DISTRIBUTE_TRACEBLOCK_WRITES

	if (DispatchThreadId.x < QuadAllocator[0])
	{
		uint CardPageId = QuadData[DispatchThreadId.x];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageId, CardPageBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint NumBlocks = NumBlocksXY.x * NumBlocksXY.y;
		NumBlocksShared[GroupThreadId.x] = NumBlocks;

		uint BlockStartOffset;
		InterlockedAdd(RWCardTraceBlockAllocator[0], NumBlocks, BlockStartOffset);
		GlobalBlockStartOffset[GroupThreadId.x] = BlockStartOffset;
	}
	else
	{
		NumBlocksShared[GroupThreadId.x] = 0;
		GlobalBlockStartOffset[GroupThreadId.x] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint GroupQuadIndex = 0; GroupQuadIndex < THREADGROUP_SIZE; GroupQuadIndex++)
	{
		uint NumBlocks = NumBlocksShared[GroupQuadIndex];
		uint BlockStartOffset = GlobalBlockStartOffset[GroupQuadIndex];
		uint QuadIndex = GroupQuadIndex + DispatchThreadId.x - GroupThreadId.x;
		uint CardPageId = QuadData[QuadIndex];

		for (uint BlockIndex = GroupThreadId.x; BlockIndex < NumBlocks; BlockIndex += THREADGROUP_SIZE)
		{
			uint4 BlockData = uint4(CardPageId, QuadIndex, BlockIndex, 0);
			RWCardTraceBlockData[BlockStartOffset + BlockIndex] = BlockData;
		}
	}

#else

	uint QuadIndex = DispatchThreadId.x;

	if (QuadIndex < QuadAllocator[0])
	{
		uint CardPageId = QuadData[QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageId, CardPageBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint NumBlocks = NumBlocksXY.x * NumBlocksXY.y;

		uint BlockStartOffset;
		InterlockedAdd(RWCardTraceBlockAllocator[0], NumBlocks, BlockStartOffset);

		for (uint BlockIndex = 0; BlockIndex < NumBlocks; BlockIndex++)
		{
			uint4 BlockData = uint4(CardPageId, QuadIndex, BlockIndex, 0);
			RWCardTraceBlockData[BlockStartOffset + BlockIndex] = BlockData;
		}
	}
#endif
}

#endif

Buffer<uint> CardTraceBlockAllocator;

[numthreads(1, 1, 1)]
void TraceBlocksIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	RWIndirectArgs[0] = (CardTraceBlockAllocator[0] * CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE * THREADS_PER_RADIOSITY_TEXEL + THREADGROUP_SIZE - 1) / THREADGROUP_SIZE;
	RWIndirectArgs[1] = 1;
	RWIndirectArgs[2] = 1;
}

Texture2D CurrentOpacityAtlas;
Buffer<uint4> CardTraceBlockData;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MarkRadianceProbesUsedByRadiosityCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;
	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = ThreadIndex % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		uint4 TraceBlockData = CardTraceBlockData[GlobalBlockIndex];
		uint CardPageIndex = TraceBlockData.x;
		uint ProbeIndex = TraceBlockData.y;
		uint BlockIndex = TraceBlockData.z;

		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex, CardPageBuffer);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex, CardBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint2 BlockOffset = uint2(BlockIndex % NumBlocksXY.x, BlockIndex / NumBlocksXY.x);
		float2 TexelCoord = BlockOffset * CARD_TRACE_BLOCK_SIZE + TexelOffsetInBlock;

		if (all(TexelCoord < (float2)CardPageSizeInTexels))
		{
			float2 CardPageUV = (TexelCoord + 0.5f) / (float2)CardPageSizeInTexels;
			float2 CardUV = CardPageUVToCardUV(CardPage, CardPageUV);
			float2 AtlasUV = CardPageUVToAtlasUV(CardPage, CardPageUV);

			float Opacity = Texture2DSampleLevel(CurrentOpacityAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

			float3 Lighting = 0;

			if (Opacity > 0)
			{
				float Depth = 1.0f - Texture2DSampleLevel(DepthAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

				float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);

				uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

				if (ClipmapIndex < NumRadianceProbeClipmaps)
				{
					MarkPositionUsedInIndirectionTexture(WorldPosition, ClipmapIndex);
				}
			}
		}
	}
}

uint NumCones;
float SampleWeight;
float4 RadiosityConeDirections[32];

Texture2D CurrentNormalAtlas;

float3 RadiosityTraceFromTexel(float2 AtlasUV, float2 CardUV, FLumenCardData Card, uint ConeStartIndex, uint ConeEndIndex)
{
	float Opacity = Texture2DSampleLevel(CurrentOpacityAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

	float3 Lighting = 0;

	if (Opacity > 0)
	{
		float Depth = 1.0f - Texture2DSampleLevel(DepthAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

		float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);
		float3 WorldNormal = DecodeSurfaceCacheNormal(Texture2DSampleLevel(CurrentNormalAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).xy);

		//@todo - derive bias from texel world size
		WorldPosition += WorldNormal * SurfaceBias;

		float VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(MinTraceDistance, MaxTraceDistance, MaxMeshSDFTraceDistance, false);

		for (uint ConeIndex = ConeStartIndex; ConeIndex < ConeEndIndex; ConeIndex++)
		{
			//uint ConeIndex = ConeStartIndex;
			float3x3 TangentBasis = GetTangentBasisFrisvad(WorldNormal);

			#define PRECOMPUTED_SAMPLE_DIRECTIONS 1
			#if PRECOMPUTED_SAMPLE_DIRECTIONS
				float3 LocalConeDirection = RadiosityConeDirections[ConeIndex].xyz;
				float3 WorldConeDirection = mul(LocalConeDirection, TangentBasis);
			#else
				uint2 AtlasCoord = AtlasUV * RadiosityAtlasSize;
				uint2 Seed0 = Rand3DPCG16(int3(AtlasCoord + 17, 0)).xy;
				float2 E = Hammersley16(ConeIndex, NumCones, Seed0);
				float2 DiskE = UniformSampleDiskConcentric(E.xy);
				float TangentZ = sqrt(1 - length2(DiskE));
				float3 WorldConeDirection = mul(float3(DiskE, TangentZ), TangentBasis);
			#endif

			//@todo - derive bias from texel world size
			float3 SamplePosition = WorldPosition + SurfaceBias * WorldConeDirection;

			FConeTraceInput TraceInput;
			TraceInput.Setup(SamplePosition, WorldConeDirection, DiffuseConeHalfAngle, MinSampleRadius, MinTraceDistance, MaxTraceDistance, StepFactor);
			TraceInput.VoxelStepFactor = VoxelStepFactor;
			TraceInput.VoxelTraceStartDistance = VoxelTraceStartDistance;
			TraceInput.SDFStepFactor = 1;

			FConeTraceResult TraceResult;
			ConeTraceVoxels(TraceInput, TraceResult);

			EvaluateSkyRadianceForCone(WorldConeDirection, TraceInput.TanConeAngle, TraceResult);

			Lighting += TraceResult.Lighting;
		}
	}

	Lighting *= PI / (float)NumCones;
	return Lighting;
}

RWTexture2D<float4> RWRadiosityAtlas;

#if THREADGROUP_SIZE > 0

float ProbeOcclusionNormalBias;
groupshared float3 ThreadLighting[THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, 1, 1)]
void LumenCardRadiosityTraceBlocksCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
#if IRRADIANCE_CACHE
	uint ThreadIndex = DispatchThreadId.x;

	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = ThreadIndex % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		uint4 TraceBlockData = CardTraceBlockData[GlobalBlockIndex];
		uint CardPageIndex = TraceBlockData.x;
		uint ProbeIndex = TraceBlockData.y;
		uint BlockIndex = TraceBlockData.z;

		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex, CardPageBuffer);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex, CardBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint2 BlockOffset = uint2(BlockIndex % NumBlocksXY.x, BlockIndex / NumBlocksXY.x);
		float2 TexelCoord = BlockOffset * CARD_TRACE_BLOCK_SIZE + TexelOffsetInBlock;

		if (all(TexelCoord < (float2)CardPageSizeInTexels))
		{
			float2 CardPageUV = (TexelCoord + 0.5f) / (float2)CardPageSizeInTexels;
			float2 CardUV = CardPageUVToCardUV(CardPage, CardPageUV);
			float2 AtlasUV = CardPageUVToAtlasUV(CardPage, CardPageUV);

			float Opacity = Texture2DSampleLevel(CurrentOpacityAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

			float3 DiffuseLighting = 0;

			if (Opacity > 0)
			{
				float Depth = 1.0f - Texture2DSampleLevel(DepthAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).x;

				float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);
				float3 WorldNormal = DecodeSurfaceCacheNormal(Texture2DSampleLevel(CurrentNormalAtlas, GlobalBilinearClampedSampler, AtlasUV, 0).xy);
				uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

				if (ClipmapIndex < NumRadianceProbeClipmaps)
				{
					float3 BiasOffset = WorldNormal * ProbeOcclusionNormalBias;
					DiffuseLighting = SampleIrradianceCacheInterpolated(WorldPosition, WorldNormal, BiasOffset, ClipmapIndex);
				}
				else
				{
					DiffuseLighting = GetSkySHDiffuse(WorldNormal) * View.SkyLightColor.rgb;
				}
			}

			uint2 AtlasWriteCoord = uint2(AtlasUV * RadiosityAtlasSize);
			RWRadiosityAtlas[AtlasWriteCoord] = float4(DiffuseLighting * PI, 0);
		}
	}
#else
	ThreadLighting[GroupThreadId.x] = 0;

	uint ThreadIndex = DispatchThreadId.x;
	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE * THREADS_PER_RADIOSITY_TEXEL);
	int2 AtlasWriteCoord = -1;

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = (ThreadIndex / THREADS_PER_RADIOSITY_TEXEL) % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		uint4 TraceBlockData = CardTraceBlockData[GlobalBlockIndex];
		uint CardPageIndex = TraceBlockData.x;
		uint ProbeIndex = TraceBlockData.y;
		uint BlockIndex = TraceBlockData.z;

		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex, CardPageBuffer);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex, CardBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint2 BlockOffset = uint2(BlockIndex % NumBlocksXY.x, BlockIndex / NumBlocksXY.x);
		float2 TexelCoord = BlockOffset * CARD_TRACE_BLOCK_SIZE + TexelOffsetInBlock;

		if (all(TexelCoord < (float2)CardPageSizeInTexels))
		{
			uint TraceThreadIndex = ThreadIndex % THREADS_PER_RADIOSITY_TEXEL;

			float2 CardPageUV = (TexelCoord + .5f) / (float2)CardPageSizeInTexels;
			float2 CardUV = CardPageUVToCardUV(CardPage, CardPageUV);
			float2 AtlasUV = CardPageUVToAtlasUV(CardPage, CardPageUV);
			AtlasWriteCoord = int2(AtlasUV * RadiosityAtlasSize);

			uint NumTracesPerThread = NumCones / THREADS_PER_RADIOSITY_TEXEL;
			uint ConeStartIndex = TraceThreadIndex * NumTracesPerThread;
			float3 Lighting = RadiosityTraceFromTexel(AtlasUV, CardUV, Card, ConeStartIndex, ConeStartIndex + NumTracesPerThread);
			ThreadLighting[GroupThreadId.x] = Lighting;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint TraceThreadIndex = ThreadIndex % THREADS_PER_RADIOSITY_TEXEL;

	if (TraceThreadIndex == 0 && all(AtlasWriteCoord >= 0))
	{
		float3 Lighting = 0;

		for (uint OtherThreadIndex = GroupThreadId.x; OtherThreadIndex < GroupThreadId.x + THREADS_PER_RADIOSITY_TEXEL; OtherThreadIndex += 1)
		{
			Lighting += ThreadLighting[OtherThreadIndex];
		}

		RWRadiosityAtlas[AtlasWriteCoord] = float4(Lighting, 0);
	}
#endif
}

#endif

void LumenCardRadiosityPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{
	FLumenCardPageData CardPage = GetLumenCardPageData(CardInterpolants.CardPageIndex, CardPageBuffer);
	FLumenCardData Card = GetLumenCardData(CardPage.CardIndex, CardBuffer);

	float3 Lighting = RadiosityTraceFromTexel(CardInterpolants.AtlasUV, CardInterpolants.CardUV, Card, 0, NumCones);

	OutColor = float4(Lighting, 0);
}