// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenTracingCommon.ush
=============================================================================*/

#include "../ReflectionEnvironmentShared.ush"
#include "../BRDF.ush"
#include "../FastMath.ush"
#include "../SHCommon.ush"
#define DISTANCE_FIELD_IN_VIEW_UB 1
#include "../GlobalDistanceFieldShared.ush"
#include "../GlobalDistanceFieldUtils.ush"
#include "../DistanceFieldLightingShared.ush"

Texture2D FinalLightingAtlas;
Texture2D IrradianceAtlas;
Texture2D IndirectIrradianceAtlas;
#define FINAL_LIGHTING_ATLAS_ID 0
#define IRRADIANCE_ATLAS_ID 1
#define INDIRECT_IRRADIANCE_ATLAS_ID 2

Texture2D AlbedoAtlas;
Texture2D OpacityAtlas;
Texture2D NormalAtlas;
Texture2D EmissiveAtlas;
Texture2D DepthAtlas;

#ifndef ENABLE_VISUALIZE_MODE
	#define ENABLE_VISUALIZE_MODE 0
#endif

#if ENABLE_VISUALIZE_MODE == 1
	#define VISUALIZE_MODE_ALBEDO 1
	#define VISUALIZE_MODE_GEOMETRY_NORMALS 2
	#define VISUALIZE_MODE_NORMALS 3
	#define VISUALIZE_MODE_EMISSIVE 4
	#define VISUALIZE_MODE_OPACITY 5
	#define VISUALIZE_CARD_WEIGHTS 6
	#define VISUALIZE_MODE_LOCAL_POSITION 7
	#define VISUALIZE_MODE_VELOCITY 8

	uint VisualizeMode;
#endif

#if SURFACE_CACHE_FEEDBACK
	RWStructuredBuffer<uint> RWSurfaceCacheFeedbackBufferAllocator;
	RWStructuredBuffer<uint2> RWSurfaceCacheFeedbackBuffer;
	uint SurfaceCacheFeedbackBufferSize;
	uint SurfaceCacheFeedbackBufferTileWrapMask;
	uint2 SurfaceCacheFeedbackBufferTileJitter;
	float SurfaceCacheFeedbackResLevelBias;
#endif

#ifndef VISIBILITY_ONLY_TRACE
	#define VISIBILITY_ONLY_TRACE 0
#endif

#ifndef DEPTH_WEIGHTED_OIT_32_BIT
	#define DEPTH_WEIGHTED_OIT_32_BIT 1
#endif

#ifndef ENABLE_DYNAMIC_SKY_LIGHT
	#define ENABLE_DYNAMIC_SKY_LIGHT 1
#endif

#ifndef SDF_TRACING_TRAVERSE_MIPS
	#define SDF_TRACING_TRAVERSE_MIPS 0
#endif

#define MIN_flt			(1.175494351e-38F)			/* min positive value */

#if CARD_TRACE_DEPTH_WEIGHTED_OIT

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float Revealage;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		Revealage = 1;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	float ComputeDepthWeight(float InDepth, float InOpacity)
	{
#if DEPTH_WEIGHTED_OIT_32_BIT
		// From Weighted Blended Order-Independent Transparency
		//@todo - make full use of 32 bit fp, original functions were crafted for 16 bit fp render targets but we are using shader temporaries
		//@todo - try 64 bit fp
	#define HEURISTIC 2
	#if HEURISTIC == 0
		float A = InDepth / 50.0f;
		float B = InDepth / 2000.0f;
		float B2 = B * B;
		float B6 = B2 * B2 * B2;
		return InOpacity * max(.01f, min(10000000.0f, 10.0f / (.00001f + A * A + B6)));
	#elif HEURISTIC == 1
		float ZNear = 10.0f;
		float ZFar = 100000.0f;
		float D = saturate(((ZNear * ZFar) / InDepth - ZFar) / (ZNear - ZFar));
		float InvD = 1 - D;
		return InOpacity * max(.01f, 1000000.0f * InvD * InvD * InvD);
	#elif HEURISTIC == 2
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		float b2 = b * b;
		float b4 = b2 * b2;
		return min(10000 * b4 * b4, 30000) * a * a * a;
	#endif
#else
		// 16 bit fp version
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		return min(10000 * b * b * b + 5, 20) * a * a * a;
#endif
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		float4 WeightedLighting = float4(InLighting * InOpacity, InOpacity) * ComputeDepthWeight(InDepth, InOpacity);
		LightingAndOpacity += WeightedLighting;
		Revealage *= (1 - InOpacity);
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity += InBlendState.LightingAndOpacity;
		Revealage *= InBlendState.Revealage;
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
		NumOverlaps++;
	}

	float3 GetFinalLighting()
	{
		float ClampedWeightedOpacity = max(LightingAndOpacity.a, MIN_flt);
		return LightingAndOpacity.rgb / ClampedWeightedOpacity * (1 - Revealage);
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return Revealage;
	}
};

#else

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float NumSteps;
	float OpaqueHitDistance;
	float NumOverlaps;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		if (InDepth < OpaqueHitDistance)
		{
			LightingAndOpacity.xyz = InLighting;
			LightingAndOpacity.w = InOpacity;
			OpaqueHitDistance = InDepth;
		}
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		// This is done in AddLighting
		//OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity.xyz += InBlendState.LightingAndOpacity.xyz;
		LightingAndOpacity.w = max(LightingAndOpacity.w, InBlendState.LightingAndOpacity.w);
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
	}

	float3 GetFinalLighting()
	{
		return LightingAndOpacity.xyz;
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return 1.0f - LightingAndOpacity.w;
	}
};

#endif

//https://iquilezles.org/www/articles/smin/smin.htm
float SmoothMin2( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return lerp( b, a, h ) - k*h*(1.0-h);
}

float ComputeBorderFadeDistance(float2 BoxMin, float2 BoxMax, float2 InPoint)
{
	float2 DistancesToMin = max(InPoint - BoxMin, 0);
	float2 DistancesToMax = max(BoxMax - InPoint, 0);
	float2 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return SmoothMin2(ClosestDistances.x, ClosestDistances.y, 100.0f);
}

#define TRACING_ATLAS_SAMPLER GlobalBilinearClampedSampler

struct FConeTraceInput
{
	float3 ConeOrigin;
	float3 ConeDirection;
	
	float ConeAngle;
	float TanConeAngle;

	float ConeStartRadius;
	float MinSampleRadius;
	float MinTraceDistance;
	float MaxTraceDistance;

	float StepFactor;
	float VoxelStepFactor;
	float VoxelTraceStartDistance;
	float SDFStepFactor;
	bool bBlackOutSteepIntersections;
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
	float InitialMaxDistance;

	// Used for dithering
	uint2 ScreenCoord;

	// Whether to sample high res surface cache data or low res always resident pages
	bool bHiResSurface;

	// Mesh SDF traces
	uint NumMeshSDFs;
	uint MeshSDFStartOffset;
	uint MeshSDFBitmaskStartOffset;
	float CardInterpolateInfluenceRadius;
	float CardInterpolateDepthVisibilityRadius;

	void Setup(
		float3 InConeOrigin,
		float3 InConeDirection,
		float InConeAngle,
		float InMinSampleRadius,
		float InMinTraceDistance,
		float InMaxTraceDistance,
		float InStepFactor)
	{
		ConeOrigin = InConeOrigin;
		ConeDirection = InConeDirection;
		ConeAngle = InConeAngle;
		TanConeAngle = tan(ConeAngle);
		ConeStartRadius = 0;
		MinSampleRadius = InMinSampleRadius;
		MinTraceDistance = InMinTraceDistance;
		MaxTraceDistance = InMaxTraceDistance;
		StepFactor = InStepFactor;
		VoxelStepFactor = .7f;
		VoxelTraceStartDistance = InMaxTraceDistance;

		// The global SDF often overestimates due to the way distances outside of an object SDF are calculated, can be corrected by stepping slower, but increases trace cost
		SDFStepFactor = 1;
		bBlackOutSteepIntersections = false;
		bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = true;
		InitialMaxDistance = 0;

		ScreenCoord = uint2(0, 0);
		bHiResSurface = false;
	}
};

struct FConeTraceResult
{
#if !VISIBILITY_ONLY_TRACE
	float3 Lighting;
#endif
	float Transparency;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;
	float3 Debug;
};

void ConeTraceSingleLumenCard(
	FConeTraceInput TraceInput,
	uint CardIndex,
	inout float3 Debug,
	inout float OutTraceEndDistance,
	inout FCardTraceBlendState CardTraceBlendState)
{
	FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

	float3 LocalConeOrigin = mul(TraceInput.ConeOrigin - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
	float3 LocalConeDirection = mul(TraceInput.ConeDirection, LumenCardData.WorldToLocalRotation);
	float3 LocalTraceEnd = LocalConeOrigin + LocalConeDirection * TraceInput.MaxTraceDistance;

	float2 IntersectionRange = LineBoxIntersect(LocalConeOrigin, LocalTraceEnd, -LumenCardData.LocalExtent, LumenCardData.LocalExtent);
	IntersectionRange.x = max(IntersectionRange.x, TraceInput.MinTraceDistance / TraceInput.MaxTraceDistance);
	OutTraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

	if (IntersectionRange.y > IntersectionRange.x
		&& LumenCardData.bVisible)
	{
		// #lumen_todo: restore after a distance scene rewrite
/*
		{
			FCardTraceBlendState ConeStepBlendState;
			ConeStepBlendState.Initialize(TraceInput.MaxTraceDistance);

			float StepTime = IntersectionRange.x * TraceInput.MaxTraceDistance;
			float3 SamplePosition = LocalCoreveneOrigin + StepTime * LocalConeDirection;
			float TraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

			float IntersectionLength = (IntersectionRange.y - IntersectionRange.x) * TraceInput.MaxTraceDistance;
			float MinStepSize = IntersectionLength / (float)LumenCardScene.MaxConeSteps;

			float PreviousStepTime = StepTime;
			float3 PreviousSamplePosition = SamplePosition;
			// Magic value to prevent linear intersection approximation on first step
			float PreviousHeightfieldZ = -2;

			bool bClampedToEnd = false;
			bool bFoundSurface = false;
			bool bRayAboveSurface = false;
			float IntersectionStepTime = 0;
			float2 IntersectionSamplePositionXY = SamplePosition.xy;
			float IntersectionSlope = 0;

			uint NumStepsPerLoop = 4;
			for (uint StepIndex = 0; StepIndex < LumenCardScene.MaxConeSteps && StepTime < TraceEndDistance; StepIndex += NumStepsPerLoop)
			{
				float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * StepTime, TraceInput.MinSampleRadius);
				float StepSize = max(SampleRadius * TraceInput.StepFactor, MinStepSize);
				float TraceClampDistance = TraceEndDistance - StepSize * .0001f;

				float DepthMip;
				float2 DepthValidRegionScale;
				CalculateMip(SampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, DepthMip, DepthValidRegionScale);

				float3 SamplePosition1 = LocalConeOrigin + min(StepTime + 0 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition2 = LocalConeOrigin + min(StepTime + 1 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition3 = LocalConeOrigin + min(StepTime + 2 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition4 = LocalConeOrigin + min(StepTime + 3 * StepSize, TraceClampDistance) * LocalConeDirection;

				float2 DepthAtlasUV1 = CalculateAtlasUV(SamplePosition1.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV2 = CalculateAtlasUV(SamplePosition2.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV3 = CalculateAtlasUV(SamplePosition3.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV4 = CalculateAtlasUV(SamplePosition4.xy, DepthValidRegionScale, LumenCardData);

				float Depth1 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV1, DepthMip).x;
				float Depth2 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV2, DepthMip).x;
				float Depth3 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV3, DepthMip).x;
				float Depth4 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV4, DepthMip).x;

				float HeightfieldZ1 = LumenCardData.LocalExtent.z - Depth1 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ2 = LumenCardData.LocalExtent.z - Depth2 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ3 = LumenCardData.LocalExtent.z - Depth3 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ4 = LumenCardData.LocalExtent.z - Depth4 * 2 * LumenCardData.LocalExtent.z;

				ConeStepBlendState.RegisterStep(NumStepsPerLoop);

				bool4 HeightfieldHit = bool4(
					SamplePosition1.z < HeightfieldZ1,
					SamplePosition2.z < HeightfieldZ2,
					SamplePosition3.z < HeightfieldZ3,
					SamplePosition4.z < HeightfieldZ4);

				bool bRayBelowHeightfield = any(HeightfieldHit);
				bool bRayWasAboveSurface = bRayAboveSurface;

				if (!bRayBelowHeightfield)
				{
					bRayAboveSurface = true;
				}

				// Traces which started below the heightfield have to get above before they can register a hit
				if (bRayBelowHeightfield && bRayWasAboveSurface)
				{
					float HeightfieldZ;
					if (HeightfieldHit.x)
					{
						SamplePosition = SamplePosition1;
						HeightfieldZ = HeightfieldZ1;
						StepTime = StepTime + 0 * StepSize;
					}
					else if (HeightfieldHit.y)
					{
						PreviousSamplePosition = SamplePosition1;
						PreviousHeightfieldZ = HeightfieldZ1;
						PreviousStepTime = StepTime + 0 * StepSize;

						SamplePosition = SamplePosition2;
						HeightfieldZ = HeightfieldZ2;
						StepTime = StepTime + 1 * StepSize;
					}
					else if (HeightfieldHit.z)
					{
						PreviousSamplePosition = SamplePosition2;
						PreviousHeightfieldZ = HeightfieldZ2;
						PreviousStepTime = StepTime + 1 * StepSize;

						SamplePosition = SamplePosition3;
						HeightfieldZ = HeightfieldZ3;
						StepTime = StepTime + 2 * StepSize;
					}
					else
					{
						PreviousSamplePosition = SamplePosition3;
						PreviousHeightfieldZ = HeightfieldZ3;
						PreviousStepTime = StepTime + 2 * StepSize;

						SamplePosition = SamplePosition4;
						HeightfieldZ = HeightfieldZ4;
						StepTime = StepTime + 3 * StepSize;
					}

					StepTime = min(StepTime, TraceClampDistance);

					if (PreviousHeightfieldZ != -2)
					{
						// Construct a linear approximation of both the SamplePosition z and heightfield z between the previous step and this step: y = m * x + b
						// SamplePosition z linear approximation:
						// y = (SamplePosition.z - PreviousSampleZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousSampleZ
						// Heightfield z linear approximation:
						// y = (HeightfieldZ - PreviousHeightfieldZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousHeightfieldZ 

						// Solve for x where they intersect
						IntersectionStepTime = PreviousStepTime + ((PreviousSamplePosition.z - PreviousHeightfieldZ) * (StepTime - PreviousStepTime)) / (HeightfieldZ - PreviousHeightfieldZ + PreviousSamplePosition.z - SamplePosition.z);

						float2 LocalPositionSlopeXY = (SamplePosition.xy - PreviousSamplePosition.xy) / (StepTime - PreviousStepTime);
						IntersectionSamplePositionXY = LocalPositionSlopeXY * (IntersectionStepTime - PreviousStepTime) + PreviousSamplePosition.xy;

						IntersectionSlope = abs(PreviousHeightfieldZ - HeightfieldZ) / max(length(PreviousSamplePosition.xy - SamplePosition.xy), .0001f);

						PreviousHeightfieldZ = -2;
						bFoundSurface = true;
					}
					break;
				}

				PreviousStepTime = StepTime + 3 * StepSize;
				PreviousSamplePosition = SamplePosition4;
				PreviousHeightfieldZ = HeightfieldZ4;
				StepTime += 4 * StepSize;

				if (StepTime >= TraceEndDistance && !bClampedToEnd)
				{
					bClampedToEnd = true;
					// Stop the last step just before the intersection end, since the linear approximation needs to step past the surface to detect a hit, without terminating the loop
					StepTime = TraceClampDistance;
				}
			}

			if (bFoundSurface)
			{
				float IntersectionSampleRadius = TraceInput.ConeStartRadius + TraceInput.TanConeAngle * IntersectionStepTime;

				float MaxMip;
				float2 ValidRegionScale;
				CalculateMip(IntersectionSampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, MaxMip, ValidRegionScale);

				float2 IntersectionAtlasUV = CalculateAtlasUV(IntersectionSamplePositionXY, ValidRegionScale, LumenCardData);

				float DistanceToSurface = 0;
				float ConeIntersectSurface = saturate(DistanceToSurface / IntersectionSampleRadius);
				float ConeVisibility = ConeIntersectSurface;

				float MaxDistanceFade = 1; // saturate((TraceInput.MaxTraceDistance - IntersectionStepTime) * TraceInput.InvMaxDistanceFadeLength);

				ConeStepBlendState.RegisterOpaqueHit(IntersectionStepTime);
				OutTraceEndDistance = IntersectionStepTime;

				float Opacity = Texture2DSampleLevel(OpacityAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).x;
				float ConeOcclusion = (1.0f - ConeVisibility) * Opacity * MaxDistanceFade;

				#if VISIBILITY_ONLY_TRACE
					float3 StepLighting = 0;
				#else
					float3 StepLighting = Texture2DSampleLevel(FinalLightingAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb;
					//float3 StepLighting = Pow2(Texture2DSampleLevel(LumenCardScene.AlbedoAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb);
				#endif
			
				if (TraceInput.bBlackOutSteepIntersections)
				{
					// Assume steep sections are covered by other faces and fade out.
					float SlopeFade = 1 - saturate((IntersectionSlope - 5) / 1.0f);
					StepLighting = lerp(0, StepLighting, SlopeFade);
					ConeOcclusion = lerp(0, ConeOcclusion, SlopeFade);
				}

				ConeStepBlendState.AddLighting(StepLighting, ConeOcclusion, IntersectionStepTime);
			}

			CardTraceBlendState.AddCardTrace(ConeStepBlendState);
		}
*/
	}
}

Buffer<uint> CulledCardGridData;

void ConeTraceLumenCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);
	float3 ConeEndPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
	float3 debug = 0;
	float TraceEndDistance = 0;

	for (uint CardIndex = 0; CardIndex < LumenCardScene.NumCards; CardIndex++)
	{
		ConeTraceSingleLumenCard(
			TraceInput,
			CardIndex,
			debug,
			TraceEndDistance,
			CardTraceBlendState);
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

// Mesh SDF cull grid
Buffer<uint> NumGridCulledMeshSDFObjects;
Buffer<uint> GridCulledMeshSDFObjectStartOffsetArray;
Buffer<uint> GridCulledMeshSDFObjectIndicesArray;

struct FTraceMeshSDFResult
{
	float HitDistance;
	uint HitObject;
	bool bRayStartInsideGeometry;
};

void RayTraceSingleMeshSDF(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TanConeHalfAngle,
	float MinTraceDistance,
	float MaxTraceDistance, 
	uint ObjectIndex,
	// The SDF surface is expanded to reduce leaking through thin surfaces, especially foliage meshes with bGenerateDistanceFieldAsIfTwoSided
	// Expanding as RayTime increases errors on the side of over-occlusion, especially at grazing angles, which can be desirable for diffuse GI.
	// Expanding as MaxDistance increases has less incorrect self-intersection which is desirable for reflections rays.
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
	float InitialMaxDistance,
	inout FTraceMeshSDFResult TraceResult)
{
	FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

	// Trace up to the current hit point
	MaxTraceDistance = min(MaxTraceDistance, TraceResult.HitDistance + DFObjectData.VolumeSurfaceBias);

	float3 WorldRayEnd = WorldRayStart + WorldRayDirection * MaxTraceDistance;
	float3 VolumeRayStart = mul(float4(WorldRayStart, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayEnd = mul(float4(WorldRayEnd, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayDirection = VolumeRayEnd - VolumeRayStart;

	float VolumeMaxTraceDistance = length(VolumeRayDirection);
	float VolumeMinTraceDistance = VolumeMaxTraceDistance * (MinTraceDistance / MaxTraceDistance);
	VolumeRayDirection /= VolumeMaxTraceDistance;

	float2 VolumeSpaceIntersectionTimes = LineBoxIntersect(VolumeRayStart, VolumeRayEnd, -DFObjectData.VolumePositionExtent, DFObjectData.VolumePositionExtent);

	VolumeSpaceIntersectionTimes *= VolumeMaxTraceDistance;
	VolumeSpaceIntersectionTimes.x = max(VolumeSpaceIntersectionTimes.x, VolumeMinTraceDistance);

	BRANCH
	if (VolumeSpaceIntersectionTimes.x < VolumeSpaceIntersectionTimes.y)
	{
		uint MaxMipIndex = LoadDFAssetData(DFObjectData.AssetIndex, 0).NumMips - 1;
		// Start tracing at the highest resolution mip
		uint ReversedMipIndex = MaxMipIndex;
		FDFAssetData DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);

		#if !SDF_TRACING_TRAVERSE_MIPS
			ReversedMipIndex = MaxMipIndex;
			DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
		#endif

		bool bRayStartInsideGeometry = false;
		float SampleRayTime = VolumeSpaceIntersectionTimes.x;

		uint MaxSteps = 64;
		float MinStepSize = 1.0f / (16 * MaxSteps);
		uint StepIndex = 0;
		bool bHit = false;
		float MaxDistance = InitialMaxDistance;

		LOOP
		for (; StepIndex < MaxSteps; StepIndex++)
		{
			float3 SampleVolumePosition = VolumeRayStart + VolumeRayDirection * SampleRayTime;
			float DistanceField = SampleSparseMeshSignedDistanceField(SampleVolumePosition, DFAssetMipData);

			MaxDistance = max(DistanceField, MaxDistance);
			float ExpandSurfaceTime = bExpandSurfaceUsingRayTimeInsteadOfMaxDistance ? SampleRayTime : MaxDistance;

			// Expand the surface to find thin features, but only away from the start of the trace where it won't introduce incorrect self-occlusion
			// This still causes incorrect self-occlusion at grazing angles
			float ExpandSurfaceDistance = DFObjectData.VolumeSurfaceBias;
			const float ExpandSurfaceFalloff = 2.0f * ExpandSurfaceDistance;
			const float ExpandSurfaceAmount = ExpandSurfaceDistance * saturate(ExpandSurfaceTime / ExpandSurfaceFalloff);

#if SDF_TRACING_TRAVERSE_MIPS

			float MaxEncodedDistance = DFAssetMipData.DistanceFieldToVolumeScaleBias.x + DFAssetMipData.DistanceFieldToVolumeScaleBias.y;

			// We reached the maximum distance of this mip's narrow band, use a lower resolution mip for next iteration
			if (abs(DistanceField) >= MaxEncodedDistance && ReversedMipIndex > 0)
			{
				ReversedMipIndex--;
				DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
			}
			// We are close to the surface, step back to safety and use a higher resolution mip for next iteration
			else if (abs(DistanceField) < .25f * MaxEncodedDistance && ReversedMipIndex < MaxMipIndex)
			{
				DistanceField -= 6.0f * DFObjectData.VolumeSurfaceBias;
				ReversedMipIndex++;
				DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
			}
			else 
#endif
			if (DistanceField < ExpandSurfaceAmount && ReversedMipIndex == MaxMipIndex)
			{
				bRayStartInsideGeometry = SampleRayTime <= 0.0f && SampleRayTime + DistanceField < 0.0f ? true : false;
				// One more step to the surface
				// Pull back by ExpandSurfaceAmount to improve the gradient computed off of the hit point
				SampleRayTime = clamp(SampleRayTime + DistanceField - ExpandSurfaceAmount, VolumeSpaceIntersectionTimes.x, VolumeSpaceIntersectionTimes.y);
				bHit = true;
				break;
			}

			float StepDistance = max(DistanceField, MinStepSize);
			SampleRayTime += StepDistance;		

			if (SampleRayTime > VolumeSpaceIntersectionTimes.y + ExpandSurfaceAmount)
			{
				break;
			}
		}

		if (StepIndex == MaxSteps)
		{
			bHit = true;
		}

		if (bHit)
		{
			float NewHitDistance = length(VolumeRayDirection * SampleRayTime * DFObjectData.VolumeToWorldScale);

			if (NewHitDistance < TraceResult.HitDistance)
			{
				TraceResult.HitObject = ObjectIndex;
				TraceResult.HitDistance = NewHitDistance;
				TraceResult.bRayStartInsideGeometry = bRayStartInsideGeometry;
			}
		}
	}
}

struct FTraceMeshSDFDerivedData
{
	float3 HitNormal;
	bool bAccurateHit;
};

FTraceMeshSDFDerivedData CalculateMeshSDFDerivedData(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TraceDistance,
	FTraceMeshSDFResult TraceMeshSDFResult)
{
	FTraceMeshSDFDerivedData TraceSDFData;

	uint ObjectIndex = TraceMeshSDFResult.HitObject;
	FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

	float3 HitPosition = WorldRayStart + WorldRayDirection * TraceMeshSDFResult.HitDistance;
	float3 SampleVolumePosition = mul(float4(HitPosition, 1), DFObjectData.WorldToVolume).xyz;

	// Clamp hit point to a valid volume
	SampleVolumePosition = clamp(SampleVolumePosition, -DFObjectData.VolumePositionExtent, DFObjectData.VolumePositionExtent);

	FDFAssetData DFAssetData = LoadDFAssetDataHighestResolution(DFObjectData.AssetIndex);
	float3 VolumeGradient = CalculateMeshSDFGradient(SampleVolumePosition, DFAssetData);
	float VolumeGradientLength = length(VolumeGradient);
	float3 VolumeNormal = VolumeGradientLength > 0.0f ? VolumeGradient / VolumeGradientLength : 0;
	// Transform by transposed inverse to handle non-uniform scaling
	float3 WorldGradient = mul(VolumeNormal, transpose((float3x3)DFObjectData.WorldToVolume));
	float WorldGradientLength = length(WorldGradient);
	TraceSDFData.HitNormal = WorldGradientLength > 0.0f ? WorldGradient / WorldGradientLength : 0;

	TraceSDFData.bAccurateHit = !DFObjectData.bMostlyTwoSided;

	return TraceSDFData;
}

struct FSurfaceCacheSample
{
	float2 PhysicalAtlasUV;
	uint2 PackedFeedback;
	bool bValid;
};

// Must match Lumen::PhysicalPageSize and Lumen::VirtualPageSize in Lumen.h
#define VIRTUAL_PAGE_SIZE			127
#define PHYSICAL_PAGE_SIZE			128
#define MIN_RES_LEVEL				2
#define MAX_RES_LEVEL				11
#define SUB_ALLOCATION_RES_LEVEL	7		// = log2(PHYSICAL_PAGE_SIZE)

uint2 ResLevelXYToSizeInPages(uint2 ResLevelXY)
{
	return ResLevelXY > SUB_ALLOCATION_RES_LEVEL ? 1u << (ResLevelXY - SUB_ALLOCATION_RES_LEVEL) : 1;
}

uint2 GetSizeInPages(FLumenCardData Card, uint ResLevel)
{
	uint2 ResLevelXY = ResLevel - Card.ResLevelToResLevelXYBias;
	return ResLevelXYToSizeInPages(ResLevelXY);
}

FSurfaceCacheSample ComputeSurfaceCacheSample(FLumenCardData Card, uint CardIndex, float2 LocalSamplePosition, float SampleRadius, bool bHiResSurface)
{
	// CardUV in [0;1]
	float2 CardUV = SamplePositonToCardUV(Card, LocalSamplePosition);

	uint2 SizeInPages = Card.SizeInPages;
	uint PageTableOffset = Card.PageTableOffset;

	if (bHiResSurface)
	{
		SizeInPages = Card.HiResSizeInPages;
		PageTableOffset = Card.HiResPageTableOffset;
	}

	uint2 PageCoord = CardUV * SizeInPages;
	uint LinearPageCoord = PageCoord.x + PageCoord.y * SizeInPages.x;

	const uint PageTableIndex = PageTableOffset + LinearPageCoord;
	const uint PageTableValue = LumenCardScene.PageTableBuffer.Load(4 * PageTableIndex);

	uint2 AtlasBias;
	AtlasBias.x = ((PageTableValue >> 0) & 0xFFF) * 4.0f;
	AtlasBias.y = ((PageTableValue >> 12) & 0xFFF) * 4.0f;

	uint2 ResLevelXY;
	ResLevelXY.x = (PageTableValue >> 24) & 0xF;
	ResLevelXY.y = (PageTableValue >> 28) & 0xF;

	// Recompute new SizeInPages, as page may be pointing to an another mip map level
	SizeInPages = ResLevelXYToSizeInPages(ResLevelXY);
	uint2 AtlasScale = ResLevelXY > SUB_ALLOCATION_RES_LEVEL ? PHYSICAL_PAGE_SIZE : (1u << ResLevelXY);

	// Sample page with a bilinear sampling border
	float2 PageUV = frac(CardUV * SizeInPages);
	float2 PhysicalAtlasUV = (PageUV * (AtlasScale - 1.0f) + AtlasBias + 0.5f) * LumenCardScene.InvPhysicalAtlasSize;

	// Compute packed feedback buffer value
	uint2 PackedFeedback = 0;
	#if SURFACE_CACHE_FEEDBACK
	{
		// Compute optimal res level, based on the cone width (SampleRadius)
		float SampleResolution = max(Card.LocalExtent.x, Card.LocalExtent.y) / max(SampleRadius, 1.0f);
		uint DesiredResLevel = clamp(log2(SampleResolution) + SurfaceCacheFeedbackResLevelBias, MIN_RES_LEVEL, MAX_RES_LEVEL);

		uint2 LevelSizeInPages = GetSizeInPages(Card, DesiredResLevel);
		uint2 LocalPageCoord = CardUV * LevelSizeInPages;

		PackedFeedback.x = CardIndex | (DesiredResLevel << 24);
		PackedFeedback.y = LocalPageCoord.x + (LocalPageCoord.y << 8);
	}
	#endif

	FSurfaceCacheSample SurfaceCacheSample;
	SurfaceCacheSample.PhysicalAtlasUV = PhysicalAtlasUV;
	SurfaceCacheSample.bValid = ResLevelXY.x > 0;
	SurfaceCacheSample.PackedFeedback = PackedFeedback;
	return SurfaceCacheSample;
}

struct FLumenCardSample
{
	// Debug visualization
	uint AxisIndex;

	float Weight;
	float2 PhysicalAtlasUV;
	uint2 PackedFeedback;
};

void InitCardSample(inout FLumenCardSample CardSample, uint AxisIndex)
{
	CardSample.AxisIndex = AxisIndex;
	CardSample.Weight = 0.0f;
	CardSample.PhysicalAtlasUV = float2(0.0f, 0.0f);
	CardSample.PackedFeedback = uint2(0, 0);
}

void SampleLumenCard(
	float3 SamplePosition,
	float SampleRadius,
	bool bAccurateHit,
	float CardWeight,
	uint CardIndex,
	float DepthVisibilityRadius,
	bool bHiResSurface,
	uint AxisIndex,
	inout FLumenCardSample CardSample)
{
	InitCardSample(CardSample, AxisIndex);

	if (CardIndex < LumenCardScene.NumCards)
	{
		FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

		if (LumenCardData.bVisible)
		{
			float3 LocalSamplePosition = mul(SamplePosition - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);

			uint AxisIndex = 0;
			uint SideIndex = 0;

			LocalSamplePosition.xy = clamp(LocalSamplePosition.xy, -LumenCardData.LocalExtent.xy, LumenCardData.LocalExtent.xy);

			FSurfaceCacheSample SurfaceCacheSample = ComputeSurfaceCacheSample(LumenCardData, CardIndex, LocalSamplePosition.xy, SampleRadius, bHiResSurface);

			if (SurfaceCacheSample.bValid)
			{
				// Shadow map visibility
				float VisibilityWeight = 1.0f;
				{
					float2 DepthMoments = Texture2DSampleLevel(DepthAtlas, GlobalBilinearClampedSampler, SurfaceCacheSample.PhysicalAtlasUV, 0.0f).xy;

					// Bias a bit as SDF traces aren't super accurate
					const float RayBias = bAccurateHit ? -0.1f : -0.2f;
					const float NormalizedDistanceToHit = (-LocalSamplePosition.z / LumenCardData.LocalExtent.z) * 0.5f + 0.5f + RayBias;

					VisibilityWeight = 1.0f;
					if (NormalizedDistanceToHit > DepthMoments.x)
					{
						float Variance = abs(Square(DepthMoments.x) - DepthMoments.y);
						VisibilityWeight = saturate(Variance / (Variance + Square(NormalizedDistanceToHit - DepthMoments.x)));

						const float VisibilityCutoff = 0.15f;
						VisibilityWeight = (VisibilityWeight - VisibilityCutoff) / (1.0f - VisibilityCutoff);
					}
				}

				float Weight = VisibilityWeight * CardWeight;

				if (Weight > 0.0f)
				{
					CardSample.Weight = Weight;
					CardSample.PhysicalAtlasUV = SurfaceCacheSample.PhysicalAtlasUV;
					CardSample.PackedFeedback = SurfaceCacheSample.PackedFeedback;
				}
			}
		}
	}
}

void AccumulateLumenCardLighting(FLumenCardSample CardSample, uint AtlasId, inout float3 LightingSum, inout float WeightSum)
{
	if (CardSample.Weight > 0.0f)
	{
		float3 CardLighting = 0.0f;

		if (AtlasId == FINAL_LIGHTING_ATLAS_ID)
		{
			CardLighting = Texture2DSampleLevel(FinalLightingAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
		}
		else if (AtlasId == IRRADIANCE_ATLAS_ID)
		{
			CardLighting = Texture2DSampleLevel(IrradianceAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
		}
		else // if (AtlasId == INDIRECT_IRRADIANCE_ATLAS_ID)
		{
			CardLighting = Texture2DSampleLevel(IndirectIrradianceAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
		}

		float OpacityWeight = Texture2DSampleLevel(OpacityAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).x;

		// Debug visualization
		#if ENABLE_VISUALIZE_MODE == 1
		{
			if (VisualizeMode == VISUALIZE_MODE_ALBEDO)
			{
				CardLighting = pow(Texture2DSampleLevel(AlbedoAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).xyz, 2.2f) * View.OneOverPreExposure;
			}
			else if (VisualizeMode == VISUALIZE_MODE_NORMALS)
			{
				float3 WorldSpaceNormal = DecodeSurfaceCacheNormal(Texture2DSampleLevel(NormalAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).xy);
				CardLighting = (WorldSpaceNormal.xyz * 0.5f + 0.5f) * View.OneOverPreExposure;
			}
			else if (VisualizeMode == VISUALIZE_MODE_EMISSIVE)
			{
				CardLighting = Texture2DSampleLevel(EmissiveAtlas, TRACING_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
			}
			else if (VisualizeMode == VISUALIZE_MODE_OPACITY)
			{
				CardLighting = OpacityWeight;
				OpacityWeight = 1.0f;
			}
			else if (VisualizeMode == VISUALIZE_CARD_WEIGHTS)
			{
				if (CardSample.AxisIndex == 0)
				{
					CardLighting = float3(1, 0, 0);
				}
				else if (CardSample.AxisIndex == 1)
				{
					CardLighting = float3(0, 1, 0);
				}
				else
				{
					CardLighting = float3(0, 0, 1);
				}

				CardLighting *= View.OneOverPreExposure;
			}
		}
		#endif

		LightingSum += CardLighting * CardSample.Weight * OpacityWeight;
		WeightSum += CardSample.Weight * OpacityWeight;
	}
}

uint FindBestMeshCardIndex(FLumenMeshCardsData MeshCardsData, float3 SamplePosition, uint Orientation)
{
	for (uint IndexInMeshCards = 0; IndexInMeshCards < MeshCardsData.NumCards[Orientation]; ++IndexInMeshCards)
	{
		uint CardIndex = MeshCardsData.CardOffset[Orientation] + IndexInMeshCards;
		if (CardIndex < LumenCardScene.NumCards)
		{
			FLumenCardData LumenCardData = GetLumenCardData(CardIndex);
			if (LumenCardData.bVisible)
			{
				float3 LocalSamplePosition = mul(SamplePosition - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
				if (all(abs(LocalSamplePosition.xyz) < LumenCardData.LocalExtent.xyz))
				{
					return CardIndex;
				}
			}
		}
	}

	return LUMEN_INVALID_CARD_INDEX;
}

float4 SampleLumenMeshCardsWithWeight(uint2 ScreenCoord, uint DFObjectIndex, float3 SamplePosition, float3 SampleNormal, float SampleRadius, bool bAccurateHit, float CardInterpolateDepthVisibilityRadius, bool bHiResSurface, uint AtlasId)
{
	uint MeshCardId = LumenCardScene.DFObjectToMeshCardsIndexBuffer.Load(4 * DFObjectIndex);

	FLumenMeshCardsData MeshCardsData = GetLumenMeshCardsData(MeshCardId);

	float3 LocalSpaceHitNormal = normalize(mul(float4(SampleNormal, 0.0f), MeshCardsData.WorldToLocal).xyz);
	float3 AxisWeights = LocalSpaceHitNormal * LocalSpaceHitNormal;
	const uint CardOrientationX = (LocalSpaceHitNormal.x < 0.0f ? 0 : 1);
	const uint CardOrientationY = (LocalSpaceHitNormal.y < 0.0f ? 2 : 3);
	const uint CardOrientationZ = (LocalSpaceHitNormal.z < 0.0f ? 4 : 5);

	uint CardIndexX = FindBestMeshCardIndex(MeshCardsData, SamplePosition, CardOrientationX);
	uint CardIndexY = FindBestMeshCardIndex(MeshCardsData, SamplePosition, CardOrientationY);
	uint CardIndexZ = FindBestMeshCardIndex(MeshCardsData, SamplePosition, CardOrientationZ);

	FLumenCardSample CardSampleX;
	SampleLumenCard(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.x,
		CardIndexX,
		CardInterpolateDepthVisibilityRadius,
		bHiResSurface,
		/*AxisIndex*/ 0,
		CardSampleX);

	FLumenCardSample CardSampleY;
	SampleLumenCard(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.y,
		CardIndexY,
		CardInterpolateDepthVisibilityRadius,
		bHiResSurface,
		/*AxisIndex*/ 1,
		CardSampleY);

	FLumenCardSample CardSampleZ;
	SampleLumenCard(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.z,
		CardIndexZ,
		CardInterpolateDepthVisibilityRadius,
		bHiResSurface,
		/*AxisIndex*/ 2,
		CardSampleZ);

	// Stochastic tri-planar
	float3 WeightPrefixSum;
	WeightPrefixSum.x = CardSampleX.Weight;
	WeightPrefixSum.y = CardSampleX.Weight + CardSampleY.Weight;
	WeightPrefixSum.z = CardSampleX.Weight + CardSampleY.Weight + CardSampleZ.Weight;

	float StochasticWeight = InterleavedGradientNoise(ScreenCoord, View.StateFrameIndexMod8) * WeightPrefixSum.z;

	FLumenCardSample StochasticCardSample;
	InitCardSample(StochasticCardSample, 0);
	if (StochasticWeight < WeightPrefixSum.x)
	{
		StochasticCardSample = CardSampleX;
	}
	else if (StochasticWeight < WeightPrefixSum.y)
	{
		StochasticCardSample = CardSampleY;
	}
	else
	{
		StochasticCardSample = CardSampleZ;
	}

	#if SURFACE_CACHE_FEEDBACK
	{
		// Write every n-th element
		if (all((ScreenCoord & SurfaceCacheFeedbackBufferTileWrapMask) == SurfaceCacheFeedbackBufferTileJitter)
			&& SurfaceCacheFeedbackBufferSize > 0
			&& StochasticCardSample.Weight > 0.1f
			&& StochasticCardSample.PackedFeedback.x > 0)
		{
			uint WriteOffset = 0;
			InterlockedAdd(RWSurfaceCacheFeedbackBufferAllocator[0], 1, WriteOffset);

			if (WriteOffset < SurfaceCacheFeedbackBufferSize)
			{
				RWSurfaceCacheFeedbackBuffer[WriteOffset] = StochasticCardSample.PackedFeedback;
			}
		}
	}
	#endif

	float3 Lighting = 0.0f;
	float Weight = 0.0f;

	const bool bUseStochasticInterpolation = false;
	if (bUseStochasticInterpolation)
	{
		AccumulateLumenCardLighting(StochasticCardSample, AtlasId, Lighting, Weight);
	}
	else
	{
		AccumulateLumenCardLighting(CardSampleX, AtlasId, Lighting, Weight);
		AccumulateLumenCardLighting(CardSampleY, AtlasId, Lighting, Weight);
		AccumulateLumenCardLighting(CardSampleZ, AtlasId, Lighting, Weight);
	}

	// Debug visualization
	#if ENABLE_VISUALIZE_MODE == 1
	{
		if (VisualizeMode == VISUALIZE_MODE_GEOMETRY_NORMALS)
		{
			Lighting = (SampleNormal * 0.5f + 0.5f) * View.OneOverPreExposure;
			Weight = 1.0f;
		}
	}
	#endif

	return float4(Lighting, Weight);
}

float3 SampleLumenMeshCards(uint2 ScreenCoord, uint DFObjectIndex, float3 SamplePosition, float3 SampleNormal, float SampleRadius, bool bAccurateHit, float CardInterpolateDepthVisibilityRadius, bool bHiResSurface, uint AtlasId)
{
	float4 LightingAndWeight = SampleLumenMeshCardsWithWeight(ScreenCoord, DFObjectIndex, SamplePosition, SampleNormal, SampleRadius, bAccurateHit, CardInterpolateDepthVisibilityRadius, bHiResSurface, AtlasId);

	if (LightingAndWeight.w > 0)
	{
		LightingAndWeight.xyz = LightingAndWeight.xyz / max(LightingAndWeight.w, 0.01f);
	}

	return LightingAndWeight.xyz;
}

void ConeTraceMeshSDFsAndInterpolateFromCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FTraceMeshSDFResult TraceMeshSDFResult;
	TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
	TraceMeshSDFResult.HitObject = 0;

	for (uint GridCulledMeshSDFIndex = 0; GridCulledMeshSDFIndex < TraceInput.NumMeshSDFs; GridCulledMeshSDFIndex++)
	{
		uint ObjectIndex = GridCulledMeshSDFObjectIndicesArray[TraceInput.MeshSDFStartOffset + GridCulledMeshSDFIndex];

		RayTraceSingleMeshSDF(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.TanConeAngle,
			TraceInput.MinTraceDistance,
			TraceInput.MaxTraceDistance, 
			ObjectIndex, 
			TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
			TraceInput.InitialMaxDistance,
			TraceMeshSDFResult);
	}

	if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance)
	{
		FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.MaxTraceDistance, 
			TraceMeshSDFResult);

		//OutResult.Lighting = frac(10 * TraceMeshSDFResult.HitDistance / TraceInput.MaxTraceDistance);
		//OutResult.Lighting = NumGridCulledMeshSDFObjects[MeshSDFGridCellIndex] / 10.0f;
		
		float3 InterpolatePosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceMeshSDFResult.HitDistance;
		float InterpolateRadius = TraceMeshSDFResult.HitDistance * TraceInput.TanConeAngle;

		//OutResult.Lighting = TraceSDFData.HitNormal * .5f + .5f;
		//OutResult.Lighting = frac(InterpolatePosition / 1000);
	
		uint AtlasId = FINAL_LIGHTING_ATLAS_ID;
		OutResult.Lighting = SampleLumenMeshCards(
			TraceInput.ScreenCoord,
			TraceMeshSDFResult.HitObject,
			InterpolatePosition,
			TraceSDFData.HitNormal,
			InterpolateRadius,
			TraceSDFData.bAccurateHit,
			TraceInput.CardInterpolateDepthVisibilityRadius,
			TraceInput.bHiResSurface,
			AtlasId);
		OutResult.Transparency = 0;
	}

	OutResult.OpaqueHitDistance = TraceMeshSDFResult.HitDistance;
}

Texture3D VoxelLighting;
// Must match C++
#define MAX_VOXEL_CLIPMAP_LEVELS 8
#define NumClipmapLevels LumenVoxelTracingParameters.NumClipmapLevels
#define ClipmapWorldToUVScale LumenVoxelTracingParameters.ClipmapWorldToUVScale
#define ClipmapWorldToUVBias LumenVoxelTracingParameters.ClipmapWorldToUVBias
#define ClipmapVoxelSizeAndRadius LumenVoxelTracingParameters.ClipmapVoxelSizeAndRadius
#define ClipmapWorldCenter LumenVoxelTracingParameters.ClipmapWorldCenter
#define ClipmapWorldExtent LumenVoxelTracingParameters.ClipmapWorldExtent
#define ClipmapWorldSamplingExtent LumenVoxelTracingParameters.ClipmapWorldSamplingExtent

float4 SampleVoxelLighting(float3 WorldPosition, float3 Direction, uint ClipmapIndex)
{
	float3 UV = WorldPosition * ClipmapWorldToUVScale[ClipmapIndex].xyz + ClipmapWorldToUVBias[ClipmapIndex].xyz;
	UV.y = (UV.y + ClipmapIndex) / (float)NumClipmapLevels;

	float4 Lighting = 0;

	float3 XAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.x > 0 ? 0 : 1.0f / 6.0f));
	float3 YAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.y > 0 ? 2.0f / 6.0f : 3.0f / 6.0f));
	float3 ZAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.z > 0 ? 4.0f / 6.0f : 5.0f / 6.0f));

	float4 XAxisLighting;
	float4 YAxisLighting;
	float4 ZAxisLighting;

	XAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, XAxisUV, 0);
	YAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, YAxisUV, 0);
	ZAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, ZAxisUV, 0);

	float3 AxisWeights = Direction * Direction;
	float InvTotalWeight = 1.0f / dot(AxisWeights, 1.0f);

	Lighting = (XAxisLighting * AxisWeights.x + YAxisLighting * AxisWeights.y + ZAxisLighting * AxisWeights.z) * InvTotalWeight;

	return Lighting.xyzw;
}

// Transparency value which is forced to zero to reduce leaking. It is softly faded-in with a VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH.
static float MIN_VOXEL_TRACE_TRANSPARENCY = 0.1f;
static float VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH = 0.05f;

float4 FadeOutVoxelConeTraceMinTransparency(float4 LightingAndAlpha)
{
	if (LightingAndAlpha.a < MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH)
	{
		// Restore missing energy due to early out.
		LightingAndAlpha.rgb *= (1.0f + LightingAndAlpha.a);

		// Smoothly force a transparency of MIN_VOXEL_TRACE_TRANSPARENCY to 0, since we stopped tracing
		LightingAndAlpha.a = saturate((LightingAndAlpha.a - MIN_VOXEL_TRACE_TRANSPARENCY) * (MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH) / VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH);
	}

	return LightingAndAlpha;
}

uint VoxelFaceFromStep(uint3 StepInc, int3 VoxelStep)
{
	uint3 DirectionOffset = VoxelStep >= 0 ? 0 : 1;
	return dot(StepInc, uint3(0, 2, 4) + DirectionOffset);
}

#if LEGACY_VOXEL_CONE_TRACING

void ConeTraceVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	float VoxelTraceStartDistance = TraceInput.VoxelTraceStartDistance;

	// Bias
	{
		bool bOutOfRange = true;
		uint LowerClipmapIndex = 0;
		for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapLevels; ++ClipmapIndex)
		{
			bOutOfRange = any(abs(TraceInput.ConeOrigin - ClipmapWorldCenter[ClipmapIndex].xyz) > ClipmapWorldSamplingExtent[ClipmapIndex].xyz);
			LowerClipmapIndex = bOutOfRange ? ClipmapIndex + 1 : LowerClipmapIndex;
		}

		if (bOutOfRange)
		{
			VoxelTraceStartDistance = TraceInput.MaxTraceDistance;
		}
		else
		{
			float LowerClipmapVoxelRadius = ClipmapVoxelSizeAndRadius[LowerClipmapIndex].w;
			VoxelTraceStartDistance = max(VoxelTraceStartDistance, LowerClipmapVoxelRadius * 2.0f);
		}
	}

	uint StartClipmapIndex = ComputeGlobalDistanceFieldClipmapIndex(TraceInput.ConeOrigin);
	float4 LightingAndAlpha = float4(0, 0, 0, 1);
	uint TotalNumSteps = 0;
	float MinRayTime = VoxelTraceStartDistance / TraceInput.MaxTraceDistance;
	float SampleRayTime = 0;

	LOOP
	for (uint ClipmapIndex = StartClipmapIndex; ClipmapIndex < NumGlobalSDFClipmaps && LightingAndAlpha.a > MIN_VOXEL_TRACE_TRANSPARENCY; ClipmapIndex++)
	{
		float MinStepSize = TraceInput.VoxelStepFactor * GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize; 
		const float ClipmapInfluenceRange = GLOBAL_DISTANCE_FIELD_INFLUENCE_RANGE_IN_VOXELS * 2.0f * GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize;
		float3 GlobalVolumeCenter = GlobalVolumeCenterAndExtent[ClipmapIndex].xyz;
		float GlobalVolumeExtent = GlobalVolumeCenterAndExtent[ClipmapIndex].w;
		float3 VolumeRayStart = TraceInput.ConeOrigin - GlobalVolumeCenter;
		
		float3 WorldRayEnd = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
		float2 IntersectionTimes = LineBoxIntersect(TraceInput.ConeOrigin, WorldRayEnd, GlobalVolumeCenter - GlobalVolumeExtent.xxx, GlobalVolumeCenter + GlobalVolumeExtent.xxx);
		IntersectionTimes.x = max(IntersectionTimes.x, MinRayTime);

		// Update the trace start for the next clipmap
		MinRayTime = IntersectionTimes.y;

		if (IntersectionTimes.x < IntersectionTimes.y)
		{
			SampleRayTime = IntersectionTimes.x * TraceInput.MaxTraceDistance;

			uint StepIndex = 0;
			uint MaxSteps = 256;

			uint VoxelClipmapIndex = 0;
			float SampleClipmapVoxelRadius = ClipmapVoxelSizeAndRadius[0].w;

			LOOP
			for (; StepIndex < MaxSteps; StepIndex++)
			{
				float3 SampleWorldPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * SampleRayTime;
				float3 MipUV = ComputeGlobalMipUV(SampleWorldPosition, ClipmapIndex);
				float DistanceFieldMipValue = Texture3DSampleLevel(GlobalDistanceFieldMipTexture, GlobalTrilinearWrappedSampler, MipUV, 0).x;
				float DistanceField = DecodeGlobalDistanceFieldPageDistance(DistanceFieldMipValue, GlobalDistanceFieldMipFactor * ClipmapInfluenceRange);
				float StepSphereRadius = SampleRayTime * TraceInput.TanConeAngle;

				float3 VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
				float3 VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;

				//@todo - align voxel clipmaps to global SDF clipmaps and we can get rid of these bounds checks
				bool bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);

				// Find the voxel clipmap that matches the cone width at the current step
				while ((StepSphereRadius > 2 * SampleClipmapVoxelRadius || bOutsideValidRegion)
					&& VoxelClipmapIndex + 1 < NumClipmapLevels)
				{
					VoxelClipmapIndex++;
					SampleClipmapVoxelRadius *= 2.0f;
					VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
					VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;
					bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);
				}

				// Approximate SDF visibility using smaller (0.75) cone to stop leaking from voxels
				float ConeVisibility = saturate(DistanceField / min(0.75 * StepSphereRadius, MaxGlobalDFAOConeDistance));

				if (DistanceField < SampleClipmapVoxelRadius && !bOutsideValidRegion)
				{
					float4 StepLighting = SampleVoxelLighting(SampleWorldPosition, TraceInput.ConeDirection, VoxelClipmapIndex);
					LightingAndAlpha.rgb += StepLighting.rgb * LightingAndAlpha.a;
					//@todo - compensate for step size not matching voxel size 
					LightingAndAlpha.a *= 1 - StepLighting.a;

					// Apply approximate SDF visibility and restore missing energy
					float PrevAlpha = LightingAndAlpha.a;
					LightingAndAlpha.a = min(LightingAndAlpha.a, ConeVisibility);
					LightingAndAlpha.rgb *= (1.0f + max(PrevAlpha - LightingAndAlpha.a, 0.0f));
				}

				float StepDistance = max(DistanceField * TraceInput.SDFStepFactor, MinStepSize);
				SampleRayTime += StepDistance;

				// Terminate the trace if we went past the end of the ray or achieved enough occlusion
				if (SampleRayTime > IntersectionTimes.y * TraceInput.MaxTraceDistance 
					|| LightingAndAlpha.a < MIN_VOXEL_TRACE_TRANSPARENCY)
				{
					break;
				}
			}

			TotalNumSteps += StepIndex;
		}
	}

	LightingAndAlpha = FadeOutVoxelConeTraceMinTransparency(LightingAndAlpha);

	OutResult = (FConeTraceResult)0;
	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = LightingAndAlpha.rgb;
	#endif
	OutResult.Transparency = LightingAndAlpha.a;
	OutResult.NumSteps = TotalNumSteps;
	OutResult.OpaqueHitDistance = SampleRayTime;
}

#else

void ConeTraceVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FGlobalSDFTraceResult SDFTraceResult;

	// Trace SDF ray
	{
		FGlobalSDFTraceInput SDFTraceInput = SetupGlobalSDFTraceInput(TraceInput.ConeOrigin, TraceInput.ConeDirection, TraceInput.MinTraceDistance, TraceInput.MaxTraceDistance, TraceInput.SDFStepFactor, TraceInput.VoxelStepFactor);
		SDFTraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
		SDFTraceInput.InitialMaxDistance = TraceInput.InitialMaxDistance;

		SDFTraceResult = RayTraceGlobalDistanceField(SDFTraceInput);
	}

	float4 LightingAndAlpha = float4(0, 0, 0, 1);

	if (GlobalSDFTraceResultIsHit(SDFTraceResult))
	{
		float3 SampleWorldPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * SDFTraceResult.HitTime;

		uint VoxelClipmapIndex = 0;
		float3 VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
		float3 VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;

		bool bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);

		// Find the voxel clipmap that matches the cone width at the current step
		while (bOutsideValidRegion && VoxelClipmapIndex + 1 < NumClipmapLevels)
		{
			VoxelClipmapIndex++;
			VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
			VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;
			bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);
		}

		LightingAndAlpha.xyzw = 0.0f;

		if (!bOutsideValidRegion)
		{
			float3 DistanceFieldGradient = -TraceInput.ConeDirection;

			float3 ClipmapVolumeUV = ComputeGlobalUV(SampleWorldPosition, SDFTraceResult.HitClipmapIndex);
			uint PageIndex = GetGlobalDistanceFieldPage(ClipmapVolumeUV, SDFTraceResult.HitClipmapIndex);

			if (PageIndex < GLOBAL_DISTANCE_FIELD_INVALID_PAGE_ID)
			{
				float3 PageUV = ComputeGlobalDistanceFieldPageUV(ClipmapVolumeUV, PageIndex);
				DistanceFieldGradient = GlobalDistanceFieldPageCentralDiff(PageUV);
			}

			float DistanceFieldGradientLength = length(DistanceFieldGradient);
			float3 SampleNormal = DistanceFieldGradientLength > 0.001 ? DistanceFieldGradient / DistanceFieldGradientLength : -TraceInput.ConeDirection;

			float4 StepLighting = SampleVoxelLighting(SampleWorldPosition, -SampleNormal, VoxelClipmapIndex);

			StepLighting.xyz = StepLighting.xyz * (1.0f / max(StepLighting.w, 0.1));

			float VoxelSelfLightingBias = 1.0f;
			if (TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance)
			{
				// For diffuse rays prefer to over occlude instead of leaking
				VoxelSelfLightingBias = smoothstep(1.5 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, 2.0 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, SDFTraceResult.HitTime);
			}

			LightingAndAlpha.xyz = StepLighting.xyz * VoxelSelfLightingBias;
		}
	}

	LightingAndAlpha = FadeOutVoxelConeTraceMinTransparency(LightingAndAlpha);

	OutResult = (FConeTraceResult)0;
	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = LightingAndAlpha.rgb;
	#endif
	OutResult.Transparency = LightingAndAlpha.a;
	OutResult.NumSteps = SDFTraceResult.TotalStepsTaken;
	OutResult.OpaqueHitDistance = GlobalSDFTraceResultIsHit(SDFTraceResult) ? SDFTraceResult.HitTime : TraceInput.MaxTraceDistance;
}

#endif

float ComputeSquaredDistanceBetweenAABBs(float3 CenterA, float3 ExtentA, float3 CenterB, float3 ExtentB)
{
	float3 AxisDistances = max(abs(CenterB - CenterA) - (ExtentA + ExtentB), 0);
	return dot(AxisDistances, AxisDistances);
}

float CalculateVoxelTraceStartDistance(float MinTraceDistance, float MaxTraceDistance, float MaxMeshSDFTraceDistance, bool bContinueCardTracing)
{
	float VoxelTraceStartDistance = MaxTraceDistance;

	if (NumClipmapLevels > 0)
	{
		VoxelTraceStartDistance = MinTraceDistance;

		if (bContinueCardTracing)
		{
			VoxelTraceStartDistance = max(VoxelTraceStartDistance, MaxMeshSDFTraceDistance);
		}
	}

	return VoxelTraceStartDistance;
}

// For debugging
#define SCENE_TRACE_CARDS 1
#define SCENE_TRACE_VOXELS 1

void ConeTraceLumenSceneCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	OutResult = (FConeTraceResult)0;
	OutResult.Transparency = 1;

#if SCENE_TRACE_CARDS
	if (TraceInput.VoxelTraceStartDistance > TraceInput.MinTraceDistance)
	{
		FConeTraceInput CardTraceInput = TraceInput;
		CardTraceInput.MaxTraceDistance = TraceInput.VoxelTraceStartDistance;

		ConeTraceMeshSDFsAndInterpolateFromCards(CardTraceInput, OutResult);
	}
#endif
}

void ConeTraceLumenSceneVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
#if SCENE_TRACE_VOXELS
	if (TraceInput.VoxelTraceStartDistance < TraceInput.MaxTraceDistance)
	{
		FConeTraceInput VoxelTraceInput = TraceInput;
		VoxelTraceInput.MinTraceDistance = TraceInput.VoxelTraceStartDistance;
		FConeTraceResult VoxelTraceResult;
		ConeTraceVoxels(VoxelTraceInput, VoxelTraceResult);

		#if !VISIBILITY_ONLY_TRACE
			OutResult.Lighting += VoxelTraceResult.Lighting * OutResult.Transparency;
		#endif
		OutResult.Transparency *= VoxelTraceResult.Transparency;
		OutResult.NumSteps += VoxelTraceResult.NumSteps;
		OutResult.OpaqueHitDistance = min(OutResult.OpaqueHitDistance, VoxelTraceResult.OpaqueHitDistance);
	}
#endif
}

void ConeTraceLumenScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	ConeTraceLumenSceneCards(TraceInput, OutResult);
	ConeTraceLumenSceneVoxels(TraceInput, OutResult);
}

void ConeTraceLumenDistantScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	float3 debug = 0;
	TraceInput.MaxTraceDistance = LumenCardScene.DistantSceneMaxTraceDistance;
	TraceInput.bBlackOutSteepIntersections = true;

	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);

	if (LumenCardScene.NumDistantCards > 0)
	{
		if (NumClipmapLevels > 0)
		{
			float3 VoxelLightingCenter = ClipmapWorldCenter[NumClipmapLevels - 1].xyz;
			float3 VoxelLightingExtent = ClipmapWorldSamplingExtent[NumClipmapLevels - 1].xyz;

			float3 RayEnd = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
			float2 IntersectionTimes = LineBoxIntersect(TraceInput.ConeOrigin, RayEnd, VoxelLightingCenter - VoxelLightingExtent, VoxelLightingCenter + VoxelLightingExtent);

			// If we are starting inside the voxel clipmaps, move the start of the trace past the voxel clipmaps
			if (IntersectionTimes.x < IntersectionTimes.y && IntersectionTimes.x < .001f)
			{
				TraceInput.MinTraceDistance = IntersectionTimes.y * TraceInput.MaxTraceDistance;
			}
		}

		float TraceEndDistance = TraceInput.MinTraceDistance;

		// Multiple cascades disabled for now - artifacts when resuming traces between cascades, and shader has worse occupancy
		//for (uint ListIndex = 0; ListIndex < LumenCardScene.NumDistantCards && CardTraceBlendState.HasRemainingVisibility(TraceInput.MaxTraceDistance); ListIndex++)
		{
			//TraceInput.MinTraceDistance = TraceEndDistance;
			uint ListIndex = 0;
			uint CardIndex = LumenCardScene.DistantCardIndices[ListIndex];

			ConeTraceSingleLumenCard(
				TraceInput,
				CardIndex,
				debug,
				TraceEndDistance,
				CardTraceBlendState);
		}
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

float TanConeAngleToRoughness(float TanConeAngle)
{
	//@todo DynamicGI - derive roughness from cone angle
	return sqrt(saturate(TanConeAngle / (.5f * PI)));
}

void EvaluateSkyRadianceForCone(
	float3 ConeDirection, 
	float TanConeAngle, 
	inout FConeTraceResult TraceResult)
{ 
#if ENABLE_DYNAMIC_SKY_LIGHT
	if (ReflectionStruct.SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;
		float Roughness = TanConeAngleToRoughness(TanConeAngle);

		#if !VISIBILITY_ONLY_TRACE
			TraceResult.Lighting += GetSkyLightReflection(ConeDirection, Roughness, SkyAverageBrightness) * TraceResult.Transparency;
		#endif
		TraceResult.Transparency = 0;
	}
#endif
}
