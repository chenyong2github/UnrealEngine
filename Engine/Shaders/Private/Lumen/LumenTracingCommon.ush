// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenTracingCommon.ush
=============================================================================*/

#include "../ReflectionEnvironmentShared.ush"
#include "../BRDF.ush"
#include "../FastMath.ush"
#include "../SHCommon.ush"
#define DISTANCE_FIELD_IN_VIEW_UB 1
#include "../GlobalDistanceFieldShared.ush"
#include "../GlobalDistanceFieldUtils.ush"
#include "../DistanceFieldLightingShared.ush"

Texture2D FinalLightingAtlas;
Texture2D IrradianceAtlas;
Texture2D IndirectIrradianceAtlas;
#define FINAL_LIGHTING_ATLAS_ID 0
#define IRRADIANCE_ATLAS_ID 1
#define INDIRECT_IRRADIANCE_ATLAS_ID 2

Texture2D OpacityAtlas;
Texture2D DilatedDepthAtlas;
Texture3D<uint> CubeMapTreeLUTAtlas;

#ifndef VISIBILITY_ONLY_TRACE
	#define VISIBILITY_ONLY_TRACE 0
#endif

#ifndef DEPTH_WEIGHTED_OIT_32_BIT
	#define DEPTH_WEIGHTED_OIT_32_BIT 1
#endif

#ifndef ENABLE_DYNAMIC_SKY_LIGHT
	#define ENABLE_DYNAMIC_SKY_LIGHT 1
#endif

#define MIN_flt			(1.175494351e-38F)			/* min positive value */

#if CARD_TRACE_DEPTH_WEIGHTED_OIT

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float Revealage;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		Revealage = 1;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	float ComputeDepthWeight(float InDepth, float InOpacity)
	{
#if DEPTH_WEIGHTED_OIT_32_BIT
		// From Weighted Blended Order-Independent Transparency
		//@todo - make full use of 32 bit fp, original functions were crafted for 16 bit fp render targets but we are using shader temporaries
		//@todo - try 64 bit fp
	#define HEURISTIC 2
	#if HEURISTIC == 0
		float A = InDepth / 50.0f;
		float B = InDepth / 2000.0f;
		float B2 = B * B;
		float B6 = B2 * B2 * B2;
		return InOpacity * max(.01f, min(10000000.0f, 10.0f / (.00001f + A * A + B6)));
	#elif HEURISTIC == 1
		float ZNear = 10.0f;
		float ZFar = 100000.0f;
		float D = saturate(((ZNear * ZFar) / InDepth - ZFar) / (ZNear - ZFar));
		float InvD = 1 - D;
		return InOpacity * max(.01f, 1000000.0f * InvD * InvD * InvD);
	#elif HEURISTIC == 2
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		float b2 = b * b;
		float b4 = b2 * b2;
		return min(10000 * b4 * b4, 30000) * a * a * a;
	#endif
#else
		// 16 bit fp version
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		return min(10000 * b * b * b + 5, 20) * a * a * a;
#endif
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		float4 WeightedLighting = float4(InLighting * InOpacity, InOpacity) * ComputeDepthWeight(InDepth, InOpacity);
		LightingAndOpacity += WeightedLighting;
		Revealage *= (1 - InOpacity);
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity += InBlendState.LightingAndOpacity;
		Revealage *= InBlendState.Revealage;
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
		NumOverlaps++;
	}

	float3 GetFinalLighting()
	{
		float ClampedWeightedOpacity = max(LightingAndOpacity.a, MIN_flt);
		return LightingAndOpacity.rgb / ClampedWeightedOpacity * (1 - Revealage);
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return Revealage;
	}
};

#else

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float NumSteps;
	float OpaqueHitDistance;
	float NumOverlaps;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		if (InDepth < OpaqueHitDistance)
		{
			LightingAndOpacity.xyz = InLighting;
			LightingAndOpacity.w = InOpacity;
			OpaqueHitDistance = InDepth;
		}
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		// This is done in AddLighting
		//OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity.xyz += InBlendState.LightingAndOpacity.xyz;
		LightingAndOpacity.w = max(LightingAndOpacity.w, InBlendState.LightingAndOpacity.w);
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
	}

	float3 GetFinalLighting()
	{
		return LightingAndOpacity.xyz;
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return 1.0f - LightingAndOpacity.w;
	}
};

#endif

float2 CalculateValidRegionScale(float Mip, float2 CardUVToAtlasScale)
{
	float2 LowerResolutionMipSizeTexels = exp2(LumenCardScene.NumMips - 1 - Mip) * CardUVToAtlasScale;
	return (LowerResolutionMipSizeTexels - 1) / LowerResolutionMipSizeTexels;
}

void CalculateMip(float SampleRadius, FLumenCardData CardData, float3 FaceLocalExtent, float CardMaxMip, out float MaxMip, out float2 ValidRegionScale)
{
	float2 SampleSizeTexels = abs(SampleRadius * CardData.LocalPositionToAtlasUVScale * LumenCardScene.AtlasSize);
	float2 Mip = clamp(log2(SampleSizeTexels), 0, CardMaxMip);
	MaxMip = max(Mip.x, Mip.y);
	float LowerResolutionMip = MaxMip + 1;
	float2 CardUVToAtlasScale = GetCardUVToAtlasScale(CardData.LocalPositionToAtlasUVScale, FaceLocalExtent);
	ValidRegionScale = CalculateValidRegionScale(LowerResolutionMip, CardUVToAtlasScale);
}

float2 CalculateAtlasUV(float2 LocalPosition, float2 ValidRegionScale, FLumenCardData CardData)
{
	return LocalPosition * CardData.LocalPositionToAtlasUVScale * ValidRegionScale + CardData.LocalPositionToAtlasUVBias;
}

//https://iquilezles.org/www/articles/smin/smin.htm
float SmoothMin2( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return lerp( b, a, h ) - k*h*(1.0-h);
}

float ComputeBorderFadeDistance(float2 BoxMin, float2 BoxMax, float2 InPoint)
{
	float2 DistancesToMin = max(InPoint - BoxMin, 0);
	float2 DistancesToMax = max(BoxMax - InPoint, 0);
	float2 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return SmoothMin2(ClosestDistances.x, ClosestDistances.y, 100.0f);
}

#define TRACING_ATLAS_SAMPLER GlobalTrilinearClampedSampler

struct FConeTraceInput
{
	float3 ConeOrigin;
	float3 ConeDirection;
	
	float ConeAngle;
	float TanConeAngle;

	float ConeStartRadius;
	float MinSampleRadius;
	float MinTraceDistance;
	float MaxTraceDistance;

	float StepFactor;
	float VoxelStepFactor;
	float VoxelTraceStartDistance;
	float SDFStepFactor;
	bool bBlackOutSteepIntersections;
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
	float InitialMaxDistance;

	// Mesh SDF traces
	uint NumMeshSDFs;
	uint MeshSDFStartOffset;
	uint MeshSDFBitmaskStartOffset;
	float CardInterpolateInfluenceRadius;
	float CardInterpolateDepthVisibilityRadius;

	void Setup(
		float3 InConeOrigin,
		float3 InConeDirection,
		float InConeAngle,
		float InMinSampleRadius,
		float InMinTraceDistance,
		float InMaxTraceDistance,
		float InStepFactor)
	{
		ConeOrigin = InConeOrigin;
		ConeDirection = InConeDirection;
		ConeAngle = InConeAngle;
		TanConeAngle = tan(ConeAngle);
		ConeStartRadius = 0;
		MinSampleRadius = InMinSampleRadius;
		MinTraceDistance = InMinTraceDistance;
		MaxTraceDistance = InMaxTraceDistance;
		StepFactor = InStepFactor;
		VoxelStepFactor = .7f;
		VoxelTraceStartDistance = InMaxTraceDistance;

		// The global SDF often overestimates due to the way distances outside of an object SDF are calculated, can be corrected by stepping slower, but increases trace cost
		SDFStepFactor = 1;
		bBlackOutSteepIntersections = false;
		bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = true;
		InitialMaxDistance = 0;
	}
};

struct FConeTraceResult
{
#if !VISIBILITY_ONLY_TRACE
	float3 Lighting;
#endif
	float Transparency;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;
	float3 Debug;
};

void ConeTraceSingleLumenCard(
	FConeTraceInput TraceInput,
	uint CardIndex,
	inout float3 Debug,
	inout float OutTraceEndDistance,
	inout FCardTraceBlendState CardTraceBlendState)
{
	FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

	float3 LocalConeOrigin = mul(TraceInput.ConeOrigin - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
	float3 LocalConeDirection = mul(TraceInput.ConeDirection, LumenCardData.WorldToLocalRotation);
	float3 LocalTraceEnd = LocalConeOrigin + LocalConeDirection * TraceInput.MaxTraceDistance;

	float2 IntersectionRange = LineBoxIntersect(LocalConeOrigin, LocalTraceEnd, -LumenCardData.LocalExtent, LumenCardData.LocalExtent);
	IntersectionRange.x = max(IntersectionRange.x, TraceInput.MinTraceDistance / TraceInput.MaxTraceDistance);
	OutTraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

	if (IntersectionRange.y > IntersectionRange.x
		&& LumenCardData.bVisible)
	{
		{
			FCardTraceBlendState ConeStepBlendState;
			ConeStepBlendState.Initialize(TraceInput.MaxTraceDistance);

			float StepTime = IntersectionRange.x * TraceInput.MaxTraceDistance;
			float3 SamplePosition = LocalConeOrigin + StepTime * LocalConeDirection;
			float TraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

			float IntersectionLength = (IntersectionRange.y - IntersectionRange.x) * TraceInput.MaxTraceDistance;
			float MinStepSize = IntersectionLength / (float)LumenCardScene.MaxConeSteps;

			float PreviousStepTime = StepTime;
			float3 PreviousSamplePosition = SamplePosition;
			// Magic value to prevent linear intersection approximation on first step
			float PreviousHeightfieldZ = -2;

			bool bClampedToEnd = false;
			bool bFoundSurface = false;
			bool bRayAboveSurface = false;
			float IntersectionStepTime = 0;
			float2 IntersectionSamplePositionXY = SamplePosition.xy;
			float IntersectionSlope = 0;

			uint NumStepsPerLoop = 4;
			for (uint StepIndex = 0; StepIndex < LumenCardScene.MaxConeSteps && StepTime < TraceEndDistance; StepIndex += NumStepsPerLoop)
			{
				float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * StepTime, TraceInput.MinSampleRadius);
				float StepSize = max(SampleRadius * TraceInput.StepFactor, MinStepSize);
				float TraceClampDistance = TraceEndDistance - StepSize * .0001f;

				float DepthMip;
				float2 DepthValidRegionScale;
				CalculateMip(SampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, DepthMip, DepthValidRegionScale);

				float3 SamplePosition1 = LocalConeOrigin + min(StepTime + 0 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition2 = LocalConeOrigin + min(StepTime + 1 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition3 = LocalConeOrigin + min(StepTime + 2 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition4 = LocalConeOrigin + min(StepTime + 3 * StepSize, TraceClampDistance) * LocalConeDirection;

				float2 DepthAtlasUV1 = CalculateAtlasUV(SamplePosition1.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV2 = CalculateAtlasUV(SamplePosition2.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV3 = CalculateAtlasUV(SamplePosition3.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV4 = CalculateAtlasUV(SamplePosition4.xy, DepthValidRegionScale, LumenCardData);

				float Depth1 = Texture2DSampleLevel(DilatedDepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV1, DepthMip).x;
				float Depth2 = Texture2DSampleLevel(DilatedDepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV2, DepthMip).x;
				float Depth3 = Texture2DSampleLevel(DilatedDepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV3, DepthMip).x;
				float Depth4 = Texture2DSampleLevel(DilatedDepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV4, DepthMip).x;

				float HeightfieldZ1 = LumenCardData.LocalExtent.z - Depth1 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ2 = LumenCardData.LocalExtent.z - Depth2 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ3 = LumenCardData.LocalExtent.z - Depth3 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ4 = LumenCardData.LocalExtent.z - Depth4 * 2 * LumenCardData.LocalExtent.z;

				ConeStepBlendState.RegisterStep(NumStepsPerLoop);

				bool4 HeightfieldHit = bool4(
					SamplePosition1.z < HeightfieldZ1,
					SamplePosition2.z < HeightfieldZ2,
					SamplePosition3.z < HeightfieldZ3,
					SamplePosition4.z < HeightfieldZ4);

				bool bRayBelowHeightfield = any(HeightfieldHit);
				bool bRayWasAboveSurface = bRayAboveSurface;

				if (!bRayBelowHeightfield)
				{
					bRayAboveSurface = true;
				}

				// Traces which started below the heightfield have to get above before they can register a hit
				if (bRayBelowHeightfield && bRayWasAboveSurface)
				{
					float HeightfieldZ;
					if (HeightfieldHit.x)
					{
						SamplePosition = SamplePosition1;
						HeightfieldZ = HeightfieldZ1;
						StepTime = StepTime + 0 * StepSize;
					}
					else if (HeightfieldHit.y)
					{
						PreviousSamplePosition = SamplePosition1;
						PreviousHeightfieldZ = HeightfieldZ1;
						PreviousStepTime = StepTime + 0 * StepSize;

						SamplePosition = SamplePosition2;
						HeightfieldZ = HeightfieldZ2;
						StepTime = StepTime + 1 * StepSize;
					}
					else if (HeightfieldHit.z)
					{
						PreviousSamplePosition = SamplePosition2;
						PreviousHeightfieldZ = HeightfieldZ2;
						PreviousStepTime = StepTime + 1 * StepSize;

						SamplePosition = SamplePosition3;
						HeightfieldZ = HeightfieldZ3;
						StepTime = StepTime + 2 * StepSize;
					}
					else
					{
						PreviousSamplePosition = SamplePosition3;
						PreviousHeightfieldZ = HeightfieldZ3;
						PreviousStepTime = StepTime + 2 * StepSize;

						SamplePosition = SamplePosition4;
						HeightfieldZ = HeightfieldZ4;
						StepTime = StepTime + 3 * StepSize;
					}

					StepTime = min(StepTime, TraceClampDistance);

					if (PreviousHeightfieldZ != -2)
					{
						// Construct a linear approximation of both the SamplePosition z and heightfield z between the previous step and this step: y = m * x + b
						// SamplePosition z linear approximation:
						// y = (SamplePosition.z - PreviousSampleZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousSampleZ
						// Heightfield z linear approximation:
						// y = (HeightfieldZ - PreviousHeightfieldZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousHeightfieldZ 

						// Solve for x where they intersect
						IntersectionStepTime = PreviousStepTime + ((PreviousSamplePosition.z - PreviousHeightfieldZ) * (StepTime - PreviousStepTime)) / (HeightfieldZ - PreviousHeightfieldZ + PreviousSamplePosition.z - SamplePosition.z);

						float2 LocalPositionSlopeXY = (SamplePosition.xy - PreviousSamplePosition.xy) / (StepTime - PreviousStepTime);
						IntersectionSamplePositionXY = LocalPositionSlopeXY * (IntersectionStepTime - PreviousStepTime) + PreviousSamplePosition.xy;

						IntersectionSlope = abs(PreviousHeightfieldZ - HeightfieldZ) / max(length(PreviousSamplePosition.xy - SamplePosition.xy), .0001f);

						PreviousHeightfieldZ = -2;
						bFoundSurface = true;
					}
					break;
				}

				PreviousStepTime = StepTime + 3 * StepSize;
				PreviousSamplePosition = SamplePosition4;
				PreviousHeightfieldZ = HeightfieldZ4;
				StepTime += 4 * StepSize;

				if (StepTime >= TraceEndDistance && !bClampedToEnd)
				{
					bClampedToEnd = true;
					// Stop the last step just before the intersection end, since the linear approximation needs to step past the surface to detect a hit, without terminating the loop
					StepTime = TraceClampDistance;
				}
			}

			if (bFoundSurface)
			{
				float IntersectionSampleRadius = TraceInput.ConeStartRadius + TraceInput.TanConeAngle * IntersectionStepTime;

				float MaxMip;
				float2 ValidRegionScale;
				CalculateMip(IntersectionSampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, MaxMip, ValidRegionScale);

				float2 IntersectionAtlasUV = CalculateAtlasUV(IntersectionSamplePositionXY, ValidRegionScale, LumenCardData);

				float DistanceToSurface = 0;
				float ConeIntersectSurface = saturate(DistanceToSurface / IntersectionSampleRadius);
				float ConeVisibility = ConeIntersectSurface;

				float MaxDistanceFade = 1; // saturate((TraceInput.MaxTraceDistance - IntersectionStepTime) * TraceInput.InvMaxDistanceFadeLength);

				ConeStepBlendState.RegisterOpaqueHit(IntersectionStepTime);
				OutTraceEndDistance = IntersectionStepTime;

				float Opacity = Texture2DSampleLevel(OpacityAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).x;
				float ConeOcclusion = (1.0f - ConeVisibility) * Opacity * MaxDistanceFade;

				#if VISIBILITY_ONLY_TRACE
					float3 StepLighting = 0;
				#else
					float3 StepLighting = Texture2DSampleLevel(FinalLightingAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb;
					//float3 StepLighting = Pow2(Texture2DSampleLevel(LumenCardScene.AlbedoAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb);
				#endif
			
				if (TraceInput.bBlackOutSteepIntersections)
				{
					// Assume steep sections are covered by other faces and fade out.
					float SlopeFade = 1 - saturate((IntersectionSlope - 5) / 1.0f);
					StepLighting = lerp(0, StepLighting, SlopeFade);
					ConeOcclusion = lerp(0, ConeOcclusion, SlopeFade);
				}

				ConeStepBlendState.AddLighting(StepLighting, ConeOcclusion, IntersectionStepTime);
			}

			CardTraceBlendState.AddCardTrace(ConeStepBlendState);
		}
	}
}

Buffer<uint> CulledCardGridData;

void ConeTraceLumenCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);
	float3 ConeEndPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
	float3 debug = 0;
	float TraceEndDistance = 0;

	for (uint CardIndex = 0; CardIndex < LumenCardScene.NumCards; CardIndex++)
	{
		ConeTraceSingleLumenCard(
			TraceInput,
			CardIndex,
			debug,
			TraceEndDistance,
			CardTraceBlendState);
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

// Mesh SDF cull grid
Buffer<uint> NumGridCulledMeshSDFObjects;
Buffer<uint> GridCulledMeshSDFObjectStartOffsetArray;
Buffer<uint> GridCulledMeshSDFObjectIndicesArray;

float3 CalculateMeshSDFGradient(float3 VolumeUV, float2 DistanceFieldMAD)
{
	// Mesh distance fields 1 texel border and can't bilinear sample further than 0.5 texel from that border
	float3 VoxelOffset = 0.5f * DistanceFieldAtlasTexelSize;

	float R = SampleMeshDistanceField(float3(VolumeUV.x + VoxelOffset.x, VolumeUV.y, VolumeUV.z), DistanceFieldMAD);
	float L = SampleMeshDistanceField(float3(VolumeUV.x - VoxelOffset.x, VolumeUV.y, VolumeUV.z), DistanceFieldMAD);
	float F = SampleMeshDistanceField(float3(VolumeUV.x, VolumeUV.y + VoxelOffset.y, VolumeUV.z), DistanceFieldMAD);
	float B = SampleMeshDistanceField(float3(VolumeUV.x, VolumeUV.y - VoxelOffset.y, VolumeUV.z), DistanceFieldMAD);
	float U = SampleMeshDistanceField(float3(VolumeUV.x, VolumeUV.y, VolumeUV.z + VoxelOffset.z), DistanceFieldMAD);
	float D = SampleMeshDistanceField(float3(VolumeUV.x, VolumeUV.y, VolumeUV.z - VoxelOffset.z), DistanceFieldMAD);

	float3 Gradient = float3(R - L, F - B, U - D);
	return Gradient;
}

struct FTraceMeshSDFResult
{
	float HitDistance;
	uint HitObject;
	bool bRayStartInsideGeometry;
};

void RayTraceSingleMeshSDF(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TanConeHalfAngle,
	float MinTraceDistance,
	float MaxTraceDistance, 
	uint ObjectIndex,
	// The SDF surface is expanded to reduce leaking through thin surfaces, especially foliage meshes with bGenerateDistanceFieldAsIfTwoSided
	// Expanding as RayTime increases errors on the side of over-occlusion, especially at grazing angles, which can be desirable for diffuse GI.
	// Expanding as MaxDistance increases has less incorrect self-intersection which is desirable for reflections rays.
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
	float InitialMaxDistance,
	inout FTraceMeshSDFResult TraceResult)
{
	FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

	// #lumen_todo: continue tracing from last TraceResult.HitDistance. At the moment this causes nondeterministic flickering of surfaces.
	float3 WorldRayEnd = WorldRayStart + WorldRayDirection * MaxTraceDistance;
	float3 VolumeRayStart = mul(float4(WorldRayStart, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayEnd = mul(float4(WorldRayEnd, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayDirection = VolumeRayEnd - VolumeRayStart;

	float VolumeMaxTraceDistance = length(VolumeRayDirection);
	float VolumeMinTraceDistance = VolumeMaxTraceDistance * (MinTraceDistance / MaxTraceDistance);
	VolumeRayDirection /= VolumeMaxTraceDistance;

	float2 IntersectionTimes = LineBoxIntersect(VolumeRayStart, VolumeRayEnd, -DFObjectData.LocalPositionExtent, DFObjectData.LocalPositionExtent);

	IntersectionTimes *= VolumeMaxTraceDistance;
	IntersectionTimes.x = max(IntersectionTimes.x, VolumeMinTraceDistance);

	BRANCH
	if (IntersectionTimes.x < IntersectionTimes.y)
	{
		bool bRayStartInsideGeometry = false;
		float SampleRayTime = IntersectionTimes.x;
		uint MaxSteps = 64;
		float MinStepSize = 1.0f / (4 * MaxSteps);
		uint StepIndex = 0;
		bool bHit = false;
		float MaxDistance = InitialMaxDistance;

		LOOP
		for (; StepIndex < MaxSteps; StepIndex++)
		{
			float3 SampleVolumePosition = VolumeRayStart + VolumeRayDirection * SampleRayTime;
			float3 VolumeUV = DistanceFieldVolumePositionToUV(SampleVolumePosition, DFObjectData.UVScale, DFObjectData.UVAdd);
			float DistanceField = SampleMeshDistanceField(VolumeUV, DFObjectData.DistanceFieldMAD).x;

			MaxDistance = max(DistanceField, MaxDistance);
			float ExpandSurfaceTime = bExpandSurfaceUsingRayTimeInsteadOfMaxDistance ? SampleRayTime : MaxDistance;

			// Expand the surface to find thin features, but only away from the start of the trace where it won't introduce incorrect self-occlusion
			// This still causes incorrect self-occlusion at grazing angles
			float ExpandSurfaceDistance = DFObjectData.LocalSurfaceBias;
			const float ExpandSurfaceFalloff = 2.0f * ExpandSurfaceDistance;
			const float ExpandSurfaceAmount = ExpandSurfaceDistance * saturate(ExpandSurfaceTime / ExpandSurfaceFalloff);

			if (DistanceField < ExpandSurfaceAmount)
			{
				// One more step to the surface
				bRayStartInsideGeometry = SampleRayTime <= 0.0f && SampleRayTime + DistanceField < 0.0f ? true : false;
				SampleRayTime = clamp(SampleRayTime + DistanceField - ExpandSurfaceAmount, IntersectionTimes.x, IntersectionTimes.y);
				bHit = true;
				break;
			}

			float StepDistance = max(DistanceField, MinStepSize);
			SampleRayTime += StepDistance;		

			if (SampleRayTime > IntersectionTimes.y + ExpandSurfaceAmount)
			{
				break;
			}
		}

		if (StepIndex == MaxSteps)
		{
			bHit = true;
		}

		if (bHit)
		{
			float NewHitDistance = length(VolumeRayDirection * SampleRayTime * DFObjectData.VolumeToLocalScale);

			if (NewHitDistance < TraceResult.HitDistance)
			{
				TraceResult.HitObject = ObjectIndex;
				TraceResult.HitDistance = NewHitDistance;
				TraceResult.bRayStartInsideGeometry = bRayStartInsideGeometry;
			}
		}
	}
}

struct FTraceMeshSDFDerivedData
{
	float3 HitNormal;
	bool bAccurateHit;
};

FTraceMeshSDFDerivedData CalculateMeshSDFDerivedData(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TraceDistance,
	FTraceMeshSDFResult TraceMeshSDFResult)
{
	FTraceMeshSDFDerivedData TraceSDFData;

	uint ObjectIndex = TraceMeshSDFResult.HitObject;
	FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

	TraceSDFData.bAccurateHit = !DFObjectData.bGeneratedAsTwoSided;

	if (TraceSDFData.bAccurateHit)
	{
		float3 HitPosition = WorldRayStart + WorldRayDirection * TraceMeshSDFResult.HitDistance;
		float3 SampleVolumePosition = mul(float4(HitPosition, 1), DFObjectData.WorldToVolume).xyz;

		// Clamp hit point to a valid volume
		SampleVolumePosition = clamp(SampleVolumePosition, -DFObjectData.LocalPositionExtent, DFObjectData.LocalPositionExtent);

		float3 VolumeUV = DistanceFieldVolumePositionToUV(SampleVolumePosition, DFObjectData.UVScale, DFObjectData.UVAdd);
		float3 LocalGradient = CalculateMeshSDFGradient(VolumeUV, DFObjectData.DistanceFieldMAD);
		TraceSDFData.HitNormal = normalize(mul(LocalGradient, (float3x3) DFObjectData.VolumeToWorld));
	}
	else
	{
		// Gradient near surface is unreliable
		TraceSDFData.HitNormal = -WorldRayDirection;
	}

	return TraceSDFData;
}

void SampleLumenCubeMapFace(
	float3 SamplePosition,
	float SampleRadius,
	bool bAccurateHit,
	float CardWeight,
	uint CardIndex,
	float DepthVisibilityRadius,
	uint AtlasId,
	inout float3 Lighting,
	inout float TotalWeight)
{
	if (CardIndex < LumenCardScene.NumCards)
	{
		FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

		if (LumenCardData.bVisible)
		{
			float3 LocalSamplePosition = mul(SamplePosition - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);

			uint AxisIndex = 0;
			uint SideIndex = 0;

			LocalSamplePosition.xy = clamp(LocalSamplePosition.xy, -LumenCardData.LocalExtent.xy, LumenCardData.LocalExtent.xy);

			float HeightfieldZ;

			{
				// Visibility weight is not filterable, prevent low mip
				float DepthSampleRadiusScale = .25f;

				float Mip;
				float2 ValidRegionScale;
				CalculateMip(SampleRadius * DepthSampleRadiusScale, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, Mip, ValidRegionScale);

				float2 AtlasUV = CalculateAtlasUV(LocalSamplePosition.xy, ValidRegionScale, LumenCardData);
				float Depth = Texture2DSampleLevel(DilatedDepthAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).x;
				HeightfieldZ = LumenCardData.LocalExtent.z - Depth * 2 * LumenCardData.LocalExtent.z;
			}

			float FullVisibilityRadius = DepthVisibilityRadius * (bAccurateHit ? 1 : 5);
			float VisibilityFadeDistance = 2;
			float VisibilityWeight = 1 - saturate((HeightfieldZ - LocalSamplePosition.z - FullVisibilityRadius) / VisibilityFadeDistance);

			float3 LocalCardZAxis = float3(0, 0, 1);
			float3 WorldCardZAxis = mul(LumenCardData.WorldToLocalRotation, LocalCardZAxis);

			//@todo - weight based on heightmap normal to remove stretched texels
			float HeightmapNormalWeight = 1.0f;

			float Weight = VisibilityWeight * HeightmapNormalWeight * CardWeight;

			if (Weight > 0)
			{
				float Mip;
				float2 ValidRegionScale;
				CalculateMip(SampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, Mip, ValidRegionScale);

				float2 AtlasUV = CalculateAtlasUV(LocalSamplePosition.xy, ValidRegionScale, LumenCardData);

				float3 CardLighting;
				if (AtlasId == FINAL_LIGHTING_ATLAS_ID)
				{
					CardLighting = Texture2DSampleLevel(FinalLightingAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).rgb;
				}
				else if (AtlasId == IRRADIANCE_ATLAS_ID)
				{
					CardLighting = Texture2DSampleLevel(IrradianceAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).rgb;
				}
				else // if (AtlasId == INDIRECT_IRRADIANCE_ATLAS_ID)
				{
					CardLighting = Texture2DSampleLevel(IndirectIrradianceAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).rgb;
				}

				//float3 CardLighting = Pow2(Texture2DSampleLevel(LumenCardScene.AlbedoAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).rgb);
				float OpacityWeight = Texture2DSampleLevel(OpacityAtlas, TRACING_ATLAS_SAMPLER, AtlasUV, Mip).x;
				Weight *= OpacityWeight;

				Lighting += CardLighting * Weight;
				TotalWeight += Weight;
			}
		}
	}
}

float4 SampleLumenCubeMapTreeWithWeight(uint DFObjectIndex, float3 SamplePosition, float3 SampleNormal, float SampleRadius, bool bAccurateHit, float CardInterpolateDepthVisibilityRadius, uint AtlasId)
{
	uint CubeMapTreeId = LumenCardScene.DFObjectToCubeMapTreeIndexBuffer.Load(4 * DFObjectIndex);

	FLumenCubeMapTreeData CubeMapTreeData = GetLumenCubeMapTreeData(CubeMapTreeId);

	float3 LUTAtlasCoord = mul(float4(SamplePosition, 1.0f), CubeMapTreeData.WorldToLUTAtlasCoord).xyz;
	LUTAtlasCoord = clamp(LUTAtlasCoord, CubeMapTreeData.MinCoordInLUTAtlas, CubeMapTreeData.MaxCoordInLUTAtlas);
	uint CubeMapId = CubeMapTreeData.FirstCubeMapIndex + CubeMapTreeLUTAtlas.Load(int4(LUTAtlasCoord, 0)).x;

	FLumenCubeMapData CubeMap = GetLumenCubeMapData(CubeMapId);

	float3 LocalSpaceHitNormal = normalize(mul(float4(SampleNormal, 0.0f), CubeMapTreeData.WorldToLocal).xyz);

	uint CardIndexX = (LocalSpaceHitNormal.x > 0.0f ? CubeMap.FaceCardIndices[1] : CubeMap.FaceCardIndices[0]);
	uint CardIndexY = (LocalSpaceHitNormal.y > 0.0f ? CubeMap.FaceCardIndices[3] : CubeMap.FaceCardIndices[2]);
	uint CardIndexZ = (LocalSpaceHitNormal.z > 0.0f ? CubeMap.FaceCardIndices[5] : CubeMap.FaceCardIndices[4]);

	float3 AxisWeights = LocalSpaceHitNormal * LocalSpaceHitNormal;

	float3 Lighting = 0;
	float TotalWeight = 0;

	SampleLumenCubeMapFace(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.x,
		CardIndexX,
		CardInterpolateDepthVisibilityRadius,
		AtlasId,
		Lighting,
		TotalWeight);

	SampleLumenCubeMapFace(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.y,
		CardIndexY,
		CardInterpolateDepthVisibilityRadius,
		AtlasId,
		Lighting,
		TotalWeight);

	SampleLumenCubeMapFace(
		SamplePosition,
		SampleRadius,
		bAccurateHit,
		AxisWeights.z,
		CardIndexZ,
		CardInterpolateDepthVisibilityRadius,
		AtlasId,
		Lighting,
		TotalWeight);

	#if DISTANT_SCENE
	{
		uint ListIndex = 0;
		uint DistantCardIndex = LumenCardScene.DistantCardIndices[ListIndex];

		float DistantCardWeight = saturate(dot(SampleNormal, LumenCardScene.DistantSceneDirection));

		SampleLumenCubeMapFace(
			SamplePosition,
			SampleRadius,
			true,
			DistantCardWeight,
			DistantCardIndex,
			CardInterpolateDepthVisibilityRadius + 500.0f,
			AtlasId,
			Lighting,
			TotalWeight);
	}
	#endif

	return float4(Lighting, TotalWeight);
}

float3 SampleLumenCubeMapTree(uint DFObjectIndex, float3 SamplePosition, float3 SampleNormal, float SampleRadius, bool bAccurateHit, float CardInterpolateDepthVisibilityRadius, uint AtlasId)
{
	float4 LightingAndWeight = SampleLumenCubeMapTreeWithWeight(DFObjectIndex, SamplePosition, SampleNormal, SampleRadius, bAccurateHit, CardInterpolateDepthVisibilityRadius, AtlasId);

	if (LightingAndWeight.w > 0)
	{
		LightingAndWeight.xyz = LightingAndWeight.xyz / max(LightingAndWeight.w, 0.01f);
	}

	return LightingAndWeight.xyz;
}

void ConeTraceMeshSDFsAndInterpolateFromCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FTraceMeshSDFResult TraceMeshSDFResult;
	TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
	TraceMeshSDFResult.HitObject = 0;

	for (uint GridCulledMeshSDFIndex = 0; GridCulledMeshSDFIndex < TraceInput.NumMeshSDFs; GridCulledMeshSDFIndex++)
	{
		uint ObjectIndex = GridCulledMeshSDFObjectIndicesArray[TraceInput.MeshSDFStartOffset + GridCulledMeshSDFIndex];

		RayTraceSingleMeshSDF(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.TanConeAngle,
			TraceInput.MinTraceDistance,
			TraceInput.MaxTraceDistance, 
			ObjectIndex, 
			TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
			TraceInput.InitialMaxDistance,
			TraceMeshSDFResult);
	}

	if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance)
	{
		FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.MaxTraceDistance, 
			TraceMeshSDFResult);

		//OutResult.Lighting = frac(10 * TraceMeshSDFResult.HitDistance / TraceInput.MaxTraceDistance);
		//OutResult.Lighting = NumGridCulledMeshSDFObjects[MeshSDFGridCellIndex] / 10.0f;
		
		float3 InterpolatePosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceMeshSDFResult.HitDistance;
		float InterpolateRadius = TraceMeshSDFResult.HitDistance * TraceInput.TanConeAngle;

		//OutResult.Lighting = TraceSDFData.HitNormal * .5f + .5f;
		//OutResult.Lighting = frac(InterpolatePosition / 1000);
	
		uint AtlasId = FINAL_LIGHTING_ATLAS_ID;
		OutResult.Lighting = SampleLumenCubeMapTree(TraceMeshSDFResult.HitObject, InterpolatePosition, TraceSDFData.HitNormal, InterpolateRadius, TraceSDFData.bAccurateHit, TraceInput.CardInterpolateDepthVisibilityRadius, AtlasId);
		OutResult.Transparency = 0;
	}

	OutResult.OpaqueHitDistance = TraceMeshSDFResult.HitDistance;
}

Texture3D VoxelLighting;
// Must match C++
#define MAX_VOXEL_CLIPMAP_LEVELS 8
#define NumClipmapLevels LumenVoxelTracingParameters.NumClipmapLevels
#define ClipmapWorldToUVScale LumenVoxelTracingParameters.ClipmapWorldToUVScale
#define ClipmapWorldToUVBias LumenVoxelTracingParameters.ClipmapWorldToUVBias
#define ClipmapVoxelSizeAndRadius LumenVoxelTracingParameters.ClipmapVoxelSizeAndRadius
#define ClipmapWorldCenter LumenVoxelTracingParameters.ClipmapWorldCenter
#define ClipmapWorldExtent LumenVoxelTracingParameters.ClipmapWorldExtent
#define ClipmapWorldSamplingExtent LumenVoxelTracingParameters.ClipmapWorldSamplingExtent

float4 SampleVoxelLighting(float3 WorldPosition, float3 Direction, uint ClipmapIndex)
{
	float3 UV = WorldPosition * ClipmapWorldToUVScale[ClipmapIndex].xyz + ClipmapWorldToUVBias[ClipmapIndex].xyz;
	UV.y = (UV.y + ClipmapIndex) / (float)NumClipmapLevels;

	float4 Lighting = 0;

	float3 XAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.x > 0 ? 0 : 1.0f / 6.0f));
	float3 YAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.y > 0 ? 2.0f / 6.0f : 3.0f / 6.0f));
	float3 ZAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.z > 0 ? 4.0f / 6.0f : 5.0f / 6.0f));

	float4 XAxisLighting;
	float4 YAxisLighting;
	float4 ZAxisLighting;

	XAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, XAxisUV, 0);
	YAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, YAxisUV, 0);
	ZAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, ZAxisUV, 0);

	float3 AxisWeights = Direction * Direction;
	float InvTotalWeight = 1.0f / dot(AxisWeights, 1.0f);

	Lighting = (XAxisLighting * AxisWeights.x + YAxisLighting * AxisWeights.y + ZAxisLighting * AxisWeights.z) * InvTotalWeight;

	return Lighting.xyzw;
}

// Transparency value which is forced to zero to reduce leaking. It is softly faded-in with a VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH.
static float MIN_VOXEL_TRACE_TRANSPARENCY = 0.1f;
static float VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH = 0.05f;

float4 FadeOutVoxelConeTraceMinTransparency(float4 LightingAndAlpha)
{
	if (LightingAndAlpha.a < MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH)
	{
		// Restore missing energy due to early out.
		LightingAndAlpha.rgb *= (1.0f + LightingAndAlpha.a);

		// Smoothly force a transparency of MIN_VOXEL_TRACE_TRANSPARENCY to 0, since we stopped tracing
		LightingAndAlpha.a = saturate((LightingAndAlpha.a - MIN_VOXEL_TRACE_TRANSPARENCY) * (MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH) / VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH);
	}

	return LightingAndAlpha;
}

uint VoxelFaceFromStep(uint3 StepInc, int3 VoxelStep)
{
	uint3 DirectionOffset = VoxelStep >= 0 ? 0 : 1;
	return dot(StepInc, uint3(0, 2, 4) + DirectionOffset);
}

#if LEGACY_VOXEL_CONE_TRACING

void ConeTraceVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	float VoxelTraceStartDistance = TraceInput.VoxelTraceStartDistance;

	// Bias
	{
		bool bOutOfRange = true;
		uint LowerClipmapIndex = 0;
		for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapLevels; ++ClipmapIndex)
		{
			bOutOfRange = any(abs(TraceInput.ConeOrigin - ClipmapWorldCenter[ClipmapIndex].xyz) > ClipmapWorldSamplingExtent[ClipmapIndex].xyz);
			LowerClipmapIndex = bOutOfRange ? ClipmapIndex + 1 : LowerClipmapIndex;
		}

		if (bOutOfRange)
		{
			VoxelTraceStartDistance = TraceInput.MaxTraceDistance;
		}
		else
		{
			float LowerClipmapVoxelRadius = ClipmapVoxelSizeAndRadius[LowerClipmapIndex].w;
			VoxelTraceStartDistance = max(VoxelTraceStartDistance, LowerClipmapVoxelRadius * 2.0f);
		}
	}

	uint StartClipmapIndex = ComputeGlobalDistanceFieldClipmapIndex(TraceInput.ConeOrigin);
	float4 LightingAndAlpha = float4(0, 0, 0, 1);
	uint TotalNumSteps = 0;
	float MinRayTime = VoxelTraceStartDistance / TraceInput.MaxTraceDistance;
	float SampleRayTime = 0;

	LOOP
	for (uint ClipmapIndex = StartClipmapIndex; ClipmapIndex < NumGlobalSDFClipmaps && LightingAndAlpha.a > MIN_VOXEL_TRACE_TRANSPARENCY; ClipmapIndex++)
	{
		float MinStepSize = TraceInput.VoxelStepFactor * GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize; 
		const float ClipmapInfluenceRange = GLOBAL_DISTANCE_FIELD_INFLUENCE_RANGE_IN_VOXELS * 2.0f * GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize;
		float3 GlobalVolumeCenter = GlobalVolumeCenterAndExtent[ClipmapIndex].xyz;
		float GlobalVolumeExtent = GlobalVolumeCenterAndExtent[ClipmapIndex].w;
		float3 VolumeRayStart = TraceInput.ConeOrigin - GlobalVolumeCenter;
		
		float3 WorldRayEnd = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
		float2 IntersectionTimes = LineBoxIntersect(TraceInput.ConeOrigin, WorldRayEnd, GlobalVolumeCenter - GlobalVolumeExtent.xxx, GlobalVolumeCenter + GlobalVolumeExtent.xxx);
		IntersectionTimes.x = max(IntersectionTimes.x, MinRayTime);

		// Update the trace start for the next clipmap
		MinRayTime = IntersectionTimes.y;

		if (IntersectionTimes.x < IntersectionTimes.y)
		{
			SampleRayTime = IntersectionTimes.x * TraceInput.MaxTraceDistance;

			uint StepIndex = 0;
			uint MaxSteps = 256;

			uint VoxelClipmapIndex = 0;
			float SampleClipmapVoxelRadius = ClipmapVoxelSizeAndRadius[0].w;

			LOOP
			for (; StepIndex < MaxSteps; StepIndex++)
			{
				float3 SampleWorldPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * SampleRayTime;
				float3 MipUV = ComputeGlobalMipUV(SampleWorldPosition, ClipmapIndex);
				float DistanceFieldMipValue = Texture3DSampleLevel(GlobalDistanceFieldMipTexture, GlobalTrilinearWrappedSampler, MipUV, 0).x;
				float DistanceField = DecodeGlobalDistanceFieldPageDistance(DistanceFieldMipValue, GlobalDistanceFieldMipFactor * ClipmapInfluenceRange);
				float StepSphereRadius = SampleRayTime * TraceInput.TanConeAngle;

				float3 VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
				float3 VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;

				//@todo - align voxel clipmaps to global SDF clipmaps and we can get rid of these bounds checks
				bool bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);

				// Find the voxel clipmap that matches the cone width at the current step
				while ((StepSphereRadius > 2 * SampleClipmapVoxelRadius || bOutsideValidRegion)
					&& VoxelClipmapIndex + 1 < NumClipmapLevels)
				{
					VoxelClipmapIndex++;
					SampleClipmapVoxelRadius *= 2.0f;
					VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
					VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;
					bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);
				}

				// Approximate SDF visibility using smaller (0.75) cone to stop leaking from voxels
				float ConeVisibility = saturate(DistanceField / min(0.75 * StepSphereRadius, MaxGlobalDFAOConeDistance));

				if (DistanceField < SampleClipmapVoxelRadius && !bOutsideValidRegion)
				{
					float4 StepLighting = SampleVoxelLighting(SampleWorldPosition, TraceInput.ConeDirection, VoxelClipmapIndex);
					LightingAndAlpha.rgb += StepLighting.rgb * LightingAndAlpha.a;
					//@todo - compensate for step size not matching voxel size 
					LightingAndAlpha.a *= 1 - StepLighting.a;

					// Apply approximate SDF visibility and restore missing energy
					float PrevAlpha = LightingAndAlpha.a;
					LightingAndAlpha.a = min(LightingAndAlpha.a, ConeVisibility);
					LightingAndAlpha.rgb *= (1.0f + max(PrevAlpha - LightingAndAlpha.a, 0.0f));
				}

				float StepDistance = max(DistanceField * TraceInput.SDFStepFactor, MinStepSize);
				SampleRayTime += StepDistance;

				// Terminate the trace if we went past the end of the ray or achieved enough occlusion
				if (SampleRayTime > IntersectionTimes.y * TraceInput.MaxTraceDistance 
					|| LightingAndAlpha.a < MIN_VOXEL_TRACE_TRANSPARENCY)
				{
					break;
				}
			}

			TotalNumSteps += StepIndex;
		}
	}

	LightingAndAlpha = FadeOutVoxelConeTraceMinTransparency(LightingAndAlpha);

	OutResult = (FConeTraceResult)0;
	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = LightingAndAlpha.rgb;
	#endif
	OutResult.Transparency = LightingAndAlpha.a;
	OutResult.NumSteps = TotalNumSteps;
	OutResult.OpaqueHitDistance = SampleRayTime;
}

#else

void ConeTraceVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FGlobalSDFTraceResult SDFTraceResult;

	// Trace SDF ray
	{
		FGlobalSDFTraceInput SDFTraceInput = SetupGlobalSDFTraceInput(TraceInput.ConeOrigin, TraceInput.ConeDirection, TraceInput.MinTraceDistance, TraceInput.MaxTraceDistance, TraceInput.SDFStepFactor, TraceInput.VoxelStepFactor);
		SDFTraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
		SDFTraceInput.InitialMaxDistance = TraceInput.InitialMaxDistance;

		SDFTraceResult = RayTraceGlobalDistanceField(SDFTraceInput);
	}

	float4 LightingAndAlpha = float4(0, 0, 0, 1);

	if (GlobalSDFTraceResultIsHit(SDFTraceResult))
	{
		float3 SampleWorldPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * SDFTraceResult.HitTime;

		uint VoxelClipmapIndex = 0;
		float3 VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
		float3 VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;

		bool bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);

		// Find the voxel clipmap that matches the cone width at the current step
		while (bOutsideValidRegion && VoxelClipmapIndex + 1 < NumClipmapLevels)
		{
			VoxelClipmapIndex++;
			VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
			VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;
			bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);
		}

		LightingAndAlpha.xyzw = 0.0f;

		if (!bOutsideValidRegion)
		{
			float3 DistanceFieldGradient = -TraceInput.ConeDirection;

			float3 ClipmapVolumeUV = ComputeGlobalUV(SampleWorldPosition, SDFTraceResult.HitClipmapIndex);
			uint PageIndex = GetGlobalDistanceFieldPage(ClipmapVolumeUV, SDFTraceResult.HitClipmapIndex);

			if (PageIndex < GLOBAL_DISTANCE_FIELD_INVALID_PAGE_ID)
			{
				float3 PageUV = ComputeGlobalDistanceFieldPageUV(ClipmapVolumeUV, PageIndex);
				DistanceFieldGradient = GlobalDistanceFieldPageCentralDiff(PageUV);
			}

			float DistanceFieldGradientLength = length(DistanceFieldGradient);
			float3 SampleNormal = DistanceFieldGradientLength > 0.001 ? DistanceFieldGradient / DistanceFieldGradientLength : -TraceInput.ConeDirection;

			float4 StepLighting = SampleVoxelLighting(SampleWorldPosition, -SampleNormal, VoxelClipmapIndex);

			StepLighting.xyz = StepLighting.xyz * (1.0f / max(StepLighting.w, 0.1));

			float VoxelSelfLightingBias = smoothstep(1.5 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, 2.0 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, SDFTraceResult.HitTime);
			LightingAndAlpha.xyz = StepLighting.xyz * VoxelSelfLightingBias;
		}
	}

	LightingAndAlpha = FadeOutVoxelConeTraceMinTransparency(LightingAndAlpha);

	OutResult = (FConeTraceResult)0;
	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = LightingAndAlpha.rgb;
	#endif
	OutResult.Transparency = LightingAndAlpha.a;
	OutResult.NumSteps = SDFTraceResult.TotalStepsTaken;
	OutResult.OpaqueHitDistance = GlobalSDFTraceResultIsHit(SDFTraceResult) ? SDFTraceResult.HitTime : TraceInput.MaxTraceDistance;
}

#endif

float ComputeSquaredDistanceBetweenAABBs(float3 CenterA, float3 ExtentA, float3 CenterB, float3 ExtentB)
{
	float3 AxisDistances = max(abs(CenterB - CenterA) - (ExtentA + ExtentB), 0);
	return dot(AxisDistances, AxisDistances);
}

float CalculateVoxelTraceStartDistance(float MinTraceDistance, float MaxTraceDistance, float MaxCardTraceDistance, bool bContinueCardTracing)
{
	float VoxelTraceStartDistance = MaxTraceDistance;

	if (NumClipmapLevels > 0)
	{
		VoxelTraceStartDistance = MinTraceDistance;

		if (bContinueCardTracing)
		{
			VoxelTraceStartDistance = max(VoxelTraceStartDistance, MaxCardTraceDistance);
		}
	}

	return VoxelTraceStartDistance;
}

// For debugging
#define SCENE_TRACE_CARDS 1
#define SCENE_TRACE_VOXELS 1

void ConeTraceLumenSceneCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	OutResult = (FConeTraceResult)0;
	OutResult.Transparency = 1;

#if SCENE_TRACE_CARDS
	if (TraceInput.VoxelTraceStartDistance > TraceInput.MinTraceDistance)
	{
		FConeTraceInput CardTraceInput = TraceInput;
		CardTraceInput.MaxTraceDistance = TraceInput.VoxelTraceStartDistance;

		ConeTraceMeshSDFsAndInterpolateFromCards(CardTraceInput, OutResult);
	}
#endif
}

void ConeTraceLumenSceneVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
#if SCENE_TRACE_VOXELS
	if (TraceInput.VoxelTraceStartDistance < TraceInput.MaxTraceDistance)
	{
		FConeTraceInput VoxelTraceInput = TraceInput;
		VoxelTraceInput.MinTraceDistance = TraceInput.VoxelTraceStartDistance;
		FConeTraceResult VoxelTraceResult;
		ConeTraceVoxels(VoxelTraceInput, VoxelTraceResult);

		#if !VISIBILITY_ONLY_TRACE
			OutResult.Lighting += VoxelTraceResult.Lighting * OutResult.Transparency;
		#endif
		OutResult.Transparency *= VoxelTraceResult.Transparency;
		OutResult.NumSteps += VoxelTraceResult.NumSteps;
		OutResult.OpaqueHitDistance = min(OutResult.OpaqueHitDistance, VoxelTraceResult.OpaqueHitDistance);
	}
#endif
}

void ConeTraceLumenScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	ConeTraceLumenSceneCards(TraceInput, OutResult);
	ConeTraceLumenSceneVoxels(TraceInput, OutResult);
}

void ConeTraceLumenDistantScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	float3 debug = 0;
	TraceInput.MaxTraceDistance = LumenCardScene.DistantSceneMaxTraceDistance;
	TraceInput.bBlackOutSteepIntersections = true;

	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);

	if (LumenCardScene.NumDistantCards > 0)
	{
		if (NumClipmapLevels > 0)
		{
			float3 VoxelLightingCenter = ClipmapWorldCenter[NumClipmapLevels - 1].xyz;
			float3 VoxelLightingExtent = ClipmapWorldSamplingExtent[NumClipmapLevels - 1].xyz;

			float3 RayEnd = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
			float2 IntersectionTimes = LineBoxIntersect(TraceInput.ConeOrigin, RayEnd, VoxelLightingCenter - VoxelLightingExtent, VoxelLightingCenter + VoxelLightingExtent);

			// If we are starting inside the voxel clipmaps, move the start of the trace past the voxel clipmaps
			if (IntersectionTimes.x < IntersectionTimes.y && IntersectionTimes.x < .001f)
			{
				TraceInput.MinTraceDistance = IntersectionTimes.y * TraceInput.MaxTraceDistance;
			}
		}

		float TraceEndDistance = TraceInput.MinTraceDistance;

		// Multiple cascades disabled for now - artifacts when resuming traces between cascades, and shader has worse occupancy
		//for (uint ListIndex = 0; ListIndex < LumenCardScene.NumDistantCards && CardTraceBlendState.HasRemainingVisibility(TraceInput.MaxTraceDistance); ListIndex++)
		{
			//TraceInput.MinTraceDistance = TraceEndDistance;
			uint ListIndex = 0;
			uint CardIndex = LumenCardScene.DistantCardIndices[ListIndex];

			ConeTraceSingleLumenCard(
				TraceInput,
				CardIndex,
				debug,
				TraceEndDistance,
				CardTraceBlendState);
		}
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

float TanConeAngleToRoughness(float TanConeAngle)
{
	//@todo DynamicGI - derive roughness from cone angle
	return sqrt(saturate(TanConeAngle / (.5f * PI)));
}

void EvaluateSkyRadianceForCone(
	float3 ConeDirection, 
	float TanConeAngle, 
	inout FConeTraceResult TraceResult)
{ 
#if ENABLE_DYNAMIC_SKY_LIGHT
	if (ReflectionStruct.SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;
		float Roughness = TanConeAngleToRoughness(TanConeAngle);

		#if !VISIBILITY_ONLY_TRACE
			TraceResult.Lighting += GetSkyLightReflection(ConeDirection, Roughness, SkyAverageBrightness) * TraceResult.Transparency;
		#endif
		TraceResult.Transparency = 0;
	}
#endif
}
