// Copyright Epic Games, Inc. All Rights Reserved.

// TODO: Remove hair dependency
#include "../HairStrands/HairStrandsVoxelPageCommonStruct.ush"

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../MortonCode.ush"
#include "../SceneTextureParameters.ush"

#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheTracingCommon.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"
#include "LumenOctahedralProbe.ush"

#define TEMP_ATLAS_TRACE_TILE_STRIDE 1024

#if LUMEN_HARDWARE_RAYTRACING
#include "LumenHardwareRayTracingCommon.ush"

#ifndef DIM_LIGHTING_MODE
#define DIM_LIGHTING_MODE LIGHTING_FROM_SURFACE_CACHE
#endif

RaytracingAccelerationStructure TLAS;
RWTexture2D<float4> RWTraceTileRadianceAndHitDistanceTexture;

uint PersistentTracingGroupCount;

RAY_TRACING_ENTRY_RAYGEN(LumenRadianceCacheHardwareRayTracingRGS)
{
	uint2 GroupThreadId = uint2(DispatchRaysIndex().x % RADIANCE_CACHE_TRACE_TILE_SIZE_2D, DispatchRaysIndex().x / RADIANCE_CACHE_TRACE_TILE_SIZE_2D);

	uint TraceTileIterationSize = (ProbeTraceTileAllocator[0] + PersistentTracingGroupCount - 1) / PersistentTracingGroupCount;
	for (uint TraceTileIteration = 0; TraceTileIteration < TraceTileIterationSize; ++TraceTileIteration)
	{
		uint TraceTileGroupIndex = DispatchRaysIndex().y;
		uint TraceTileIndex = TraceTileIteration * PersistentTracingGroupCount + TraceTileGroupIndex;
		if (TraceTileIndex >= ProbeTraceTileAllocator[0])
		{
			return;
		}

		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		float3 ProbeWorldCenter;
		uint ClipmapIndex;
		uint ProbeIndex;
		GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;

		if (all(ProbeTexelCoord < TraceResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(TraceResolution);
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

			float FinalMinTraceDistance = max(MinTraceDistance, GetRadianceProbeTMin(ClipmapIndex));
			float FinalMaxTraceDistance = MaxTraceDistance;

			// Evenly distributing the sphere solid angle among all cones instead of based on Octahedron distortion
			float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(TraceResolution * TraceResolution));

			RayDesc Ray;
			Ray.Origin = ProbeWorldCenter;
			Ray.Direction = WorldConeDirection;
			Ray.TMin = FinalMinTraceDistance;
			Ray.TMax = FinalMaxTraceDistance;

			FRayCone RayCone = (FRayCone)0;
			RayCone = PropagateRayCone(RayCone, ConeHalfAngle, 0.0);

			const uint LinearCoord = ProbeTexelCoord.y * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + ProbeTexelCoord.x;
			const bool bCullBackFacingTriangles = false;
			FRayTracedLightingContext Context = CreateRayTracedLightingContext(TLAS, RayCone, ProbeTexelCoord, LinearCoord, bCullBackFacingTriangles);

			float3 SampleRadiance = 0.0;
			float SampleHitDistance = MaxHalfFloat;

			bool bIsHit = false;
			bool bUseMinimalPayload = (DIM_LIGHTING_MODE == LIGHTING_FROM_SURFACE_CACHE);
			if (bUseMinimalPayload)
			{
				bIsHit = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context, SampleHitDistance, SampleRadiance);
			}
			else
			{
				bIsHit = TraceAndCalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE, SampleHitDistance, SampleRadiance);
			}

			// Apply environment contribution on miss
			if (!bIsHit)
			{
				FConeTraceResult TraceResult = (FConeTraceResult)0;
				TraceResult.Transparency = 1;
				EvaluateSkyRadianceForCone(Ray.Direction, tan(ConeHalfAngle), TraceResult);
				SampleRadiance = TraceResult.Lighting;
				SampleHitDistance = MaxTraceDistance;
			}

			uint2 WrappedTileCoord = uint2(TraceTileIndex % TEMP_ATLAS_TRACE_TILE_STRIDE, TraceTileIndex / TEMP_ATLAS_TRACE_TILE_STRIDE);
			uint2 OutputIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId;
			RWTraceTileRadianceAndHitDistanceTexture[OutputIndex] = float4(SampleRadiance, min(SampleHitDistance, MaxHalfFloat));
		}
	}
}

#endif // LUMEN_HARDWARE_RAYTRACING

Texture2D<float4> RadianceAndHitDistanceTexture;


[numthreads(RADIANCE_CACHE_TRACE_TILE_SIZE_2D, RADIANCE_CACHE_TRACE_TILE_SIZE_2D, 1)]
void SplatRadianceCacheIntoAtlasCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID
)
{
	uint TraceTileIndex = GroupId.y * TRACE_TILE_GROUP_STRIDE + GroupId.x;
	if (TraceTileIndex >= ProbeTraceTileAllocator[0])
	{
		return;
	}

	uint2 TraceTileCoord;
	uint TraceTileLevel;
	uint ProbeTraceIndex;
	UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

	uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
	uint2 WrappedTileCoord = uint2(TraceTileIndex % TEMP_ATLAS_TRACE_TILE_STRIDE, TraceTileIndex / TEMP_ATLAS_TRACE_TILE_STRIDE);

	float3 ProbeWorldCenter;
	uint ClipmapIndex;
	uint ProbeIndex;
	GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

	uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

	if (TraceResolution < RadianceProbeResolution)
	{
		uint UpsampleFactor = RadianceProbeResolution / TraceResolution;
		ProbeAtlasBaseCoord += (RADIANCE_CACHE_TRACE_TILE_SIZE_2D * TraceTileCoord + GroupThreadId.xy) * UpsampleFactor;

		uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;
		float4 Data = RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex];
		float3 Lighting = Data.rgb;

		for (uint Y = 0; Y < UpsampleFactor; Y++)
		for (uint X = 0; X < UpsampleFactor; X++)
		{
			RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = Lighting;
		}

#if RADIANCE_CACHE_STORE_DEPTHS
		float HitDistance = Data.a;

		for (uint Y = 0; Y < UpsampleFactor; Y++)
		for (uint X = 0; X < UpsampleFactor; X++)
		{
			RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = HitDistance;
		}
#endif
	}
	else
	{
		uint DownsampleFactor = TraceResolution / RadianceProbeResolution;
		uint WriteTileSize = RADIANCE_CACHE_TRACE_TILE_SIZE_2D / DownsampleFactor;

		if (all(GroupThreadId.xy < WriteTileSize))
		{
			float3 Lighting = 0;

			for (uint Y = 0; Y < DownsampleFactor; Y++)
			for (uint X = 0; X < DownsampleFactor; X++)
			{
				uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy * DownsampleFactor + uint2(X, Y);
				Lighting += RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex].rgb;
			}

			ProbeAtlasBaseCoord += WriteTileSize * TraceTileCoord + GroupThreadId.xy;
			RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord] = Lighting / (float)(DownsampleFactor * DownsampleFactor);

#if RADIANCE_CACHE_STORE_DEPTHS
			float HitDistance = MaxHalfFloat;

			for (uint Y = 0; Y < DownsampleFactor; Y++)
			for (uint X = 0; X < DownsampleFactor; X++)
			{
				uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy * DownsampleFactor + uint2(X, Y);
				HitDistance = min(HitDistance, RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex].a);
			}

			RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord] = HitDistance;
#endif
		}
	}
}
