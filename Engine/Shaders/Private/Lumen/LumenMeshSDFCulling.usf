// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenMeshSDFCulling.usf
=============================================================================*/

#include "../Common.ush"
#include "../DistanceFieldLightingShared.ush"
#include "../HybridIndirectLighting.ush"
#include "LumenCardCommon.ush"
#include "ProbeHierarchy/LumenProbeTracing.ush"

uint ObjectBoundingGeometryIndexCount;
float CardTraceEndDistanceFromCamera; 
float MaxMeshSDFInfluenceRadius;
float MeshSDFRadiusThreshold;
uint NumCullGridCells;

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

groupshared uint NumGroupObjects;
groupshared uint GroupBaseIndex;
groupshared uint GroupObjectIndices[THREADGROUP_SIZE];

RWBuffer<uint> RWObjectIndexBuffer;

float LengthSq(float3 X)
{
	return dot(X, X);
}

[numthreads(THREADGROUP_SIZE, 1, 1)]
void CullMeshSDFObjectsForViewCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID) 
{
	uint ObjectIndex = DispatchThreadId.x;

#define USE_FRUSTUM_CULLING 1
#if USE_FRUSTUM_CULLING
	if (DispatchThreadId.x == 0)
	{
		// RWObjectIndirectArguments is zeroed by a clear before this shader, only need to set things that are non-zero (and are not read by this shader as that would be a race condition)
		// IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance
		RWObjectIndirectArguments[0] = ObjectBoundingGeometryIndexCount;
	}

	if (GroupThreadId.x == 0)
	{
		NumGroupObjects = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	if (ObjectIndex < NumSceneObjects)
	{
		uint SourceIndex = ObjectIndex;

		float4 ObjectBoundingSphere = SceneObjectBounds[SourceIndex * OBJECT_BOUNDS_STRIDE + 0];
		float DistanceToViewSq = LengthSq(View.WorldCameraOrigin - ObjectBoundingSphere.xyz);

		if (DistanceToViewSq < Square(CardTraceEndDistanceFromCamera + ObjectBoundingSphere.w)
			&& ObjectBoundingSphere.w > MeshSDFRadiusThreshold
			&& ViewFrustumIntersectSphere(ObjectBoundingSphere.xyz, ObjectBoundingSphere.w + MaxMeshSDFInfluenceRadius)) 
		{
            float2 MinMaxDrawDist2 = LoadGlobalObjectMinMaxDrawDistance2(SourceIndex);

            if ((MinMaxDrawDist2.x < 0.0001 || DistanceToViewSq > MinMaxDrawDist2.x)
                && (MinMaxDrawDist2.y < 0.0001 || DistanceToViewSq < MinMaxDrawDist2.y))
            {
                uint DestIndex;
                InterlockedAdd(NumGroupObjects, 1U, DestIndex);
                GroupObjectIndices[DestIndex] = SourceIndex;
            }
        }
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadId.x == 0)
	{
		InterlockedAdd(RWObjectIndirectArguments[1], NumGroupObjects, GroupBaseIndex);
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadId.x < NumGroupObjects)
	{
		uint SourceIndex = GroupObjectIndices[GroupThreadId.x];
		uint DestIndex = GroupBaseIndex + GroupThreadId.x;
		RWObjectIndexBuffer[DestIndex] = SourceIndex;
	}

#else

	if (DispatchThreadId.x == 0)
	{
		// IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance
		RWObjectIndirectArguments[0] = ObjectBoundingGeometryIndexCount;
		RWObjectIndirectArguments[1] = NumSceneObjects;
	}

	GroupMemoryBarrierWithGroupSync();

	if (ObjectIndex < NumSceneObjects)
	{
		uint SourceIndex = ObjectIndex;
		uint DestIndex = ObjectIndex;

		RWObjectIndexBuffer[DestIndex] = SourceIndex;
	}

#endif
}


struct FObjectCullVertexOutput
{
	nointerpolation float4 PositionAndRadius : TEXCOORD0;
	nointerpolation uint ObjectIndex : TEXCOORD1;
};
 
float ConservativeRadiusScale;
Buffer<uint> ObjectIndexBuffer;

void MeshSDFObjectCullVS(
	float4 InPosition : ATTRIBUTE0,
	uint IndexInIndexBuffer : SV_InstanceID,
	out FObjectCullVertexOutput Output,
	out float4 OutPosition : SV_POSITION
	)
{
	uint ObjectIndex = ObjectIndexBuffer[IndexInIndexBuffer];

	float4 ObjectPositionAndRadius = LoadGlobalObjectPositionAndRadius(ObjectIndex);
	//@todo - expand to handle conservative rasterization
	float EffectiveRadius = (ObjectPositionAndRadius.w + MaxMeshSDFInfluenceRadius) * ConservativeRadiusScale;
	float3 WorldPosition = InPosition.xyz * EffectiveRadius + ObjectPositionAndRadius.xyz;
	OutPosition = mul(float4(WorldPosition, 1), View.WorldToClip);
	Output.PositionAndRadius = ObjectPositionAndRadius;
	Output.ObjectIndex = ObjectIndex;
} 

RWBuffer<uint> RWNumGridCulledMeshSDFObjects;
RWBuffer<uint> RWNumCulledObjectsToCompact;
RWBuffer<uint> RWCulledObjectsToCompactArray;
RWBuffer<uint> RWGridCulledMeshSDFObjectIndicesArray;

//@todo - put in header for tracing
Buffer<uint> GridCulledMeshSDFObjectStartOffsetArray;
#define CULLED_MESH_SDF_DATA_STRIDE 1
#define CULLED_OBJECT_TO_COMPACT_STRIDE 2
float3 CardGridZParams;
uint3 CullGridSize;
uint CardGridPixelSizeShift;

uint ComputeFroxelGridZ(float SceneDepth)
{
	uint ZSlice = (uint)(max(0, log2(SceneDepth * CardGridZParams.x + CardGridZParams.y) * CardGridZParams.z));
	ZSlice = min(ZSlice, (uint)(CullGridSize.z - 1));
	return ZSlice;
}

float ComputeDepthFromZSlice(float ZSlice)
{
#if CULL_TO_FROXEL_GRID
	float SliceDepth = (exp2(ZSlice / CardGridZParams.z) - CardGridZParams.y) / CardGridZParams.x;
	return SliceDepth;
#else
	float MinTileZ = 0.0f;
	float MaxTileZ = CardTraceEndDistanceFromCamera;
	return lerp(MinTileZ, MaxTileZ, ZSlice);
#endif
}

float3 ComputeCellWorldPosition(uint3 GridCoordinate, float3 CellOffset)
{
	float2 VolumeUV = (GridCoordinate.xy + CellOffset.xy) / CullGridSize.xy;
	float2 VolumeNDC = (VolumeUV * 2 - 1) * float2(1, -1);

	float SceneDepth = ComputeDepthFromZSlice(GridCoordinate.z + CellOffset.z);
	float TileDeviceZ = ConvertToDeviceZ(SceneDepth);

	float4 CenterPosition = mul(float4(VolumeNDC, TileDeviceZ, 1), View.ClipToTranslatedWorld);
	return CenterPosition.xyz / CenterPosition.w - View.PreViewTranslation;
}

bool DoesMeshSDFAffectSphere(float3 WorldSphereCenter, float WorldSphereRadius, uint ObjectIndex, float3 LocalPositionExtent) 
{
	float4x4 WorldToVolume = LoadGlobalObjectWorldToVolume(ObjectIndex);

	float3 VolumeSphereCenter = mul(float4(WorldSphereCenter, 1), WorldToVolume).xyz;

	// Transform a length along each axis and take the maximum bounding sphere to conservatively handle non-uniform scaling
	float3 VolumeTileInfluenceRadii = abs(mul(float4(WorldSphereRadius, WorldSphereRadius, WorldSphereRadius, 0), WorldToVolume).xyz);
	float VolumeTileInfluenceRadius = max(VolumeTileInfluenceRadii.x, max(VolumeTileInfluenceRadii.y, VolumeTileInfluenceRadii.z));

	float3 UVAdd = LoadGlobalObjectUVAddAndSelfShadowBias(ObjectIndex).xyz;
	float2 DistanceFieldMAD = LoadGlobalObjectDistanceFieldMAD(ObjectIndex);

	float3 ClampedSamplePosition = clamp(VolumeSphereCenter, -LocalPositionExtent, LocalPositionExtent);
	float DistanceToClamped = length(VolumeSphereCenter - ClampedSamplePosition);

	bool bGeneratedAsTwoSided;
	float4 UVScaleAndVolumeScale = LoadGlobalObjectUVScale(ObjectIndex, bGeneratedAsTwoSided);

	float3 StepVolumeUV = DistanceFieldVolumePositionToUV(ClampedSamplePosition, UVScaleAndVolumeScale.xyz, UVAdd);
	float DistanceToOccluder = SampleMeshDistanceField(StepVolumeUV, DistanceFieldMAD).x + DistanceToClamped;

	return DistanceToOccluder < VolumeTileInfluenceRadius;
}

uint MaxNumberOfCulledObjects;

Texture2D ClosestHZBTexture;
Texture2D FurthestHZBTexture;
float HZBMipLevel;
uint HaveClosestHZB;
float2 ViewportUVToHZBBufferUV;

void MeshSDFObjectCullPS(
	FObjectCullVertexOutput Input, 
	in float4 SVPos : SV_POSITION)
{
	uint2 PixelPos = SVPos.xy;

	uint ObjectIndex = Input.ObjectIndex;
	float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;
	float3x3 VolumeToWorld = LoadGlobalObjectVolumeToWorld(ObjectIndex);

	float3 WorldObjectPosition = Input.PositionAndRadius.xyz;
	float3 WorldObjectExtent = mul(LocalPositionExtent, abs(VolumeToWorld));

	float3 ViewSpaceObjectPosition = mul(float4(WorldObjectPosition + View.PreViewTranslation.xyz, 1), View.TranslatedWorldToView).xyz;
	float3 ViewSpaceObjectInfluenceExtent = mul(WorldObjectExtent, abs((float3x3)View.TranslatedWorldToView)) + MaxMeshSDFInfluenceRadius;

	float4 FrustumPlanes[6];
	{
		// Setup tile frustum planes
		float2 TileScale = -float2(View.ViewSizeAndInvSize.zw - View.ViewSizeAndInvSize.xy) * rcp(2 * (1 << CardGridPixelSizeShift));
		float2 TileBias = TileScale - PixelPos - 0.5;

		float4 C1 = float4(View.ViewToClip._11 * TileScale.x, 0.0f, View.ViewToClip._31 * TileScale.x + TileBias.x, 0.0f);
		float4 C2 = float4(0.0f, -View.ViewToClip._22 * TileScale.y, View.ViewToClip._32 * TileScale.y + TileBias.y, 0.0f);
		float4 C4 = float4(0.0f, 0.0f, 1.0f, 0.0f);

		FrustumPlanes[0] = C4 - C1;
		FrustumPlanes[1] = C4 + C1;
		FrustumPlanes[2] = C4 - C2;
		FrustumPlanes[3] = C4 + C2;

		// Normalize tile frustum planes
		for (uint i = 0; i < 4; ++i)
		{
			FrustumPlanes[i] *= rcp(length(FrustumPlanes[i].xyz));
		}
	}
	
	uint MinFroxelZ = 0;
	uint MaxFroxelZ = 0;

#if CULL_TO_FROXEL_GRID
	float MinDepth = ViewSpaceObjectPosition.z - ViewSpaceObjectInfluenceExtent.z;
	float MaxDepth = ViewSpaceObjectPosition.z + ViewSpaceObjectInfluenceExtent.z;

	#define CULL_TO_HZB 1
	#if CULL_TO_HZB
		float2 HZBScreenUV = (PixelPos * (1 << CardGridPixelSizeShift) + .5f) * View.ViewSizeAndInvSize.zw * ViewportUVToHZBBufferUV;

		if (HaveClosestHZB)
		{
			MinDepth = max(MinDepth, ConvertFromDeviceZ(ClosestHZBTexture.SampleLevel(GlobalPointClampedSampler, HZBScreenUV, HZBMipLevel).x));
		}
	
		MaxDepth = min(MaxDepth, ConvertFromDeviceZ(FurthestHZBTexture.SampleLevel(GlobalPointClampedSampler, HZBScreenUV, HZBMipLevel).x));
	#endif

	//@todo - make this conservative
	MinFroxelZ = ComputeFroxelGridZ(MinDepth);
	MaxFroxelZ = ComputeFroxelGridZ(MaxDepth);
#endif

	for (uint FroxelZ = MinFroxelZ; FroxelZ <= MaxFroxelZ; FroxelZ++)
	{
		uint3 FroxelGridCoordinate = uint3(PixelPos, FroxelZ);
		float MinTileZ = ComputeDepthFromZSlice(FroxelZ);
		float MaxTileZ = ComputeDepthFromZSlice(FroxelZ + 1);

		FrustumPlanes[4] = float4(0.0f, 0.0f, 1.0f, -MinTileZ);
		FrustumPlanes[5] = float4(0.0f, 0.0f, -1.0f, MaxTileZ);

		bool bTileIntersectsObject = true;

#define INTERSECT_FRUSTUM_WITH_VIEW_AABB 1
#if INTERSECT_FRUSTUM_WITH_VIEW_AABB
		// Tile frustum plane vs view space MeshSDF AABB
		for (uint i = 0; i < 6; ++i)
		{
			float DistanceFromNodeCenterToPlane = dot(FrustumPlanes[i], float4(ViewSpaceObjectPosition, 1.0f));
			float Radius = dot(ViewSpaceObjectInfluenceExtent, abs(FrustumPlanes[i].xyz));
			bTileIntersectsObject = bTileIntersectsObject && (DistanceFromNodeCenterToPlane >= -Radius);
		}
#endif

#define INTERSECT_FROXEL_WITH_SDF 1
#if INTERSECT_FROXEL_WITH_SDF
		if (bTileIntersectsObject)
		{
			float3 WorldTileCenterPosition = ComputeCellWorldPosition(FroxelGridCoordinate, .5f);

			float3 WorldTileCornerVector = (ComputeCellWorldPosition(FroxelGridCoordinate, float3(1, 1, 1)) - WorldTileCenterPosition);
			float CornerLength = length(WorldTileCornerVector);

			WorldTileCornerVector = (ComputeCellWorldPosition(FroxelGridCoordinate, float3(0, 0, 1)) - WorldTileCenterPosition);
			CornerLength = max(length(WorldTileCornerVector), CornerLength);

			bTileIntersectsObject = DoesMeshSDFAffectSphere(WorldTileCenterPosition, CornerLength + MaxMeshSDFInfluenceRadius, ObjectIndex, LocalPositionExtent);
		}
#endif
		
		if (bTileIntersectsObject)
		{
			uint GridIndex = (FroxelGridCoordinate.z * CullGridSize.y + FroxelGridCoordinate.y) * CullGridSize.x + FroxelGridCoordinate.x;

			InterlockedAdd(RWNumGridCulledMeshSDFObjects[GridIndex], 1);

			// Write out object index with a corresponding grid index
			uint CulledObjectToCompactIndex;
			InterlockedAdd(RWNumCulledObjectsToCompact[0], 1, CulledObjectToCompactIndex);

			if (CulledObjectToCompactIndex < MaxNumberOfCulledObjects)
			{
				RWCulledObjectsToCompactArray[CulledObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 0] = ObjectIndex;
				RWCulledObjectsToCompactArray[CulledObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 1] = GridIndex;
			}
		}
	}
}

uint ProbeHierarchyLevelIndex;
Texture2D<uint> ProbeListPerEmitTile;

void MeshSDFObjectCullForProbesPS(
	FObjectCullVertexOutput Input, 
	in float4 SVPos : SV_POSITION)
{
	uint2 PixelCoord = SVPos.xy;
	uint2 ProbeTileCoord = PixelCoord;

	uint ObjectIndex = Input.ObjectIndex;
	float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;
	float3x3 VolumeToWorld = LoadGlobalObjectVolumeToWorld(ObjectIndex);

	float3 WorldObjectPosition = Input.PositionAndRadius.xyz;
	float3 WorldObjectExtent = mul(LocalPositionExtent, abs(VolumeToWorld));

	for (uint ProbeIndexInTile = 0; ProbeIndexInTile < PROBE_HIERARCHY_MAX_EMIT_PER_TILE; ++ProbeIndexInTile)
	{
		uint2 ProbeStorageCoord = EmitTileCoordToProbeStorageCoord(ProbeTileCoord, ProbeIndexInTile);

		uint ProbeIndex = ProbeListPerEmitTile[ProbeStorageCoord];

		if (ProbeIndex != PROBE_INVALID_INDEX)
		{
			FProbeInfo ProbeInfo = ReadProbeInfo(ProbeIndex);

			float ProbeTMin;
			float ProbeTMax;
			GetProbeTracingRange(ProbeInfo, ProbeHierarchyLevelIndex, ProbeTMin, ProbeTMax);

			ProbeTMax = min(MaxMeshSDFInfluenceRadius, ProbeTMax);

			float3 ProbeWorldPosition = ProbeInfo.TranslatedWorldPosition - View.PreViewTranslation;

			float DistanceToViewSq = LengthSq(View.WorldCameraOrigin - ProbeWorldPosition);

			if (DistanceToViewSq < Pow2(CardTraceEndDistanceFromCamera)
				&& ProbeTMin < ProbeTMax)
			{
				bool bProbeIntersectsObject = true;

				// Check bounds
				if (bProbeIntersectsObject)
				{
					float DistanceFromObjectToProbeCenterSq = ComputeSquaredDistanceFromBoxToPoint(WorldObjectPosition, WorldObjectExtent, ProbeWorldPosition);

					if (DistanceFromObjectToProbeCenterSq > Pow2(ProbeTMax))
					{
						bProbeIntersectsObject = false;
					}
				}

				// Check distance to SDF
				if (bProbeIntersectsObject)
				{
					bProbeIntersectsObject = DoesMeshSDFAffectSphere(ProbeWorldPosition, MaxMeshSDFInfluenceRadius, ObjectIndex, LocalPositionExtent);
				}

				if (bProbeIntersectsObject)
				{
					InterlockedAdd(RWNumGridCulledMeshSDFObjects[ProbeIndex], 1);

					// Write out object index with a corresponding grid index
					uint CulledObjectToCompactIndex;
					InterlockedAdd(RWNumCulledObjectsToCompact[0], 1, CulledObjectToCompactIndex);

					if (CulledObjectToCompactIndex < MaxNumberOfCulledObjects)
					{
						RWCulledObjectsToCompactArray[CulledObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 0] = ObjectIndex;
						RWCulledObjectsToCompactArray[CulledObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 1] = ProbeIndex;
					}
				}
			}
		}
	}
}

Buffer<uint> NumCulledObjectsToCompact;
Buffer<uint> CulledObjectsToCompactArray;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MeshSDFObjectCompactCulledObjectsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ObjectToCompactIndex = DispatchThreadId.x;

	uint NumObjectsToCompact = min(MaxNumberOfCulledObjects, NumCulledObjectsToCompact[0]);

	if (ObjectToCompactIndex < NumObjectsToCompact)
	{
		uint ObjectIndex = CulledObjectsToCompactArray[ObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 0];
		uint GridIndex = CulledObjectsToCompactArray[ObjectToCompactIndex * CULLED_OBJECT_TO_COMPACT_STRIDE + 1];

		uint CulledObjectIndex;
		InterlockedAdd(RWNumGridCulledMeshSDFObjects[GridIndex], 1, CulledObjectIndex);

		uint CulledObjectDataStart = GridCulledMeshSDFObjectStartOffsetArray[GridIndex];

		RWGridCulledMeshSDFObjectIndicesArray[(CulledObjectDataStart + CulledObjectIndex) * CULLED_MESH_SDF_DATA_STRIDE + 0] = ObjectIndex;
	}
}


RWBuffer<uint> RWGridCulledMeshSDFObjectStartOffsetArray;
RWBuffer<uint> RWCulledMeshSDFObjectAllocator;
RWBuffer<uint> RWCompactCulledObjectsIndirectArguments;
Buffer<uint> NumGridCulledMeshSDFObjects;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ComputeCulledMeshSDFObjectsStartOffsetCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint CellIndex = DispatchThreadId.x;

	if (DispatchThreadId.x == 0)
	{
		RWCompactCulledObjectsIndirectArguments[0] = (NumCulledObjectsToCompact[0] + 63) / 64;
		RWCompactCulledObjectsIndirectArguments[1] = 1;
		RWCompactCulledObjectsIndirectArguments[2] = 1;
	}

	if (CellIndex < NumCullGridCells)
	{
		uint NumIntersectingObjects = NumGridCulledMeshSDFObjects[CellIndex];

		uint StartOffset;
		InterlockedAdd(RWCulledMeshSDFObjectAllocator[0], NumIntersectingObjects, StartOffset);
		RWGridCulledMeshSDFObjectStartOffsetArray[CellIndex] = StartOffset;
	}
}
