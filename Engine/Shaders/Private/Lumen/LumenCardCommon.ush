// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardCommon.ush
=============================================================================*/

struct FLumenCardData
{
	float3x3 WorldToLocalRotation;
	float3 Origin;
	float3 LocalExtent;

	uint2 SizeInPages;
	uint PageTableOffset;

	uint2 HiResSizeInPages;
	uint HiResPageTableOffset;

	// Convert Card's uint ResLevel (card's resolution) to uint2 ResLevelXY (each side's resolution)
	uint2 ResLevelToResLevelXYBias;

	bool bVisible;
};

// Stride of a single cards's data in float4's, must match C++
#define PROXY_CARD_DATA_STRIDE 5
#define LUMEN_CARD_TILE_DATA_STRIDE 3

void GetLumenCardSharedDataInternal(uint BaseOffset, StructuredBuffer<float4> CardBuffer, inout FLumenCardData CardData)
{
	// Note: layout must match FLumenCardData in C++
	// Relying on optimizer to remove unused loads

	CardData = (FLumenCardData)0;

	float4 Vector0 = CardBuffer[BaseOffset + 0];
	float4 Vector1 = CardBuffer[BaseOffset + 1];
	float4 Vector2 = CardBuffer[BaseOffset + 2];
	float4 Vector3 = CardBuffer[BaseOffset + 3];
	float4 Vector4 = CardBuffer[BaseOffset + 4];

	CardData.WorldToLocalRotation[0] = Vector0.xyz;
	CardData.WorldToLocalRotation[1] = Vector1.xyz;
	CardData.WorldToLocalRotation[2] = Vector2.xyz;
	CardData.Origin = float3(Vector0.w, Vector1.w, Vector2.w);

	CardData.LocalExtent = abs(Vector3.xyz);
	CardData.ResLevelToResLevelXYBias.x = (asuint(Vector3.w) >> 0) & 0xFF;
	CardData.ResLevelToResLevelXYBias.y = (asuint(Vector3.w) >> 8) & 0xFF;
	CardData.bVisible = asuint(Vector3.w) & (1 << 16);

	CardData.SizeInPages.x = (asuint(Vector4.x) >> 0) & 0xFFFF;
	CardData.SizeInPages.y = (asuint(Vector4.x) >> 16) & 0xFFFF;
	CardData.PageTableOffset = asuint(Vector4.y);
	CardData.HiResSizeInPages.x = (asuint(Vector4.z) >> 0) & 0xFFFF;
	CardData.HiResSizeInPages.y = (asuint(Vector4.z) >> 16) & 0xFFFF;
	CardData.HiResPageTableOffset = asuint(Vector4.w);
}

bool IsCardVisible(uint CardId)
{
	return LumenCardScene.CardData[CardId * PROXY_CARD_DATA_STRIDE + 3].y > 0.0f;
}

// Fetch from scene card buffer
FLumenCardData GetLumenCardData(uint CardId) 
{
	FLumenCardData CardData;
	uint BaseOffset = CardId * PROXY_CARD_DATA_STRIDE;
	
	GetLumenCardSharedDataInternal(BaseOffset, LumenCardScene.CardData, CardData);

	return CardData;
}

FLumenCardData GetLumenCardData(uint CardId, StructuredBuffer<float4> CardBuffer) 
{
	FLumenCardData CardData;
	uint BaseOffset = CardId * PROXY_CARD_DATA_STRIDE;
	
	GetLumenCardSharedDataInternal(BaseOffset, CardBuffer, CardData);

	return CardData;
}

struct FLumenCardPageData
{
	uint CardIndex;
	float4 CardUVRect;
	float4 PhysicalAtlasUVRect;
};

void GetLumenCardPageInternal(uint BaseOffset, StructuredBuffer<float4> CardPageBuffer, inout FLumenCardPageData CardPageData)
{
	// Note: layout must match FLumenCardPageData in C++

	CardPageData = (FLumenCardPageData) 0;

	float4 Vector0 = CardPageBuffer[BaseOffset + 0];
	float4 Vector1 = CardPageBuffer[BaseOffset + 1];
	float4 Vector2 = CardPageBuffer[BaseOffset + 2];

	CardPageData.CardIndex = asuint(Vector0.x);
	CardPageData.CardUVRect = Vector1;
	CardPageData.PhysicalAtlasUVRect = Vector2;
}

// Fetch from scene card buffer
FLumenCardPageData GetLumenCardPageData(uint CardPageId)
{
	FLumenCardPageData CardPageData;
	uint BaseOffset = CardPageId * LUMEN_CARD_TILE_DATA_STRIDE;

	GetLumenCardPageInternal(BaseOffset, LumenCardScene.CardPageData, CardPageData);

	return CardPageData;
}

FLumenCardPageData GetLumenCardPageData(uint CardPageId, StructuredBuffer<float4> CardPageBuffer)
{
	FLumenCardPageData CardPageData;
	uint BaseOffset = CardPageId * LUMEN_CARD_TILE_DATA_STRIDE;

	GetLumenCardPageInternal(BaseOffset, CardPageBuffer, CardPageData);

	return CardPageData;
}

float3 TransformLocalToAxis(uint AxisIndex, float3 LocalPosition)
{
	// Local to Axis
	// 0: xyz = x, y, z
	// 1: xyz = z, y, -x
	// 2: xyz = x, -z, y
	// Note: must match C++ FCardRenderData::GetWorldToLocalRotation

	float3 FacePosition = LocalPosition;

	if (AxisIndex == 1)
	{
		FacePosition = float3(FacePosition.zy, -FacePosition.x);
	}
	else if (AxisIndex == 2)
	{		
		FacePosition = float3(FacePosition.x, -FacePosition.z, FacePosition.y);
	}

	return FacePosition;
}

float3 TransformFaceToLocal(uint FaceIndex, float3 FacePosition)
{
	if (FaceIndex & 1)
	{
		FacePosition.yz = -FacePosition.yz;
	}

	float3 LocalPosition = FacePosition;

	// Axis to Local
	// 0: xyz = x, y, z
	// 1: xyz = -z, y, x
	// 2: xyz = x, z, -y
	// Note: must match C++ FCardRenderData::GetWorldToLocalRotation

	uint AxisIndex = FaceIndex / 2;

	if (AxisIndex == 1)
	{
		LocalPosition = float3(-FacePosition.z, FacePosition.y, FacePosition.x);
	}
	else if (AxisIndex == 2)
	{		
		LocalPosition = float3(FacePosition.x, FacePosition.z, -FacePosition.y);
	}

	return LocalPosition;
}

struct FCardVSToPS
{
	float2 AtlasUV : ATTRIBUTE0;
	float2 CardUV : ATTRIBUTE1;
	nointerpolation uint CardPageIndex : CARD_ID;
};

// Stride of mesh cards data, must match C++
#define LUMEN_MESH_CARDS_DATA_STRIDE 4
#define LUMEN_INVALID_CARD_INDEX 0xFFFFFFFF

struct FLumenMeshCardsData
{
	float4x4 WorldToLocal;

	// Per orientation
	uint NumCards[6];
	uint CardOffset[6];
};

void UnpackCardNumAndOffset(inout uint NumCards, inout uint CardOffset, uint BaseCardOffset, uint PackedData, uint PackedDataOffset)
{
	NumCards = (PackedData >> (PackedDataOffset + 0)) & 0xFF;
	CardOffset = (PackedData >> (PackedDataOffset + 8)) & 0xFF;

	CardOffset += BaseCardOffset;
}

// Note: layout must match FLumenMeshCardsData in C++
FLumenMeshCardsData GetLumenMeshCardsData(uint MeshCardsId)
{
	uint BaseOffset = MeshCardsId * LUMEN_MESH_CARDS_DATA_STRIDE;

	FLumenMeshCardsData MeshCardsData;

	float4 M0 = LumenCardScene.MeshCardsData[BaseOffset + 0];
	float4 M1 = LumenCardScene.MeshCardsData[BaseOffset + 1];
	float4 M2 = LumenCardScene.MeshCardsData[BaseOffset + 2];
	MeshCardsData.WorldToLocal = transpose(float4x4(M0, M1, M2, float4(0.0f, 0.0f, 0.0f, 1.0f)));

	uint4 PackedData;
	PackedData.x = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].x);
	PackedData.y = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].y);
	PackedData.z = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].z);
	PackedData.w = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].w);

	uint BaseCardOffset = PackedData.w;

	UnpackCardNumAndOffset(MeshCardsData.NumCards[0], MeshCardsData.CardOffset[0], BaseCardOffset, PackedData.x, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[1], MeshCardsData.CardOffset[1], BaseCardOffset, PackedData.x, 16);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[2], MeshCardsData.CardOffset[2], BaseCardOffset, PackedData.y, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[3], MeshCardsData.CardOffset[3], BaseCardOffset, PackedData.y, 16);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[4], MeshCardsData.CardOffset[4], BaseCardOffset, PackedData.z, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[5], MeshCardsData.CardOffset[5], BaseCardOffset, PackedData.z, 16);

	return MeshCardsData;
}

float3 GetCardLocalPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	CardUV.x = 1.0f - CardUV.x;

	float3 LocalPosition;
	LocalPosition.xy = Card.LocalExtent.xy * (1.0f - 2.0f * CardUV);
	LocalPosition.z = -Card.LocalExtent.z + Depth * 2.0f * Card.LocalExtent.z;

	return LocalPosition;
}

void GetCardPageLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	float3 CardPageLocalBoxMin = GetCardLocalPosition(Card, CardPage.CardUVRect.xw, 0.0f);
	float3 CardPageLocalBoxMax = GetCardLocalPosition(Card, CardPage.CardUVRect.zy, 1.0f);

	CardPageLocalCenter = 0.5f * (CardPageLocalBoxMax + CardPageLocalBoxMin);
	CardPageLocalExtent = 0.5f * (CardPageLocalBoxMax - CardPageLocalBoxMin);
}

float3 GetCardWorldPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	float3 LocalPosition = GetCardLocalPosition(Card, CardUV, Depth);
	float3 WorldPosition = mul(Card.WorldToLocalRotation, LocalPosition) + Card.Origin;
	return WorldPosition;
}

uint2 GetCardPageSizeInTexels(FLumenCardPageData CardPage, uint2 AtlasSize)
{
	float2 AtlasSizeInUV = CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy;
	return uint2(AtlasSizeInUV * AtlasSize);
}

float2 CardPageUVToCardUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, CardPageUV);
	return CardUV;
}

float2 CardPageUVToAtlasUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, CardPageUV);
	return AtlasUV;
}

float2 SamplePositonToCardUV(FLumenCardData Card, float2 LocalSamplePosition)
{
	float2 CardUV = saturate(float2(+0.5f, -0.5f) * (LocalSamplePosition / Card.LocalExtent.xy) + 0.5f);
	return CardUV;
}

// Return decoded world space normal
float3 DecodeSurfaceCacheNormal(float2 EncodedNormal)
{
	float3 WorldSpaceNormal;
	WorldSpaceNormal.xy = EncodedNormal.xy * 2.0f - 1.0f;
	WorldSpaceNormal.z = sqrt(max(1.0f - dot(WorldSpaceNormal.xy, WorldSpaceNormal.xy), 0.00001f));
	return normalize(WorldSpaceNormal);
}
