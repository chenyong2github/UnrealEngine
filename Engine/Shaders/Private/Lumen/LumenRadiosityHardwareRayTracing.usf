// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadiosityHardwareRayTracing.usf
=============================================================================*/

// TODO: Remove hair dependency
#include "../HairStrands/HairStrandsVoxelPageCommonStruct.ush"

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../MortonCode.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenCardUpdate.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"
#include "LumenRadiosity.ush"
#include "LumenHardwareRayTracingCommon.ush"

RaytracingAccelerationStructure TLAS;

uint GroupCount;

float MinTraceDistance;
float MaxTraceDistance;
float MinTraceDistanceToSampleSurface;
float SurfaceBias;
uint RayCountPerTexelShift;
StructuredBuffer<float4> RayDirections;

RWTexture2D<float4> RWRadiosityAtlas;
RWTexture2D<float3> RWRayBuffer;

float3 CalculateWorldDirection(uint SampleIndex, uint SampleCount, float3 WorldNormal)
{
	float3 LocalDirection = RayDirections[SampleIndex].xyz;
	float3x3 TangentBasis = GetTangentBasisFrisvad(WorldNormal);

	float3 WorldDirection = mul(LocalDirection, TangentBasis);
	return WorldDirection;
}

RAY_TRACING_ENTRY_RAYGEN(LumenRadiosityHardwareRayTracingRGS)
{
	uint ThreadIndex = DispatchRaysIndex().y;

	uint2 TexelLocalCoord = uint2(ThreadIndex % RADIOSITY_TRACE_TILE_SIZE_2D, ThreadIndex / RADIOSITY_TRACE_TILE_SIZE_2D);
	for (uint GroupIndex = DispatchRaysIndex().x; GroupIndex < CardTraceBlockAllocator[0] * RayCountPerTexel; GroupIndex += GroupCount)
	{
		//uint TraceTileIndex = GroupIndex / RayCountPerTexel;
		//uint RayIndex = GroupIndex % RayCountPerTexel;
		uint TraceTileIndex = GroupIndex >> RayCountPerTexelShift;
		uint RayIndex = GroupIndex - TraceTileIndex * RayCountPerTexel;

		FRadiosityTexel RadiosityTexel = GetRadiosityTexel(TraceTileIndex, TexelLocalCoord);

		if (RadiosityTexel.bValid)
		{
			FRayTracedLightingResult RayResult = (FRayTracedLightingResult)0;
			RayResult.Radiance = float3(0.0f, 0.0f, 0.0f);

			if (RadiosityTexel.Opacity > 0.0f)
			{
				float3 WorldPosition = RadiosityTexel.WorldPosition;
				float3 WorldNormal = RadiosityTexel.WorldNormal;
				float3 WorldDirection = CalculateWorldDirection(RayIndex, RayCountPerTexel, WorldNormal);

				RayDesc Ray;
				Ray.Origin = WorldPosition + WorldNormal * SurfaceBias;
				Ray.Direction = WorldDirection;
				Ray.TMin = MinTraceDistance;
				Ray.TMax = MaxTraceDistance;

				FRayCone RayCone = (FRayCone)0;
				float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(RayCountPerTexel));
				RayCone = PropagateRayCone(RayCone, ConeHalfAngle, 0.0);

				const uint LinearCoord = TexelLocalCoord.y * RADIOSITY_TRACE_TILE_SIZE_2D + TexelLocalCoord.x;
				const bool bCullBackFacingTriangles = true;
				FRayTracedLightingContext Context = CreateRayTracedLightingContext(TLAS, RayCone, TexelLocalCoord, LinearCoord, bCullBackFacingTriangles);

				if (DIM_USE_SURFACE_CACHE)
				{
					RayResult = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context);
				}
				else
				{
					FLumenMinimalPayload Payload;
					RayResult.bIsHit = TraceLumenMinimalRay(Ray, Context, Payload);
				}

				if (RayResult.TraceHitDistance < MinTraceDistanceToSampleSurface)
				{
					RayResult.Radiance = 0.0f;
				}

				if (!RayResult.bIsHit)
				{
					FConeTraceResult TraceResult = (FConeTraceResult)0;
					TraceResult.Transparency = 1;
					EvaluateSkyRadianceForCone(Ray.Direction, tan(ConeHalfAngle), TraceResult);
					RayResult.Radiance = TraceResult.Lighting;
				}
			}

			uint2 RayBufferWriteCoord = GetRayBufferCoord(TraceTileIndex, TexelLocalCoord, RayIndex);
			RWRayBuffer[RayBufferWriteCoord] = RayResult.Radiance;
		}
	}
}