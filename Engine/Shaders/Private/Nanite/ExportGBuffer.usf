// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../VelocityCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

ByteAddressBuffer MaterialSlotTable;
ByteAddressBuffer MaterialDepthTable;
ByteAddressBuffer MaterialHitProxyTable;

uint DummyZero; // TODO: Remove me
uint StencilClear;
uint StencilDecal;

Texture2D<UlongType> VisBuffer64;
Texture2D<uint> MaterialResolve;
StructuredBuffer<uint> MaterialTileRemap;

void MarkStencilPS(
	in float4 SvPosition	: SV_Position,
	out float OutDepth		: SV_Depth
)
{
	const uint2 PixelPos = (uint2)SvPosition.xy;
	const UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		OutDepth = asfloat(DepthInt);
	}
	else
	{
		discard;
	}
}

void EmitMaterialDepthPS(
	in  float4 SvPosition	: SV_Position,
	out float  OutDepth		: SV_Depth
)
{
	const uint2 PixelPos = (uint2)SvPosition.xy;
	uint MaterialSlot = 0;

#if MATERIAL_RESOLVE
	bool IsNanitePixel = false;
	bool IsDecalReceiver = false;
	UnpackMaterialResolve(MaterialResolve[PixelPos], IsNanitePixel, IsDecalReceiver, MaterialSlot);
#else
	UlongType VisPixel  = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	const bool IsNanitePixel = VisibleClusterIndex != 0xFFFFFFFF;
	if (IsNanitePixel)
	{
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData = GetInstanceSceneData( VisibleCluster );
		FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		MaterialSlot = GetMaterialSlot(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialSlotTable);
	}
#endif

	if (IsNanitePixel)
	{
		// Export material depth ID as SV_Depth.
		const uint MaterialDepthId = GetMaterialDepthId(MaterialSlot, MaterialDepthTable);
		OutDepth = asfloat(MaterialDepthId | DummyZero); // Workaround for bug on Geforce 2080Ti. It seems the issue might be related to writing directly to OutDepth in a buffer load instruction.
	}
	else
	{
		discard;
	}
}

void EmitSceneDepthPS(
	in float4  SvPosition			: SV_Position,
#if MATERIAL_RESOLVE
	out uint   OutMaterialResolve	: SV_Target0,
#endif
#if VELOCITY_EXPORT
	out float4 OutVelocity			: SV_Target1,
#endif
	out float  OutDepth				: SV_Depth
)
{
#if VELOCITY_EXPORT
	FNaniteView NaniteView = GetNaniteView(0);
#endif

	uint2 PixelPos = (uint2)SvPosition.xy;
	UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
#if VELOCITY_EXPORT || MATERIAL_RESOLVE
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		const FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster);
#endif

#if MATERIAL_RESOLVE
		const FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		const uint MaterialSlot = GetMaterialSlot(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialSlotTable);
		const bool IsDecalReceiver = (GetPrimitiveData(InstanceData.PrimitiveId).Flags & PRIMITIVE_SCENE_DATA_FLAG_DECAL_RECEIVER) != 0 && View.ShowDecalsMask > 0;
		OutMaterialResolve = PackMaterialResolve(MaterialSlot, IsDecalReceiver);
#endif

#if VELOCITY_EXPORT
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

		const float4 ScreenPos = SvPositionToScreenPosition(float4(SvPosition.xy, asfloat(DepthInt), 1.0f));
		const float3 WorldPos  = SvPositionToWorld(float4(SvPosition.xy, asfloat(DepthInt), 1.0f));
		const float4 LocalPos  = mul(float4(WorldPos.xyz, 1.0f), InstanceData.WorldToLocal);

		const float4 ScreenPosPrev = mul(float4(LocalPos.xyz, 1), InstanceDynamicData.PrevLocalToClip);
		
		const float3 Velocity = Calculate3DVelocity(ScreenPos, ScreenPosPrev);
		OutVelocity = EncodeVelocityToTexture(Velocity);
#endif

		OutDepth = asfloat(DepthInt);
	}
	else
	{
		discard;
	}
}

void EmitSceneStencilPS(
	in float4 SvPosition	: SV_Position,
	out float OutDepth		: SV_Depth
)
{
	const uint2 PixelPos = (uint2)SvPosition.xy;

	bool IsNanitePixel = false;
	bool IsDecalReceiver = false;
	uint MaterialSlot = 0;
	UnpackMaterialResolve(MaterialResolve[PixelPos], IsNanitePixel, IsDecalReceiver, MaterialSlot);

	BRANCH
	if (IsNanitePixel && IsDecalReceiver)
	{
		UlongType VisPixel = VisBuffer64[PixelPos];
		uint DepthInt = 0;
		uint VisibleClusterIndex = 0;
		uint TriIndex = 0;
		UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);
		OutDepth = asfloat(DepthInt);
	}
	else
	{
		OutDepth = 0.0f;
		discard;
	}
}

void EmitSceneDepthStencilPS
(
	in float4  SvPosition			: SV_Position,
	out uint   OutMaterialResolve	: SV_Target0,
#if VELOCITY_EXPORT
	out float4 OutVelocity			: SV_Target1,
#endif
	out float  OutDepth				: SV_Depth,
	out uint   OutStencil			: SV_StencilRef // Requires GRHISupportsStencilRefFromPixelShader
)
{
	uint2 PixelPos = (uint2)SvPosition.xy;
	UlongType VisPixel = VisBuffer64[PixelPos];

	FNaniteView NaniteView = GetNaniteView(0);

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		const FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster);
		const FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

		const uint MaterialSlot = GetMaterialSlot(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialSlotTable);
		const bool IsDecalReceiver = (GetPrimitiveData(InstanceData.PrimitiveId).Flags & PRIMITIVE_SCENE_DATA_FLAG_DECAL_RECEIVER) != 0 && View.ShowDecalsMask > 0;
		
#if VELOCITY_EXPORT
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

		const float4 ScreenPos = SvPositionToScreenPosition(float4(SvPosition.xy, asfloat(DepthInt), 1.0f));
		const float3 WorldPos  = SvPositionToWorld(float4(SvPosition.xy, asfloat(DepthInt), 1.0f));
		const float4 LocalPos  = mul(float4(WorldPos.xyz, 1.0f), InstanceData.WorldToLocal);

		const float4 ScreenPosPrev = mul(float4(LocalPos.xyz, 1), InstanceDynamicData.PrevLocalToClip);
		
		const float3 Velocity = Calculate3DVelocity(ScreenPos, ScreenPosPrev);
		OutVelocity = EncodeVelocityToTexture(Velocity);
#endif

		OutDepth = asfloat(DepthInt);
		OutMaterialResolve = PackMaterialResolve(MaterialSlot, IsDecalReceiver);

		OutStencil = CondMask(IsDecalReceiver, StencilDecal, StencilClear);

		//@todo - proper support
		OutStencil |= 1 << LIGHTING_CHANNELS_TEXTURE_DISTANCE_FIELD_REPRESENTATION_BIT;
	}
	else
	{
		discard;
	}
}

float ViewToClip22;
float DepthBias;

Texture2D< uint > DepthBuffer;

void EmitShadowMapPS(
	in float4 SvPosition	: SV_Position,
	out float OutDepth		: SV_Depth
)
{
	OutDepth = 0;

	uint2 PixelPos = (uint2)SvPosition.xy;
	uint DepthInt = DepthBuffer[ PixelPos ];

	if( DepthInt != 0 )
	{
		float DeviceZ = asfloat( DepthInt );

#if DEPTH_OUTPUT_TYPE == 0
		// Standard depth
		OutDepth = DeviceZ;
#elif DEPTH_OUTPUT_TYPE == 1
		// Ortho shadow maps
		OutDepth = 1 - DeviceZ + DepthBias;
#else
		// Perspective shadow maps
		OutDepth = ViewToClip22 * ( DeviceZ - 1 ) / ( DeviceZ - ViewToClip22 ) + DepthBias;
		//MinZ = View.ViewToClip[3][2] / ( 1 - View.ViewToClip[2][2] );
		//ViewZ = View.ViewToClip[3][2] / ( DeviceZ - View.ViewToClip[2][2] );
#endif
	}
	else
	{
		discard;
	}
}

void EmitHitProxyIdPS(
	in float4 SvPosition		: SV_Position,
	out float4 OutHitProxyId	: SV_Target0,
	out float OutDepth			: SV_Depth
)
{
	uint2 PixelPos = (uint2)SvPosition.xy;
	UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster);
		FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		const uint MaterialHitProxyId = GetMaterialHitProxyId(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialHitProxyTable);
		float4 HitProxyId = float4(
			float((MaterialHitProxyId >> 16) & 0xFF) / 255.0f,
			float((MaterialHitProxyId >>  8) & 0xFF) / 255.0f,
			float((MaterialHitProxyId >>  0) & 0xFF) / 255.0f,
			0
			);
		OutHitProxyId = HitProxyId;
		OutDepth = asfloat(DepthInt);
	}
	else
	{
		discard;
	}
}

uint LowerBound(Buffer<uint> SearchBuffer, uint BufferCount, uint Key)
{
	uint idx = 0;
	uint width = BufferCount >> 1;
	
	UNROLL
	while (width > 0)
	{
		idx += (Key < SearchBuffer[idx + width]) ? 0 : width;
		width = width >> 1;
	}
	
	return idx;
}

bool BinarySearch(Buffer<uint> SearchBuffer, uint BufferCount, uint Key)
{
	uint idx = LowerBound(SearchBuffer, BufferCount, Key);
	return SearchBuffer[idx] == Key;
}


#if EDITOR_SELECTED_BUFFER_COUNT > 0 || EDITOR_LEVELINSTANCE_BUFFER_COUNT > 0
float2 OutputToInputScale;
float2 OutputToInputBias;
#endif

#if EDITOR_LEVELINSTANCE_BUFFER_COUNT > 0

void EmitEditorLevelInstanceDepthPS(
	float4 SvPosition  : SV_Position,
	out float OutDepth : SV_Depth
)
{
	uint2 PixelPos = (uint2)(SvPosition.xy * OutputToInputScale + OutputToInputBias);
	UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster);
		FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		const uint MaterialHitProxyId = GetMaterialHitProxyId(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialHitProxyTable);
		if (BinarySearch(View.EditorVisualizeLevelInstanceIds, EDITOR_LEVELINSTANCE_BUFFER_COUNT, MaterialHitProxyId))
		{
			OutDepth = asfloat(DepthInt);
		}
		else
		{
			discard;
		}
	}
	else
	{
		discard;
	}
}
#endif

#if EDITOR_SELECTED_BUFFER_COUNT > 0

void EmitEditorSelectionDepthPS(
	float4 SvPosition  : SV_Position,
	out float OutDepth : SV_Depth
)
{
	uint2 PixelPos = (uint2)(SvPosition.xy * OutputToInputScale + OutputToInputBias);
	UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster);
		FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		const uint MaterialHitProxyId = GetMaterialHitProxyId(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialHitProxyTable);
		if (BinarySearch(View.EditorSelectedHitProxyIds, EDITOR_SELECTED_BUFFER_COUNT, MaterialHitProxyId))
		{
			OutDepth = asfloat(DepthInt);
		}
		else
		{
			discard;
		}
	}
	else
	{
		discard;
	}
}

#endif

float MaterialDepth;
uint MaterialSlot;
uint TileRemapCount;
uint InstanceBaseOffset;

struct FVertexFactoryInterpolantsVSToPS
{
	float4 LightMapCoordinate : TEXCOORD3;
	uint LightmapDataIndex : LIGHTMAP_ID;
	uint EyeIndex : PACKED_EYE_INDEX;
	uint ViewIndex : PACKED_VIEW_INDEX;
};

void FullScreenVS(
	float2 InPosition : ATTRIBUTE0,
	uint InstanceIndex : SV_InstanceID,
	out FVertexFactoryInterpolantsVSToPS Output,	// Always produce all outputs to work around shader linkage errors without introducing permutations.
	out float4 Position : SV_Position

)
{
	const bool bIndirect = Nanite.MaterialConfig.x != 0;
	const uint2 GridSize = Nanite.MaterialConfig.yz;

	Output = (FVertexFactoryInterpolantsVSToPS)0;

	uint TileIndex = InstanceIndex;

	BRANCH
	if (bIndirect)
	{
		const uint TargetTileCount = TileIndex + 1;

		uint ValidTiles = 0;

		// Remap compacted tile index to sparse tile index
		// If compacted index is 7, the first 4 indices are valid, but the next 2 are not, the sparse index is 9
		// Basically figure out how many preceeding empty slots exist, so we can shift the index by that. (reverse prefix sum w/ linear scan)
		const uint RemapBaseOffset = (TileRemapCount * MaterialSlot);

		// TODO: Could optimize by having material classify store out the prefix sum per remap uint, and then binary search the result quicker

		uint RemapBin  = 0;
		uint RemapData = 0;

		LOOP
		for (; RemapBin < TileRemapCount; ++RemapBin)
		{
			RemapData = Nanite.MaterialTileRemap[RemapBaseOffset + RemapBin];

			const uint SumValidTiles = ValidTiles + countbits(RemapData); // Count number of valid tiles in bin
			if (SumValidTiles < TargetTileCount)
			{
				// Keeping going
				ValidTiles = SumValidTiles;
			}
			else
			{
				// Found the target bin
				break;
			}
		}

		uint RemapBinBit = 0;

		LOOP
		while (RemapData != 0)
		{
			RemapBinBit = firstbitlow(RemapData);
			RemapData &= ~(1u << RemapBinBit);
			++ValidTiles;
			if (ValidTiles == TargetTileCount)
			{
				// Arrived at sparse tile index
				break;
			}
		}

		TileIndex = (RemapBin * 32u) + RemapBinBit;
	}

	float4 RectScaleOffset = Nanite.RectScaleOffset;

	BRANCH
	if (Nanite.MultiViewEnabled > 0)
	{
		// Treat InstanceIndex for view indexing if multi view rendering is enabled
		TileIndex = 0;

		const uint ViewIndex = Nanite.MultiViewIndices[InstanceBaseOffset + InstanceIndex];
		RectScaleOffset = Nanite.MultiViewRectScaleOffsets[ViewIndex];
		Output.ViewIndex = ViewIndex;	
	}

	float2 GridStep = float2(1.0, 1.0) / (float2)GridSize;
	uint2  GridPos  = uint2(TileIndex % GridSize.x, TileIndex / GridSize.x);

	// Input position is in [0,0 .. 1,1] range.
	float2 TilePosition = (InPosition + (float2)GridPos) * GridStep;
	TilePosition.xy = TilePosition.xy * RectScaleOffset.xy + RectScaleOffset.zw;

	const float Depth = MaterialDepth;
	const uint MaterialBucketId = GetMaterialBucketIdFromDepth(Depth);

	Position = float4(TilePosition.x * 2.0 - 1.0, 1.0 - 2.0 * TilePosition.y, Depth, 1);
}
