// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "NaniteDataDecode.ush"
#include "../VirtualShadowMaps/PageAccessCommon.ush"
#include "../VirtualShadowMaps/StaticCaching.ush"
#include "WritePixel.ush"

#define SUBPIXEL_BITS				8
#define SUBPIXEL_SAMPLES			(1 << SUBPIXEL_BITS)
#define SUBPIXEL_MASK				(SUBPIXEL_SAMPLES - 1)
#define SUBPIXEL_DILATE				0	// To correct for mismatch with HW rasterizer

#if VISUALIZE
uint VisualizeModeBitMask;

uint2 GetVisualizeValues()
{
	uint VisualizeValueMax = 0; // InterlockedMax64 using depth (value associated with surviving fragment)
	uint VisualizeValueAdd = 0; // InterlockedAdd32 (value accumulated with every evaluated fragment)
	
	if (VisualizeModeBitMask & VISUALIZE_RASTER_MODE)
	{
	#if SOFTWARE_RASTER
		VisualizeValueMax = 2; // Software Raster
	#else
		VisualizeValueMax = 1; // Hardware Raster
	#endif
	}

	if (VisualizeModeBitMask & VISUALIZE_OVERDRAW)
	{
		VisualizeValueAdd = 1;
	}

	return uint2(VisualizeValueMax, VisualizeValueAdd);
}
#endif

void RasterizeTri(
	FNaniteView NaniteView,
	int4 ViewRect,
	uint PixelValue,
#if VISUALIZE
	uint2 VisualizeValues,
#endif
	float3 Verts[3],
	WritePixelPageTranslation PageTranslation)
{
	float3 v01 = Verts[1] - Verts[0];
	float3 v02 = Verts[2] - Verts[0];

	float DetXY = v01.x * v02.y - v01.y * v02.x;
	if( DetXY >= 0.0f )
	{
		// Backface
		// If not culling, need to swap verts to correct winding for rest of code
		return;
	}

	float InvDet = rcp( DetXY );
	float2 GradZ;
	GradZ.x = ( v01.z * v02.y - v01.y * v02.z ) * InvDet;
	GradZ.y = ( v01.x * v02.z - v01.z * v02.x ) * InvDet;

	// 16.8 fixed point
	float2 Vert0 = Verts[0].xy;
	float2 Vert1 = Verts[1].xy;
	float2 Vert2 = Verts[2].xy;

	// Bounding rect
	const float2 MinSubpixel = min3( Vert0, Vert1, Vert2 );
	const float2 MaxSubpixel = max3( Vert0, Vert1, Vert2 );

#if 0
	bool2 bMissCenter =	( MinSubpixel & SUBPIXEL_MASK > (SUBPIXEL_SAMPLES / 2) ) &&
						( MaxSubpixel - ( MinSubpixel & ~SUBPIXEL_MASK ) + (SUBPIXEL_SAMPLES / 2) ) < SUBPIXEL_MASK;
	if( any( bMissCenter ) )
		return;
#endif

	// Round to nearest pixel
	int2 MinPixel = (int2)floor( ( MinSubpixel + (SUBPIXEL_SAMPLES / 2) - 1 ) * (1.0 / SUBPIXEL_SAMPLES) );
	int2 MaxPixel = (int2)floor( ( MaxSubpixel - (SUBPIXEL_SAMPLES / 2) - 1 ) * (1.0 / SUBPIXEL_SAMPLES) );	// inclusive!

	// Clip to viewport
	MinPixel = max( MinPixel, ViewRect.xy );
	MaxPixel = min( MaxPixel, ViewRect.zw - 1 );
	
	// Force 1 pixel
	//MaxPixel = max( MaxPixel, MinPixel );
	
	// Cull when no pixels covered
	if( any( MinPixel > MaxPixel ) )
		return;

	// Limit the rasterizer bounds to a sensible max.
	MaxPixel = min( MaxPixel, MinPixel + 63 );

	// 4.8 fixed point
	float2 Edge01 = -v01.xy;
	float2 Edge12 = Vert1 - Vert2;
	float2 Edge20 = v02.xy;
	
	// Rebase off MinPixel with half pixel offset
	// 4.8 fixed point
	// Max triangle size = 127x127 pixels
	const float2 BaseSubpixel = (float2)MinPixel * SUBPIXEL_SAMPLES + (SUBPIXEL_SAMPLES / 2);
	Vert0 -= BaseSubpixel;
	Vert1 -= BaseSubpixel;
	Vert2 -= BaseSubpixel;

	// Half-edge constants
	// 8.16 fixed point
	float C0 = Edge01.y * Vert0.x - Edge01.x * Vert0.y;
	float C1 = Edge12.y * Vert1.x - Edge12.x * Vert1.y;
	float C2 = Edge20.y * Vert2.x - Edge20.x * Vert2.y;

	// Correct for fill convention
	// Top left rule for CCW
#if 1
	C0 -= saturate(Edge01.y + saturate(1.0f - Edge01.x));
	C1 -= saturate(Edge12.y + saturate(1.0f - Edge12.x));
	C2 -= saturate(Edge20.y + saturate(1.0f - Edge20.x));
#else
	C0 -= ( Edge01.y < 0 || ( Edge01.y == 0 && Edge01.x > 0 ) ) ? 0 : 1;
	C1 -= ( Edge12.y < 0 || ( Edge12.y == 0 && Edge12.x > 0 ) ) ? 0 : 1;
	C2 -= ( Edge20.y < 0 || ( Edge20.y == 0 && Edge20.x > 0 ) ) ? 0 : 1;
#endif

	float Z0 = Verts[0].z - ( GradZ.x * Vert0.x + GradZ.y * Vert0.y );
	GradZ *= SUBPIXEL_SAMPLES;
	
	// Step in pixel increments
	// 8.16 fixed point
	//Edge01 *= SubpixelSamples;
	//Edge12 *= SubpixelSamples;
	//Edge20 *= SubpixelSamples;

	// Scale C0/C1/C2 down by SubpixelSamples instead of scaling Edge01/Edge12/Edge20 up. Lossless because SubpixelSamples is a power of two.
	float CY0 = C0 * (1.0f / SUBPIXEL_SAMPLES);
	float CY1 = C1 * (1.0f / SUBPIXEL_SAMPLES);
	float CY2 = C2 * (1.0f / SUBPIXEL_SAMPLES);
	float ZY = Z0;

#if COMPILER_SUPPORTS_WAVE_VOTE
	bool bScanLine = WaveActiveAnyTrue( MaxPixel.x - MinPixel.x > 4 );
#else
	bool bScanLine = false;
#endif
	if( bScanLine )
	{
		float3 Edge012 = { Edge01.y, Edge12.y, Edge20.y };
		bool3 bOpenEdge = Edge012 < 0;
		float3 InvEdge012 = Edge012 == 0 ? 1e8 : rcp( Edge012 );

		int y = MinPixel.y;
		while( true )
		{
			//float CX0 = CY0 - Edge01.y * (x - MinPixel.x);
			// Edge01.y * (x - MinPixel.x) <= CY0;

			/*
			if( Edge01.y > 0 )
				x <= CY0 / Edge01.y + MinPixel.x;	// Closing edge
			else
				x >= CY0 / Edge01.y + MinPixel.x;	// Opening edge
			*/
			
			// No longer fixed point
			float3 CrossX = float3( CY0, CY1, CY2 ) * InvEdge012;

			float3 MinX = bOpenEdge ? CrossX : 0;
			float3 MaxX = bOpenEdge ? MaxPixel.x - MinPixel.x : CrossX;

			float x0 = ceil( max3( MinX.x, MinX.y, MinX.z ) );
			float x1 = min3( MaxX.x, MaxX.y, MaxX.z );
			float ZX = ZY + GradZ.x * x0;

			x0 += MinPixel.x;
			x1 += MinPixel.x;
			for( float x = x0; x <= x1; x++ )
			{
				WritePixel(OutVisBuffer64, PixelValue, uint2(x,y), ZX, PageTranslation);
			#if VISUALIZE
				WritePixel(OutDbgBuffer64, VisualizeValues.x, uint2(x,y), ZX, PageTranslation);
				InterlockedAdd(OutDbgBuffer32[uint2(x,y)], VisualizeValues.y);
			#endif

				ZX += GradZ.x;
			}

			if( y >= MaxPixel.y )
				break;

			CY0 += Edge01.x;
			CY1 += Edge12.x;
			CY2 += Edge20.x;
			ZY += GradZ.y;
			y++;
		}
	}
	else
	{
		int y = MinPixel.y;

		while (true)
		{
			int x = MinPixel.x;
			if (min3(CY0, CY1, CY2) >= 0)
			{
				WritePixel(OutVisBuffer64, PixelValue, uint2(x, y), ZY, PageTranslation);
			#if VISUALIZE
				WritePixel(OutDbgBuffer64, VisualizeValues.x, uint2(x, y), ZY, PageTranslation);
				InterlockedAdd(OutDbgBuffer32[uint2(x, y)], VisualizeValues.y);
			#endif
			}

			if (x < MaxPixel.x)
			{
				float CX0 = CY0 - Edge01.y;
				float CX1 = CY1 - Edge12.y;
				float CX2 = CY2 - Edge20.y;
				float ZX = ZY + GradZ.x;
				x++;

				HOIST_DESCRIPTORS
				while (true)
				{
					if (min3(CX0, CX1, CX2) >= 0)
					{
						WritePixel(OutVisBuffer64, PixelValue, uint2(x, y), ZX, PageTranslation);
					#if VISUALIZE
						WritePixel(OutDbgBuffer64, VisualizeValues.x, uint2(x, y), ZX, PageTranslation);
						InterlockedAdd(OutDbgBuffer32[uint2(x, y)], VisualizeValues.y);
					#endif
					}

					if (x >= MaxPixel.x)
						break;

					CX0 -= Edge01.y;
					CX1 -= Edge12.y;
					CX2 -= Edge20.y;
					ZX += GradZ.x;
					x++;
				}
			}

			if (y >= MaxPixel.y)
				break;

			CY0 += Edge01.x;
			CY1 += Edge12.x;
			CY2 += Edge20.x;
			ZY += GradZ.y;
			y++;
		}
	}
}

#if USE_CONSTRAINED_CLUSTERS
groupshared float3 GroupVerts[256];
#else
groupshared float3 GroupVerts[384];
#endif

// Default cull mode is CW. If this returns true, CCW culling is required
bool ReverseWindingOrder(FInstanceSceneData InstanceData)
{
	// Negative determinant sign for non uniform scale means
	// that an odd number of components are negative, so
	// we need to reverse the triangle winding order.
	bool bReverseInstanceCull = (InstanceData.DeterminantSign < 0.0f);
	bool bRasterStateReverseCull = (RenderFlags & RENDER_FLAG_REVERSE_CULLING);
	
	// Logical XOR
	return (bReverseInstanceCull != bRasterStateReverseCull);
}

StructuredBuffer< uint2 >	InTotalPrevDrawClusters;
Buffer<uint>				InClusterOffsetSWHW;

[numthreads(64, 1, 1)]
void MicropolyRasterize(
	uint	VisibleIndex	: SV_GroupID,
	uint	GroupIndex		: SV_GroupIndex) 
{
#if HAS_PREV_DRAW_DATA
	VisibleIndex += InTotalPrevDrawClusters[0].x;
#endif
#if ADD_CLUSTER_OFFSET
	VisibleIndex += InClusterOffsetSWHW[0];
#endif

	// Should be all scalar.
	FVisibleCluster VisibleCluster = GetVisibleCluster( VisibleIndex, VIRTUAL_TEXTURE_TARGET );
	FInstanceSceneData InstanceData = GetInstanceSceneData( VisibleCluster.InstanceId, false );
	FNaniteView NaniteView = GetNaniteView( VisibleCluster.ViewId );
	
	// Virtual shadow maps can scatter instances into different physical pages for caching purposes
	bool bVirtualTargetStaticPage = false;
#if VIRTUAL_TEXTURE_TARGET
	bVirtualTargetStaticPage = ShouldCacheInstanceAsStatic( InstanceData );
#endif

#if CLUSTER_PER_PAGE
	// Scalar
	uint2 vPage = VisibleCluster.vPage;
	uint2 pPageAddress = ShadowGetPhysicalPage( CalcPageTableLevelOffset( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel ) + CalcPageOffsetInLevel( NaniteView.TargetMipLevel, vPage ) ).PhysicalAddress;	
	WritePixelPageTranslation PageTranslation = InitializeWritePixelPageTranslation();
	// We can just move the physical page address we're rasterizing into
	pPageAddress += bVirtualTargetStaticPage ? GetVirtualShadowMapStaticPixelOffset() >> VSM_LOG2_PAGE_SIZE : uint2( 0, 0 );
#else
	// Per-pixel page translation means we need to pass through an offset to WritePixel
	WritePixelPageTranslation PageTranslation = InitializeWritePixelPageTranslation( NaniteView, bVirtualTargetStaticPage );
#endif

	FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

	float2 SubpixelScale = float2(0.5, -0.5) * NaniteView.ViewSizeAndInvSize.xy * SUBPIXEL_SAMPLES;
	float2 SubpixelBias = (0.5 * NaniteView.ViewSizeAndInvSize.xy + NaniteView.ViewRect.xy) * SUBPIXEL_SAMPLES + 0.5f;
#if CLUSTER_PER_PAGE
	SubpixelBias += ( (float2)pPageAddress - (float2)vPage ) * VSM_PAGE_SIZE * SUBPIXEL_SAMPLES;
#endif

	FCluster Cluster = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

	UNROLL
	for( uint i = 0; i < 4; i++ )
	{
		uint VertIndex = GroupIndex + i * 64;
		if( VertIndex < Cluster.NumVerts )
		{
			// Transform vertex and store in group shared memory.
			float3 PointLocal = DecodePosition( VertIndex, Cluster );
			float4 PointClipSubpixel = mul( mul( float4( PointLocal, 1 ), InstanceDynamicData.LocalToTranslatedWorld ), NaniteView.TranslatedWorldToClip );

			float3 Subpixel = PointClipSubpixel.xyz / PointClipSubpixel.w;
			Subpixel.xy = Subpixel.xy * SubpixelScale.xy + SubpixelBias.xy;

			GroupVerts[ VertIndex ] = float3(floor(Subpixel.xy), Subpixel.z);
		}
	}
	
	GroupMemoryBarrierWithGroupSync();

	int4 ViewRect = NaniteView.ViewRect;

#if CLUSTER_PER_PAGE
	ViewRect.xy = pPageAddress * VSM_PAGE_SIZE;
	ViewRect.zw = ViewRect.xy + VSM_PAGE_SIZE;
#endif

	UNROLL
	for( uint i = 0; i < 2; i++ )
	{
		uint TriangleID = GroupIndex + i * 64;
		if (TriangleID < Cluster.NumTris)
		{
			uint3 TriangleIndices = ReadTriangleIndices(Cluster, TriangleID);
			if (ReverseWindingOrder(InstanceData))
			{
				TriangleIndices = uint3(TriangleIndices.x, TriangleIndices.z, TriangleIndices.y);
			}

			float3 Vertices[3];
			Vertices[0] = GroupVerts[TriangleIndices.x];
			Vertices[1] = GroupVerts[TriangleIndices.y];
			Vertices[2] = GroupVerts[TriangleIndices.z];

			uint PixelValue = ((VisibleIndex + 1) << 7) | TriangleID;

			RasterizeTri(
				NaniteView,
				ViewRect,
				PixelValue,
			#if VISUALIZE
				GetVisualizeValues(),
			#endif
				Vertices,
				PageTranslation);
		}
	}
}

#define PIXEL_VALUE					(RASTER_TECHNIQUE != RASTER_TECHNIQUE_DEPTHONLY)
#define VERTEX_TO_TRIANGLE_MASKS	(NANITE_PRIM_SHADER && PIXEL_VALUE)

struct VSOut
{
#if !NEAR_CLIP
	float2 ClipZW							: TEXCOORD0;
#endif
#if PIXEL_VALUE
	nointerpolation uint PixelValue			: TEXCOORD1;
#endif
#if NANITE_MULTI_VIEW
	nointerpolation int4 ViewRect			: TEXCOORD2;
#endif
#if VISUALIZE
	nointerpolation uint2 VisualizeValues	: TEXCOORD3;
#endif
#if VIRTUAL_TEXTURE_TARGET
	nointerpolation uint PackedPageInfo		: TEXCOORD4;
#endif
#if VERTEX_TO_TRIANGLE_MASKS
	CUSTOM_INTERPOLATION uint4 ToTriangleMasks	: TEXCOORD5;
#endif
#if NANITE_MESH_SHADER_INTERP == 1
	float4 InterpPosition					: TEXCOORD6;
#endif
	float4 Position							: SV_Position;
};

VSOut CommonRasterizerVS(FNaniteView NaniteView, FInstanceSceneData InstanceData, FVisibleCluster VisibleCluster, FCluster Cluster, uint VertIndex, out float4 PointClipNoScaling)
{
	VSOut Out;

	float4x4 LocalToTranslatedWorld = LWCMultiplyTranslation(InstanceData.LocalToWorld, NaniteView.PreViewTranslation);
	float3 PointLocal = DecodePosition( VertIndex, Cluster );
	float3 PointRotated = LocalToTranslatedWorld[0].xyz * PointLocal.xxx + LocalToTranslatedWorld[1].xyz * PointLocal.yyy + LocalToTranslatedWorld[2].xyz * PointLocal.zzz;
	float3 PointTranslatedWorld = PointRotated + LocalToTranslatedWorld[3].xyz;
	float4 PointClip = mul( float4( PointTranslatedWorld, 1 ), NaniteView.TranslatedWorldToClip );
	PointClipNoScaling = PointClip;
#if CLUSTER_PER_PAGE
	/*
	float2 vUV = PointClip.xy * float2(0.5, -0.5) + 0.5 * PointClip.w;
	float2 vPixels = vUV * NaniteView.ViewSizeAndInvSize.xy;
	float2 LocalPixels = vPixels - VisibleCluster.vPage * VSM_PAGE_SIZE * PointClip.w;
	float2 LocalUV = LocalPixels / ( 4 * VSM_PAGE_SIZE );
	float2 LocalClip = LocalUV * float2(2, -2) + float2(-1, 1) * PointClip.w;
	PointClip.xy = LocalClip;
	*/
	PointClip.xy = NaniteView.ClipSpaceScaleOffset.xy * PointClip.xy + NaniteView.ClipSpaceScaleOffset.zw * PointClip.w;

	// Offset 0,0 to be at vPage for a 0, VSM_PAGE_SIZE * VSM_RASTER_WINDOW_PAGES viewport.
	PointClip.xy += PointClip.w * ( float2(-2, 2) / VSM_RASTER_WINDOW_PAGES ) * VisibleCluster.vPage;

	Out.ViewRect.xy = VisibleCluster.vPage * VSM_PAGE_SIZE;
	Out.ViewRect.zw = NaniteView.ViewRect.zw;
#elif NANITE_MULTI_VIEW
	PointClip.xy = NaniteView.ClipSpaceScaleOffset.xy * PointClip.xy + NaniteView.ClipSpaceScaleOffset.zw * PointClip.w;
	Out.ViewRect = NaniteView.ViewRect;
#endif
#if VIRTUAL_TEXTURE_TARGET
	FPageInfo PageInfo;
	PageInfo.ViewId = VisibleCluster.ViewId;
	PageInfo.bStaticPage = ShouldCacheInstanceAsStatic( InstanceData );
	Out.PackedPageInfo = PackPageInfo( PageInfo );
#endif
	Out.Position = PointClip;
#if !NEAR_CLIP
	Out.ClipZW = PointClip.zw;
#endif

	// Shader workaround to avoid HW depth clipping. Should be replaced with rasterizer state ideally.
#if !NEAR_CLIP
	Out.Position.z = 0.5f * Out.Position.w;
#endif

#if NANITE_MESH_SHADER_INTERP == 1
	Out.InterpPosition = Out.Position;
#endif

#if VISUALIZE
	Out.VisualizeValues = GetVisualizeValues();
#endif
	return Out;
}

#if NANITE_PRIM_SHADER

#pragma argument(wavemode=wave64)
#pragma argument(realtypes)

struct PrimitiveInput
{
	uint Index		: PRIM_SHADER_SEM_VERT_INDEX;
	uint WaveIndex	: PRIM_SHADER_SEM_WAVE_INDEX;
};

struct PrimitiveOutput
{
	VSOut Out;

	uint PrimExport	: PRIM_SHADER_SEM_PRIM_EXPORT;
	uint VertCount	: PRIM_SHADER_SEM_VERT_COUNT;
	uint PrimCount	: PRIM_SHADER_SEM_PRIM_COUNT;
};

uint PackTriangleExport(uint3 TriangleIndices)
{
    return TriangleIndices.x | (TriangleIndices.y << 10) | (TriangleIndices.z << 20);
}

uint3 UnpackTriangleExport(uint Packed)
{
	const uint Index0 = (Packed & 0x3FF);
	const uint Index1 = (Packed >> 10) & 0x3FF;
	const uint Index2 = (Packed >> 20);
	return uint3(Index0, Index1, Index2);
}

#if VERTEX_TO_TRIANGLE_MASKS
groupshared uint GroupVertexToTriangleMasks[256][4];
#endif
groupshared uint GroupTriangleCount;
groupshared uint GroupVertexCount;
groupshared uint GroupClusterIndex;

PRIM_SHADER_OUTPUT_TRIANGLES
PRIM_SHADER_PRIM_COUNT(1)
PRIM_SHADER_VERT_COUNT(1)
PRIM_SHADER_VERT_LIMIT(256)
PRIM_SHADER_AMP_FACTOR(128)
PRIM_SHADER_AMP_ENABLE
PrimitiveOutput HWRasterizeVS(PrimitiveInput Input)
{
	const uint LaneIndex = WaveGetLaneIndex();
	const uint LaneCount = WaveGetLaneCount();

	const uint GroupThreadID = LaneIndex + Input.WaveIndex * LaneCount;

	if (GroupThreadID == 0)
	{
		// Input index is only initialized for lane 0, so we need to manually communicate it to all other threads in subgroup (not just wavefront).
		GroupClusterIndex = Input.Index;
	}
	
	GroupMemoryBarrierWithGroupSync();

	uint VisibleIndex = GroupClusterIndex;
#if HAS_PREV_DRAW_DATA
	VisibleIndex += InTotalPrevDrawClusters[0].y;
#endif
#if ADD_CLUSTER_OFFSET
	VisibleIndex += InClusterOffsetSWHW[GetHWClusterCounterIndex(RenderFlags)];
#endif
	VisibleIndex = (MaxVisibleClusters - 1) - VisibleIndex;

	// Should be all scalar.
	FVisibleCluster VisibleCluster = GetVisibleCluster( VisibleIndex, VIRTUAL_TEXTURE_TARGET );
	FInstanceSceneData InstanceData = GetInstanceSceneData( VisibleCluster.InstanceId, false );
	FNaniteView NaniteView = GetNaniteView( VisibleCluster.ViewId );

	FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

	FCluster Cluster = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

#if VERTEX_TO_TRIANGLE_MASKS
	if (GroupThreadID < Cluster.NumVerts)
	{
		GroupVertexToTriangleMasks[GroupThreadID][0] = 0;
		GroupVertexToTriangleMasks[GroupThreadID][1] = 0;
		GroupVertexToTriangleMasks[GroupThreadID][2] = 0;
		GroupVertexToTriangleMasks[GroupThreadID][3] = 0;
	}
#endif

	GroupMemoryBarrierWithGroupSync();

	PrimitiveOutput PrimOutput;
	PrimOutput.VertCount = Cluster.NumVerts;
	PrimOutput.PrimCount = Cluster.NumTris;

	bool bCullTriangle = false;

	if (GroupThreadID < Cluster.NumTris)
	{
		uint TriangleID = GroupThreadID;
		uint3 TriangleIndices = ReadTriangleIndices(Cluster, TriangleID);
		if (ReverseWindingOrder(InstanceData))
		{
			TriangleIndices = uint3(TriangleIndices.x, TriangleIndices.z, TriangleIndices.y);
		}

#if VERTEX_TO_TRIANGLE_MASKS
		const uint DwordIndex   = (GroupThreadID >> 5) & 3;
		const uint TriangleMask = 1 << (GroupThreadID & 31);
		InterlockedOr(GroupVertexToTriangleMasks[TriangleIndices.x][DwordIndex], TriangleMask);
		InterlockedOr(GroupVertexToTriangleMasks[TriangleIndices.y][DwordIndex], TriangleMask);
		InterlockedOr(GroupVertexToTriangleMasks[TriangleIndices.z][DwordIndex], TriangleMask);
#endif
		PrimOutput.PrimExport = PackTriangleExport(TriangleIndices);
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadID < Cluster.NumVerts)
	{
		float4 PointClipNoScaling;
		PrimOutput.Out = CommonRasterizerVS(NaniteView, InstanceData, VisibleCluster, Cluster, GroupThreadID, PointClipNoScaling);
#if VERTEX_TO_TRIANGLE_MASKS
		PrimOutput.Out.PixelValue = ((VisibleIndex + 1) << 7);
		PrimOutput.Out.ToTriangleMasks = uint4(GroupVertexToTriangleMasks[GroupThreadID][0],
											   GroupVertexToTriangleMasks[GroupThreadID][1],
											   GroupVertexToTriangleMasks[GroupThreadID][2],
											   GroupVertexToTriangleMasks[GroupThreadID][3]);
#endif
	}

	return PrimOutput;
}

#elif NANITE_MESH_SHADER

struct PrimitiveAttributes
{
	// Use uint4 to prevent compiler from erroneously packing per-vertex and per-prim attributes together
	// .x = Cluster Index
	// .y = Triangle Index
	// .z = View Width
	// .w = View Height
	nointerpolation uint4 PackedData : TEXCOORD7;
};

#if MESHSHADER

MESH_SHADER_TRIANGLE_ATTRIBUTES(NANITE_MESH_SHADER_TG_SIZE)
void HWRasterizeMS(
	uint GroupThreadID : SV_GroupThreadID,
	uint GroupID : SV_GroupID,
	MESH_SHADER_VERTEX_EXPORT(VSOut, 256),
	MESH_SHADER_TRIANGLE_EXPORT(128),
	MESH_SHADER_PRIMITIVE_EXPORT(PrimitiveAttributes, 128)
)
{
	uint VisibleIndex = GroupID;
#if HAS_PREV_DRAW_DATA
	VisibleIndex += InTotalPrevDrawClusters[0].y;
#endif
#if ADD_CLUSTER_OFFSET
	VisibleIndex += InClusterOffsetSWHW[GetHWClusterCounterIndex(RenderFlags)];
#endif
	VisibleIndex = (MaxVisibleClusters - 1) - VisibleIndex;

	FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleIndex, VIRTUAL_TEXTURE_TARGET);
	FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster.InstanceId, false);

	FNaniteView NaniteView = GetNaniteView(VisibleCluster.ViewId);
	FCluster Cluster = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

	SetMeshOutputCounts(Cluster.NumVerts, Cluster.NumTris);

	if (GroupThreadID < Cluster.NumTris)
	{
		uint TriangleIndex = GroupThreadID;
		uint3 TriangleIndices = ReadTriangleIndices(Cluster, TriangleIndex);
		if (ReverseWindingOrder(InstanceData))
		{
			TriangleIndices = uint3(TriangleIndices.x, TriangleIndices.z, TriangleIndices.y);
		}

		MESH_SHADER_WRITE_TRIANGLE(TriangleIndex, TriangleIndices);

		PrimitiveAttributes Attributes;
		Attributes.PackedData.x = VisibleIndex;
		Attributes.PackedData.y = TriangleIndex;
		Attributes.PackedData.z = asuint(NaniteView.ViewSizeAndInvSize.x);
		Attributes.PackedData.w = asuint(NaniteView.ViewSizeAndInvSize.y);
		MESH_SHADER_WRITE_PRIMITIVE(TriangleIndex, Attributes);
	}

	const uint Vertex0 = GroupThreadID + 0;
	if (Vertex0 < Cluster.NumVerts)
	{
		float4 PointClipNoScaling;
		VSOut VertexOutput = CommonRasterizerVS(NaniteView, InstanceData, VisibleCluster, Cluster, Vertex0, PointClipNoScaling);
		MESH_SHADER_WRITE_VERTEX(Vertex0, VertexOutput);
	}

#if NANITE_MESH_SHADER_TG_SIZE == 128
	const uint Vertex1 = GroupThreadID + 128;
	if (Vertex1 < Cluster.NumVerts)
	{
		float4 PointClipNoScaling;
		VSOut VertexOutput = CommonRasterizerVS(NaniteView, InstanceData, VisibleCluster, Cluster, Vertex1, PointClipNoScaling);
		MESH_SHADER_WRITE_VERTEX(Vertex1, VertexOutput);
	}
#endif
}

#endif // MESHSHADER

#else // NANITE_MESH_SHADER / NANITE_PRIM_SHADER

VSOut HWRasterizeVS(
	uint VertexID		: SV_VertexID,
	uint VisibleIndex	: SV_InstanceID
	)
{
#if HAS_PREV_DRAW_DATA
	VisibleIndex += InTotalPrevDrawClusters[0].y;
#endif

#if ADD_CLUSTER_OFFSET
	VisibleIndex += InClusterOffsetSWHW[GetHWClusterCounterIndex(RenderFlags)];
#endif
	VisibleIndex = (MaxVisibleClusters - 1) - VisibleIndex;

	uint TriIndex = VertexID / 3;
	VertexID = VertexID - TriIndex * 3;

	VSOut Out;
	Out.Position = float4(0,0,0,1);
#if !NEAR_CLIP
	Out.ClipZW = float2(0,0);
#endif

	FVisibleCluster VisibleCluster = GetVisibleCluster( VisibleIndex, VIRTUAL_TEXTURE_TARGET );
	FInstanceSceneData InstanceData = GetInstanceSceneData( VisibleCluster.InstanceId, false );

	FNaniteView NaniteView = GetNaniteView( VisibleCluster.ViewId );
	FCluster Cluster = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

	if( TriIndex < Cluster.NumTris )
	{
		uint3 TriangleIndices = ReadTriangleIndices( Cluster, TriIndex );
		if( ReverseWindingOrder( InstanceData ) )
		{
			TriangleIndices = uint3( TriangleIndices.x, TriangleIndices.z, TriangleIndices.y );
		}

		uint VertIndex = TriangleIndices[ VertexID ];
		float4 PointClipNoScaling;
		Out = CommonRasterizerVS(NaniteView, InstanceData, VisibleCluster, Cluster, VertIndex, PointClipNoScaling);
	#if PIXEL_VALUE
		Out.PixelValue  = ((VisibleIndex + 1) << 7) | TriIndex;
	#endif
	}

	return Out;
}

#endif // NANITE_PRIM_SHADER

#if NANITE_MESH_SHADER
void HWRasterizePS(VSOut In, PrimitiveAttributes Primitive)
#else
void HWRasterizePS(VSOut In)
#endif
{
#if NANITE_MESH_SHADER_INTERP == 1
	float3 InterpPos = In.InterpPosition.xyz / In.InterpPosition.www;
	InterpPos.xy = (InterpPos.xy * float2(0.5f, -0.5f)) + 0.5f;
	InterpPos.xy *= float2(asfloat(Primitive.PackedData.z), asfloat(Primitive.PackedData.w)); // ViewSize
	uint2 PixelPos = (uint2)InterpPos.xy;
#else
	uint2 PixelPos = (uint2)In.Position.xy;
#endif

	uint PixelValue = 0;
#if PIXEL_VALUE
	PixelValue = In.PixelValue;
#endif

#if VERTEX_TO_TRIANGLE_MASKS
	uint4 Masks0 = LoadParameterCacheP0( In.ToTriangleMasks );
	uint4 Masks1 = LoadParameterCacheP1( In.ToTriangleMasks );
	uint4 Masks2 = LoadParameterCacheP2( In.ToTriangleMasks );

	uint4 Masks = Masks0 & Masks1 & Masks2;
	uint TriangleIndex =	Masks.x ? firstbitlow( Masks.x ) :
							Masks.y ? firstbitlow( Masks.y ) + 32 :
							Masks.z ? firstbitlow( Masks.z ) + 64 :
							firstbitlow( Masks.w ) + 96;

	PixelValue += TriangleIndex;
#endif

#if NANITE_MESH_SHADER
	const uint ClusterIndex  = Primitive.PackedData.x;
	const uint TriangleIndex = Primitive.PackedData.y;
	PixelValue = ((ClusterIndex + 1) << 7) | TriangleIndex;
#endif

#if CLUSTER_PER_PAGE
	PixelPos += In.ViewRect.xy;
	if (all(PixelPos < In.ViewRect.zw))
#elif NANITE_MULTI_VIEW
	// In multi-view mode every view has its own scissor, so we have to scissor manually.
	if (all(PixelPos >= In.ViewRect.xy && PixelPos < In.ViewRect.zw))
#endif
	{
	#if NEAR_CLIP
		float DeviceZ = In.Position.z;
	#else
		float DeviceZ = In.ClipZW.x / In.ClipZW.y;
	#endif
		
	#if VIRTUAL_TEXTURE_TARGET
		FPageInfo PageInfo = UnpackPageInfo(In.PackedPageInfo);
		FNaniteView NaniteView = GetNaniteView(PageInfo.ViewId);
		WritePixelPageTranslation PageTranslation = InitializeWritePixelPageTranslation(NaniteView, PageInfo.bStaticPage);
	#else
		WritePixelPageTranslation PageTranslation = InitializeWritePixelPageTranslation();
	#endif

		WritePixel(OutVisBuffer64, PixelValue, PixelPos, DeviceZ, PageTranslation);
	#if VISUALIZE
		WritePixel(OutDbgBuffer64, In.VisualizeValues.x, PixelPos, DeviceZ, PageTranslation);
		InterlockedAdd(OutDbgBuffer32[PixelPos], In.VisualizeValues.y);
	#endif
	}
}
