// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../DeferredShadingCommon.ush"

#include "NaniteDataDecode.ush"

// MATERIAL_CULLING_METHOD 0: no culling
// MATERIAL_CULLING_METHOD 1: cull full screen passes (32bit mask)
// MATERIAL_CULLING_METHOD 2: cull individual tiles   (32bit mask)
// MATERIAL_CULLING_METHOD 3: cull individual tiles   (range load)
// MATERIAL_CULLING_METHOD 4: cull individual tiles   (64bit mask)

Texture2D<UlongType> VisBuffer64;
ByteAddressBuffer MaterialDepthTable;

#if MATERIAL_CULLING_METHOD == 1 || MATERIAL_CULLING_METHOD == 2

RWStructuredBuffer<uint> VisibleMaterials;

// .xy = min, .zw = max
uint4 ViewRect;

[numthreads(8, 8, 1)]
void ClassifyMaterials(uint3 PixelPos : SV_DispatchThreadID)
{
	const UlongType VisPixel = VisBuffer64[PixelPos.xy];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	const bool TileHasNanite = WaveActiveAnyTrue(VisibleClusterIndex != 0xFFFFFFFF);
	if (TileHasNanite)
	{
		float MaterialDepthValue = 0.0f;

		if (VisibleClusterIndex != 0xFFFFFFFF)
		{
			const FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
			const FInstanceSceneData InstanceData = GetInstanceData(VisibleCluster.InstanceId);
			const FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
			const uint MaterialDepthId = GetMaterialDepthId(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialDepthTable);
			MaterialDepthValue = asfloat(MaterialDepthId);
		}

		GroupMemoryBarrierWithGroupSync();

		uint MaterialBucketId = GetMaterialBucketIdFromDepth(MaterialDepthValue);

		uint2 ViewportSize       = ViewRect.zw - ViewRect.xy;
		uint2 MaterialGridSize   = uint2(8, 4); // 32 bits, 1 bit per tile
		float2 MaterialTileSize  = (float2)ViewportSize / (float2)MaterialGridSize;
		uint2 MaterialGridPos    = (uint2)floor((float2)(PixelPos.xy - ViewRect.xy) / MaterialTileSize);
		uint MaterialTileIndex   = MaterialGridPos.x + MaterialGridPos.y * MaterialGridSize.x;
		uint VisibleMaterialMask = 1u << MaterialTileIndex;
		uint ThisLaneIndex       = WaveGetLaneIndex();
		bool bThisLaneActive     = true;
		while (bThisLaneActive)
		{
			if (MaterialBucketId == WaveReadLaneFirst(MaterialBucketId))
			{
				uint ActiveVisibleMaterialMask = WaveActiveBitOr(VisibleMaterialMask);
				if (ThisLaneIndex == WaveGetActiveLaneIndexFirst())
				{
					InterlockedOr(VisibleMaterials[MaterialBucketId], ActiveVisibleMaterialMask);
				}
				bThisLaneActive = false;
			}
		}
	}
}

#elif MATERIAL_CULLING_METHOD == 3 || MATERIAL_CULLING_METHOD == 4

uint2 FetchClamp;
RWTexture2D<uint2> MaterialRange;

groupshared uint2 TileMinMax;

[numthreads(16, 16, 1)]
void ClassifyMaterials(uint3 ThreadIndex : SV_GroupThreadID, uint3 GroupIndex : SV_GroupID)
{
	uint2 PixelPos = ThreadIndex.xy + GroupIndex.xy * 64u;

	if (all(ThreadIndex.xy == 0u))
	{
	#if MATERIAL_CULLING_METHOD == 3
		TileMinMax.x = 0xffffffff;
		TileMinMax.y = 0x0;
	#else
		TileMinMax.x = 0x0;
		TileMinMax.y = 0x0;
	#endif
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint BlockY = 0; BlockY < 64u; BlockY += 16)
	{
		for (uint BlockX = 0; BlockX < 64u; BlockX += 16)
		{
			uint2 FetchPos = PixelPos + uint2(BlockX, BlockY);

			FetchPos = min(FetchPos, FetchClamp);

			UlongType VisPixel = VisBuffer64[FetchPos];

			uint DepthInt = 0;
			uint VisibleClusterIndex = 0;
			uint TriIndex = 0;
			UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

			const bool ValidClusterIndex = (VisibleClusterIndex != 0xFFFFFFFF);
		#if COMPILER_SUPPORTS_WAVE_VOTE
			const bool TileHasNanite = WaveActiveAnyTrue(ValidClusterIndex);
			if (TileHasNanite)
		#endif
			{
				if (ValidClusterIndex)
				{
					FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
					FInstanceSceneData InstanceData = GetInstanceData(VisibleCluster);
					FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
					const uint MaterialDepthId = GetMaterialDepthId(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialDepthTable);

				#if MATERIAL_CULLING_METHOD == 3
					InterlockedMin(TileMinMax.x, MaterialDepthId);
					InterlockedMax(TileMinMax.y, MaterialDepthId);
				#else
					const uint MaterialBucket = GetMaterialBucketIdFromDepth(asfloat(MaterialDepthId));

					uint2 MaterialMask = uint2(0, 0);
					if ((MaterialBucket >> 5u) & 1u)
					{
						MaterialMask.y = 1u << (MaterialBucket & 0x1F);
					}
					else
					{
						MaterialMask.x = 1u << (MaterialBucket & 0x1F);
					}

					InterlockedOr(TileMinMax.x, MaterialMask.x);
					InterlockedOr(TileMinMax.y, MaterialMask.y);
				#endif
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(ThreadIndex.xy == 0u))
	{
		MaterialRange[GroupIndex.xy] = TileMinMax;
	}
}

#endif
