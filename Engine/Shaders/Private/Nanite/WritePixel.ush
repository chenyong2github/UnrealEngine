// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../VirtualShadowMaps/PageAccessCommon.ush"

// Must match ERasterTechnique in NaniteRender.h
#define RASTER_TECHNIQUE_FALLBACK	0
#define RASTER_TECHNIQUE_PLATFORM	1
#define RASTER_TECHNIQUE_NVIDIA		2
#define RASTER_TECHNIQUE_AMD_DX11	3
#define RASTER_TECHNIQUE_AMD_DX12	4
#define RASTER_TECHNIQUE_DEPTHONLY	5

#if RASTER_TECHNIQUE == RASTER_TECHNIQUE_FALLBACK
#define COHERENCY_FLAG globallycoherent
#else
#define COHERENCY_FLAG 
#endif

// When near clipping is disabled we need to move the geometry 
#ifndef NEAR_CLIP
#define NEAR_CLIP 1
#endif

RWTexture2D<uint>						OutDepthBuffer : register(u0);
COHERENCY_FLAG RWTexture2D<UlongType>	OutVisBuffer64 : register(u0);

#if DEBUG_VISUALIZE
COHERENCY_FLAG RWTexture2D<UlongType>	OutDbgBuffer64 : register(u1);
RWTexture2D<uint>						OutDbgBuffer32 : register(u2);
#endif

RWTexture2D<uint> 							LockBuffer : register(u3);

#if RASTER_TECHNIQUE == RASTER_TECHNIQUE_NVIDIA
#define NV_SHADER_EXTN_SLOT u7
#include "/Engine/Shared/ThirdParty/NVIDIA/nvHLSLExtns.h"

#elif RASTER_TECHNIQUE == RASTER_TECHNIQUE_AMD_DX11
#define AmdDxExtShaderIntrinsicsUAVSlot u7
#include "/Engine/Shared/ThirdParty/AMD/ags_shader_intrinsics_dx11.h"

#elif RASTER_TECHNIQUE == RASTER_TECHNIQUE_AMD_DX12
#include "/Engine/Shared/ThirdParty/AMD/ags_shader_intrinsics_dx12.h"
#endif

void WritePixel( RWTexture2D<UlongType> OutBuffer, uint PixelValue, uint2 PixelPos, float DeviceZ, FNaniteView NaniteView, bool bUsePageTable )
{
#if VIRTUAL_TEXTURE_TARGET
	if( bUsePageTable )
	{
		if( !VirtualToPhysicalTexel(NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, PixelPos, PixelPos) )
		{
			// mapped to non-commited space.
			return;
		}
	}
#endif

#if !NEAR_CLIP
	DeviceZ = max(0.0f, DeviceZ);
#endif

	const uint DepthInt = asuint(DeviceZ);

#if RASTER_TECHNIQUE == RASTER_TECHNIQUE_DEPTHONLY
	InterlockedMax( OutDepthBuffer[ PixelPos ], DepthInt );
#else
	const UlongType Pixel = PackUlongType(uint2(PixelValue, DepthInt));

#if RASTER_TECHNIQUE == RASTER_TECHNIQUE_PLATFORM
#if COMPILER_SUPPORTS_UINT64_IMAGE_ATOMICS
	ImageInterlockedMaxUInt64(OutBuffer, PixelPos, Pixel);
#else
	#error UNKNOWN_ATOMIC_PLATFORM
#endif
#elif RASTER_TECHNIQUE == RASTER_TECHNIQUE_NVIDIA
	NvInterlockedMaxUint64(OutBuffer, PixelPos, Pixel); 
#elif RASTER_TECHNIQUE == RASTER_TECHNIQUE_AMD_DX11
	AmdDxExtShaderIntrinsics_AtomicMaxU64(OutBuffer, PixelPos, Pixel);
#elif RASTER_TECHNIQUE == RASTER_TECHNIQUE_AMD_DX12
	AmdExtD3DShaderIntrinsics_AtomicMaxU64(OutBuffer, PixelPos, Pixel);
#else
	// YOLO SYNC: Surprisingly this seems to work in practice (for compute, not pixel). Tested on 2080Ti and 1080.
	uint PrevDepth;
	InterlockedMax(LockBuffer[PixelPos], DepthInt, PrevDepth);
	if (DepthInt > PrevDepth)
	{
		OutBuffer[PixelPos] = Pixel;
	}
#endif
#endif
}