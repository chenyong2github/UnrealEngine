// Copyright Epic Games, Inc. All Rights Reserved.

// Nanite visibility culling

// In Nanite scene traversal, visibility determination and LOD selection all happens on the GPU. At the highest level the goal is to calculate a set of triangle clusters
// that needs to be rasterized based on the Scene and the set of active views.
// (Scene, Views) -> Clusters for rasterization

#include "../Common.ush"
#include "../SceneData.ush"
#include "../WaveOpUtil.ush"
#if VIRTUAL_TEXTURE_TARGET
#include "../VirtualShadowMaps/PageOverlap.ush"

RWStructuredBuffer<uint> OutDynamicCasterFlags;
#endif

#include "NaniteDataDecode.ush"
#include "HZBCull.ush"
#include "Culling.ush"

#ifndef NEAR_CLIP
#define NEAR_CLIP 1
#endif

#ifndef CULLING_PASS
#define CULLING_PASS 0
#endif

#ifndef VIRTUAL_TEXTURE_TARGET
#define VIRTUAL_TEXTURE_TARGET 0
#endif

#ifndef CLUSTER_PER_PAGE
#define CLUSTER_PER_PAGE 0
#endif

#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
static const bool bIsPostPass = true;
static const uint PersistentStateIndex = 1;
groupshared uint3 GroupNodeData[MAX_BVH_NODES_PER_GROUP];
uint4 GetGroupNodeData(uint NodeIndex)				{ return uint4(GroupNodeData[NodeIndex], 0); }
void SetGroupNodeData(uint NodeIndex, uint4 Data)	{ GroupNodeData[NodeIndex] = Data.xyz; }
#else
static const bool bIsPostPass = false;
static const uint PersistentStateIndex = 0;
groupshared uint2 GroupNodeData[MAX_BVH_NODES_PER_GROUP];
uint4 GetGroupNodeData(uint NodeIndex)				{ return uint4(GroupNodeData[NodeIndex], 0, 0); }
void SetGroupNodeData(uint NodeIndex, uint4 Data)	{ GroupNodeData[NodeIndex] = Data.xy; }
#endif

struct FStreamingRequest
{
	uint RuntimeResourceID;
	uint PageIndex;
	uint Priority;
};

ByteAddressBuffer			HierarchyBuffer;
Buffer< uint >				OffsetClustersArgsSWHW;
StructuredBuffer< uint2 >	InTotalPrevDrawClusters;

RWByteAddressBuffer						OutOccludedNodesAndClusters;
RWStructuredBuffer<FStreamingRequest>	OutStreamingRequests;			// First entry holds count

globallycoherent RWCoherentStructuredBuffer(FPersistentState)	MainAndPostPassPersistentStates;
globallycoherent RWCoherentByteAddressBuffer					InOutCandidateNodesAndClusters;

RWByteAddressBuffer			OutVisibleClustersSWHW;
RWBuffer< uint >			VisibleClustersArgsSWHW;

groupshared uint			GroupNumCandidateNodes;
groupshared uint			GroupCandidateNodesOffset;
groupshared uint			GroupOccludedBitmask[MAX_BVH_NODES_PER_GROUP];
groupshared uint2			GroupCandidateData[PERSISTENT_CLUSTER_CULLING_GROUP_SIZE];

groupshared int				GroupNodeCount;
groupshared uint			GroupNodeBatchStartIndex;
groupshared uint			GroupNodeMask;

groupshared uint			GroupClusterBatchStartIndex;
groupshared uint			GroupClusterBatchReadySize;
groupshared uint			GroupClusterMask[2];

#if DEBUG_FLAGS
RWStructuredBuffer<FStats>	OutStatsBuffer;
#endif

float						DisocclusionLodScaleFactor;	// TODO: HACK: Force LOD down first frame an instance is visible to mitigate disocclusion spikes.
uint						LargePageRectThreshold;


// Get the area of an "inclusive" rect (which means that the max is inside the rect), also guards against negative area (where min > max)
uint GetInclusiveRectArea(uint4 Rect)
{
	if (all(Rect.zw >= Rect.xy))
	{
		uint2 Size = Rect.zw - Rect.xy;
		return (Size.x  + 1) * (Size.y + 1);
	}
	return 0;
}

FHierarchyNodeSlice GetHierarchyNodeSlice( uint NodeIndex, uint ChildIndex )
{
	const uint NodeSize = ( 4 + 4 + 4 + 1 ) * 4 * MAX_BVH_NODE_FANOUT;

	uint BaseAddress = NodeIndex * NodeSize;

	FHierarchyNodeSlice Node;
	Node.LODBounds			=	asfloat(	HierarchyBuffer.Load4( BaseAddress + 16 * ChildIndex) );
	
	uint4 Misc0				=	HierarchyBuffer.Load4( BaseAddress + (MAX_BVH_NODE_FANOUT * 16) + 16 * ChildIndex);
	uint4 Misc1				=	HierarchyBuffer.Load4( BaseAddress + (MAX_BVH_NODE_FANOUT * 32) + 16 * ChildIndex);
	uint  Misc2				=	HierarchyBuffer.Load ( BaseAddress + (MAX_BVH_NODE_FANOUT * 48) +  4 * ChildIndex);
	Node.BoxBoundsCenter	=	asfloat( Misc0.xyz );
	Node.BoxBoundsExtent	=	asfloat( Misc1.xyz );

	Node.MinLODError		=	f16tof32( Misc0.w );
	Node.MaxParentLODError	=	f16tof32( Misc0.w >> 16 );
	Node.ChildStartReference=	Misc1.w;
	Node.bLoaded			=	Misc1.w != 0xFFFFFFFFu;

	uint ResourcePageIndex_NumPages_GroupPartSize = Misc2;
	Node.NumChildren		=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_CLUSTERS_PER_GROUP_BITS, 0);
	Node.NumPages			=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_GROUP_PARTS_BITS, MAX_CLUSTERS_PER_GROUP_BITS);
	Node.StartPageIndex		=	BitFieldExtractU32(ResourcePageIndex_NumPages_GroupPartSize, MAX_RESOURCE_PAGES_BITS, MAX_CLUSTERS_PER_GROUP_BITS + MAX_GROUP_PARTS_BITS);
	Node.bEnabled			=	ResourcePageIndex_NumPages_GroupPartSize != 0u;
	Node.bLeaf				=	ResourcePageIndex_NumPages_GroupPartSize != 0xFFFFFFFFu;

	return Node;
}

float2 GetProjectedEdgeScales(FNaniteView NaniteView, FInstanceSceneData InstanceData, FInstanceDynamicData DynamicData, float4 Bounds)	// float2(min, max)
{
	if( NaniteView.ViewToClip[ 3 ][ 3 ] >= 1.0f )
	{
		// Ortho
		return float2( 1, 1 );
	}
	float3 ViewForward = DynamicData.ViewForwardScaledLocal;
	float3 ViewToCluster = Bounds.xyz * InstanceData.NonUniformScale.xyz - DynamicData.ViewPosScaledLocal;
	float Radius = Bounds.w * InstanceData.NonUniformScale.w;

	float ZNear = NaniteView.NearPlane;
	float DistToClusterSq = dot( ViewToCluster, ViewToCluster );
	float DistToCluster = sqrt( DistToClusterSq );
	
	float Z = dot( ViewForward, ViewToCluster );
	float XSq = DistToClusterSq - Z * Z;
	float X = sqrt( max(0.0f, XSq) );
	float DistToTSq = DistToClusterSq - Radius * Radius;
	float DistToT = sqrt( max(0.0f, DistToTSq) );
	float ScaledCosTheta = DistToT;
	float ScaledSinTheta = Radius;
	float ScaleToUnit = rcp( DistToClusterSq );
	float By = (  ScaledSinTheta * X + ScaledCosTheta * Z ) * ScaleToUnit;
	float Ty = ( -ScaledSinTheta * X + ScaledCosTheta * Z ) * ScaleToUnit;
	
	float H = ZNear - Z;
	if( DistToTSq < 0.0f || By * DistToT < ZNear )
	{
		float Bx = max( X - sqrt( Radius * Radius - H * H ), 0.0f );
		By = ZNear * rsqrt( Bx * Bx + ZNear * ZNear );
	}

	if( DistToTSq < 0.0f || Ty * DistToT < ZNear )
	{	
		float Tx = X + sqrt( Radius * Radius - H * H );
		Ty = ZNear * rsqrt( Tx * Tx + ZNear * ZNear );
	}

	float MinZ = max( Z - Radius, ZNear );
	float MaxZ = max( Z + Radius, ZNear );
	float MinCosAngle = Ty;
	float MaxCosAngle = By;

	if(Z + Radius > ZNear)
		return float2( MinZ * MinCosAngle, MaxZ * MaxCosAngle );
	else
		return float2( 0.0f, 0.0f );
}

bool ShouldVisitChild( FNaniteView NaniteView, FInstanceSceneData InstanceData, FInstanceDynamicData DynamicData, float4 LODBounds, float MinLODError, float MaxParentLODError, inout float Priority )
{
	float2 ProjectedEdgeScales = GetProjectedEdgeScales(NaniteView, InstanceData, DynamicData, LODBounds);
	float UniformScale = min3( InstanceData.NonUniformScale.x, InstanceData.NonUniformScale.y, InstanceData.NonUniformScale.z );
	float Threshold = NaniteView.LODScale * UniformScale * MaxParentLODError;
	if( ProjectedEdgeScales.x <= Threshold )
	{
		Priority = Threshold / ProjectedEdgeScales.x;	// TODO: Experiment with better priority
		// return (ProjectedEdgeScales.y >= NaniteView.LODScale * UniformScale * MinLODError); //TODO: Doesn't currently work with streaming. MinLODError needs to also reflect leafness caused by streaming cut.
		return true;
	}
	else
	{
		return false;
	}
}

bool SmallEnoughToDraw( FNaniteView NaniteView, FInstanceSceneData InstanceData, FInstanceDynamicData DynamicData, float4 LODBounds, float LODError, float EdgeLength, inout bool bUseHWRaster )
{
	float ProjectedEdgeScale = GetProjectedEdgeScales( NaniteView, InstanceData, DynamicData, LODBounds ).x;
	float UniformScale = min3( InstanceData.NonUniformScale.x, InstanceData.NonUniformScale.y, InstanceData.NonUniformScale.z );
	bool bVisible = ProjectedEdgeScale > UniformScale * LODError * NaniteView.LODScale;

	if (RenderFlags & RENDER_FLAG_FORCE_HW_RASTER)
	{
		bUseHWRaster = true;
	}
	else
	{
		bUseHWRaster = ProjectedEdgeScale < InstanceData.NonUniformScale.w * abs( EdgeLength ) * NaniteView.LODScaleHW; // TODO: EdgeLength shouldn't have sign
	}

	return bVisible;
}

void RequestPageRange( uint RuntimeResourceID, uint StartPageIndex, uint NumPages, uint PriorityCategory, float Priority )
{
	if ((RenderFlags & RENDER_FLAG_OUTPUT_STREAMING_REQUESTS) && NumPages > 0)
	{
		uint Index;
		WaveInterlockedAddScalar_(OutStreamingRequests[0].RuntimeResourceID, 1, Index);	// HACK: Store count in RuntimeResourceID of first request.
		if( Index < MAX_STREAMING_REQUESTS - 1 )
		{
			FStreamingRequest Request;
			Request.RuntimeResourceID = RuntimeResourceID;
			Request.PageIndex = (StartPageIndex << MAX_GROUP_PARTS_BITS) | NumPages;
			Request.Priority = (PriorityCategory << 30) | (asuint(Priority) >> 2);
			OutStreamingRequests[Index + 1] = Request;
		}
	}
}

void ClusterCull(FVisibleCluster VisibleCluster, uint InstanceId)
{
	FInstanceSceneData InstanceData = GetInstanceData( InstanceId );
	FNaniteView NaniteView = GetNaniteView( VisibleCluster.ViewId );

#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	if (VisibleCluster.Flags & CULLING_FLAG_FROM_DISOCCLUDED_INSTANCE)
		NaniteView.LODScale *= DisocclusionLodScaleFactor;
#endif

	FInstanceDynamicData DynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

	const uint HWClusterCounterIndex = GetHWClusterCounterIndex(RenderFlags);

	// Near depth clipping should only be disabled with orthographic projections
	// WARNING: This is a macro/permutation because of FXC code gen issues! Be careful if you change this to test thoroughly!
	const bool bNearClip = (NEAR_CLIP != 0);
	const bool bViewHZB = ((NaniteView.Flags & VIEW_FLAG_HZBTEST) != 0);

#if DEBUG_FLAGS && COMPILER_PSSL
	const bool bSkipBoxCullFrustum = (DebugFlags & DEBUG_FLAG_CULL_FRUSTUM_BOX) == 0;
	const bool bSkipBoxCullHZB     = (DebugFlags & DEBUG_FLAG_CULL_HZB_BOX) == 0;
#else
	const bool bSkipBoxCullFrustum = false;
	const bool bSkipBoxCullHZB     = false;
#endif

	FCluster Cluster = GetCluster( VisibleCluster.PageIndex, VisibleCluster.ClusterIndex );

	bool bWasOccluded	= false;
	bool bUseHWRaster	= false;
	bool bNeedsClipping = false;
	bool bVisible		= true;

#if VIRTUAL_TEXTURE_TARGET
	// Rect of overlapped virtual pages, is inclusive (as in zw is max, not max + 1)
	uint4 RectPages = PageRectBounds[NaniteView.TargetLayerIndex * VSM_MAX_MIP_LEVELS + NaniteView.TargetMipLevel];
#endif // VIRTUAL_TEXTURE_TARGET

#if CULLING_PASS == CULLING_PASS_NO_OCCLUSION || CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
	BRANCH
	if( bVisible )
	{
		bVisible = SmallEnoughToDraw( NaniteView, InstanceData, DynamicData, Cluster.LODBounds, Cluster.LODError, Cluster.EdgeLength, bUseHWRaster ) || (Cluster.Flags & CLUSTER_FLAG_LEAF);
	}

	BRANCH
	if( bVisible )
	{
		FFrustumCullData Cull = BoxCullFrustum( Cluster.BoxBoundsCenter, Cluster.BoxBoundsExtent, DynamicData.LocalToClip, bNearClip, bSkipBoxCullFrustum );
		FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );

		bVisible = Cull.bIsVisible && ( Rect.bOverlapsPixelCenter || Cull.bCrossesNearPlane );	// Rect from box isn't valid if crossing near plane
		bNeedsClipping = Cull.bCrossesNearPlane || Cull.bCrossesFarPlane;
		bUseHWRaster = bUseHWRaster || bNeedsClipping;

#if VIRTUAL_TEXTURE_TARGET
		BRANCH
		if( bVisible && !Cull.bCrossesNearPlane )
		{
			bVisible = OverlapsAnyValidPage( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, NaniteView.ViewRect.xy, Rect, DynamicData.bHasMoved );

			uint4 ClusterRectPages = uint4( NaniteView.ViewRect.xyxy + Rect.Pixels ) >> VSM_LOG2_PAGE_SIZE;

			// Clip to committed pages pages
			RectPages.xy = max(RectPages.xy, ClusterRectPages.xy);
			RectPages.zw = min(RectPages.zw, ClusterRectPages.zw);
		}
#endif // VIRTUAL_TEXTURE_TARGET
	}

#if VIRTUAL_TEXTURE_TARGET

	// Cull any rect that doesn't overlap any physical pages, note inclusive rect means area of {0,0,0,0} is 1 (not culled)
	uint PageRectArea = GetInclusiveRectArea(RectPages);
	if (PageRectArea == 0)
	{
		bVisible = false;
	}

#if DEBUG_FLAGS
	if (PageRectArea >= LargePageRectThreshold)
	{
		WaveInterlockedAddScalar(OutStatsBuffer[0].NumLargePageRectClusters, 1);
	}
#endif // DEBUG_FLAGS
#endif // VIRTUAL_TEXTURE_TARGET

#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN || VIRTUAL_TEXTURE_TARGET
	BRANCH
	if( bViewHZB && bVisible )
	{
		FFrustumCullData PrevCull = BoxCullFrustum( Cluster.BoxBoundsCenter, Cluster.BoxBoundsExtent, DynamicData.PrevLocalToClip, bNearClip, bSkipBoxCullFrustum );
		
		BRANCH
		if (PrevCull.bIsVisible && !PrevCull.bCrossesNearPlane)
		{
			#if VIRTUAL_TEXTURE_TARGET
				FScreenRect PrevRect = GetScreenRect( NaniteView.ViewRect, PrevCull, 4 );	// Assume HZBTestViewRect=ViewRect for VSM. Don't load it redundantly.
				bVisible = bSkipBoxCullHZB ? true : IsVisibleHZB( NaniteView.TargetPrevLayerIndex, NaniteView.TargetMipLevel, PrevRect );
			#else
				FScreenRect PrevRect = GetScreenRect( NaniteView.HZBTestViewRect, PrevCull, 4 );
				bWasOccluded = bSkipBoxCullHZB ? false : !IsVisibleHZB(PrevRect, true);
			#endif
		}
	}
#endif

#elif CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	BRANCH
	if( ( VisibleCluster.Flags & CULLING_FLAG_TEST_LOD ) != 0 )
	{
		BRANCH
		if( bVisible )
		{
			bVisible = SmallEnoughToDraw(NaniteView, InstanceData, DynamicData, Cluster.LODBounds, Cluster.LODError, Cluster.EdgeLength, bUseHWRaster) || (Cluster.Flags & CLUSTER_FLAG_LEAF);
		}
	}
	else
	{
		bUseHWRaster = ( VisibleCluster.Flags & CULLING_FLAG_USE_HW ) != 0;
	}

	BRANCH
	if( bVisible )
	{
		FFrustumCullData Cull = BoxCullFrustum(Cluster.BoxBoundsCenter, Cluster.BoxBoundsExtent, DynamicData.LocalToClip, bNearClip, bSkipBoxCullFrustum);
		FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );

		bVisible = Cull.bIsVisible && ( Rect.bOverlapsPixelCenter || Cull.bCrossesNearPlane );	// Rect from box isn't valid if crossing near plane
		bNeedsClipping = Cull.bCrossesNearPlane || Cull.bCrossesFarPlane;
		bUseHWRaster = bUseHWRaster || bNeedsClipping;

		BRANCH
		if (bVisible && !Cull.bCrossesNearPlane)
		{
			bVisible = bSkipBoxCullHZB ? true : IsVisibleHZB( Rect, true );
		}
	}
#endif

#if CLUSTER_PER_PAGE
	uint NumClustersToEmit = 0;
	uint PageTableLevelOffset = 0;
	if( bVisible )
	{
		const uint PageFlagMask = DynamicData.bHasMoved ? VSM_ALLOCATED_FLAG : VSM_INVALID_FLAG;

		PageTableLevelOffset = CalcPageTableLevelOffset( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel );

		if( bUseHWRaster )
		{
			// Clip rect to the mapped pages.
			uint4 RectPagesMapped = RectPages.zwxy;
			for( uint y = RectPages.y; y <= RectPages.w; y++ )
			{
				for( uint x = RectPages.x; x <= RectPages.z; x++ )
				{
					uint2 vPage = uint2(x,y);
					uint PageFlag = PageFlags[ PageTableLevelOffset + CalcPageOffsetInLevel( NaniteView.TargetMipLevel, vPage ) ];
					if ((PageFlag & PageFlagMask) != 0)
					{
						RectPagesMapped.xy = min( RectPagesMapped.xy, vPage );
						RectPagesMapped.zw = max( RectPagesMapped.zw, vPage );
					}
				}
			}
			RectPages = RectPagesMapped;

			if( all( RectPages.xy <= RectPages.zw ) )
			{
				uint2 MacroTiles = ( RectPages.zw - RectPages.xy ) / VSM_RASTER_WINDOW_PAGES + 1;
				NumClustersToEmit = MacroTiles.x * MacroTiles.y;
			}
		}
		else
		{
			for( uint y = RectPages.y; y <= RectPages.w; y++ )
			{
				for( uint x = RectPages.x; x <= RectPages.z; x++ )
				{
					uint PageFlag = PageFlags[ PageTableLevelOffset + CalcPageOffsetInLevel( NaniteView.TargetMipLevel, uint2(x,y) ) ];
					NumClustersToEmit += (PageFlag & PageFlagMask) != 0 ? 1 : 0;
				}
			}
		}
	}
#endif

	uint ClusterOffsetHW = 0;
	uint ClusterOffsetSW = 0;
	
	BRANCH
	if( bVisible && !bWasOccluded )
	{
#if CLUSTER_PER_PAGE
		// Need full size counters
		if( bUseHWRaster )
		{
			WaveInterlockedAdd_( VisibleClustersArgsSWHW[ HWClusterCounterIndex ], NumClustersToEmit, ClusterOffsetHW );
		}
		else
		{
			WaveInterlockedAdd_( VisibleClustersArgsSWHW[0], NumClustersToEmit, ClusterOffsetSW );
		}
#else
		if( bUseHWRaster )
		{
			WaveInterlockedAddScalar_( VisibleClustersArgsSWHW[ HWClusterCounterIndex ], 1, ClusterOffsetHW );
		}
		else
		{
			WaveInterlockedAddScalar_( VisibleClustersArgsSWHW[0], 1, ClusterOffsetSW );
		}
#endif
	}

	if( bVisible )
	{
		const uint2 TotalPrevDrawClusters = (RenderFlags & RENDER_FLAG_HAVE_PREV_DRAW_DATA) ? InTotalPrevDrawClusters[0] : 0;

		if( !bWasOccluded )
		{
#if VIRTUAL_TEXTURE_TARGET
			// If the geometry has moved, record this information in a page flag array
			// TODO: also find the previous rect and set that also, to ensure correct invalidation.
			if ( DynamicData.bHasMoved )
			{
				uint PageTableLevelOffset = CalcPageTableLevelOffset(NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel);
				for (uint y = RectPages.y; y <= RectPages.w; y++)
				{
					for (uint x = RectPages.x; x <= RectPages.z; x++)
					{
						uint PageFlagOffset = PageTableLevelOffset + CalcPageOffsetInLevel(NaniteView.TargetMipLevel, uint2(x, y));
						uint PageFlag = PageFlags[PageFlagOffset];

						if (PageFlag != 0)
						{
							OutDynamicCasterFlags[PageFlagOffset] = 1;
						}
					}
				}
			}
#endif // VIRTUAL_TEXTURE_TARGET

#if CLUSTER_PER_PAGE

#if !VIRTUAL_TEXTURE_TARGET
#error "This should always be enabled."
#endif

			uint ClusterIndex;
			if( bUseHWRaster )
				ClusterIndex = MaxVisibleClusters - ClusterOffsetHW - NumClustersToEmit;	// HW clusters written from the top
			else
				ClusterIndex = ClusterOffsetSW;	// SW clusters written from the bottom

			if( bUseHWRaster )
			{
				for( uint y = RectPages.y; y <= RectPages.w; y += VSM_RASTER_WINDOW_PAGES )
				{
					for( uint x = RectPages.x; x <= RectPages.z; x += VSM_RASTER_WINDOW_PAGES )
					{
						VisibleCluster.vPage = uint2(x,y);
						if (ClusterIndex < MaxVisibleClusters)
						{
							StoreVisibleCluster( OutVisibleClustersSWHW, ClusterIndex++, VisibleCluster, VIRTUAL_TEXTURE_TARGET );
						}
					}
				}
			}
			else
			{
				const uint PageFlagMask = DynamicData.bHasMoved ? VSM_ALLOCATED_FLAG : VSM_INVALID_FLAG;
				for( uint y = RectPages.y; y <= RectPages.w; y++ )
				{
					for( uint x = RectPages.x; x <= RectPages.z; x++ )
					{
						uint PageFlag = PageFlags[ PageTableLevelOffset + CalcPageOffsetInLevel( NaniteView.TargetMipLevel, uint2(x,y) ) ];

						if ((PageFlag & PageFlagMask) != 0)
						{
							VisibleCluster.vPage = uint2(x,y);
							if (ClusterIndex < MaxVisibleClusters)
							{
								StoreVisibleCluster( OutVisibleClustersSWHW, ClusterIndex++, VisibleCluster, VIRTUAL_TEXTURE_TARGET );
							}
						}
					}
				}
			}
#else
			if( bUseHWRaster )
			{
				uint VisibleClusterOffsetHW = ClusterOffsetHW;
				VisibleClusterOffsetHW += TotalPrevDrawClusters.y;
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
				VisibleClusterOffsetHW += OffsetClustersArgsSWHW[HWClusterCounterIndex];
#endif
				if( VisibleClusterOffsetHW < MaxVisibleClusters )
				{
					StoreVisibleCluster( OutVisibleClustersSWHW, (MaxVisibleClusters - 1) - VisibleClusterOffsetHW, VisibleCluster, VIRTUAL_TEXTURE_TARGET );	// HW clusters written from the top
				}
			}
			else
			{
				uint VisibleClusterOffsetSW = ClusterOffsetSW;
				VisibleClusterOffsetSW += TotalPrevDrawClusters.x;
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
				VisibleClusterOffsetSW += OffsetClustersArgsSWHW[ 0 ];
#endif
				if( VisibleClusterOffsetSW < MaxVisibleClusters )
				{
					StoreVisibleCluster( OutVisibleClustersSWHW, VisibleClusterOffsetSW, VisibleCluster, VIRTUAL_TEXTURE_TARGET );	// SW clusters written from the bottom
				}
			}
#endif
		}
#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
		else
		{
			uint OccludedClusterOffset = 0;
			WaveInterlockedAddScalar_( MainAndPostPassPersistentStates[1].ClusterWriteOffset, 1, OccludedClusterOffset );

			if( OccludedClusterOffset < MaxCandidateClusters )
			{
				VisibleCluster.Flags = ( bUseHWRaster ? CULLING_FLAG_USE_HW : 0u );
				
				StoreCandidateCluster(OutOccludedNodesAndClusters, OccludedClusterOffset, VisibleCluster);

				DeviceMemoryBarrier();
				uint Bucket = OccludedClusterOffset / PERSISTENT_CLUSTER_CULLING_GROUP_SIZE;
				OutOccludedNodesAndClusters.InterlockedAdd(GetCullingBatchesOffset() + Bucket * 4, 1);
			}
		}
#endif
	}
}

void NodeCull(uint BatchSize, uint GroupIndex)
{
	const uint LocalNodeIndex = (GroupIndex >> MAX_BVH_NODE_FANOUT_BITS);
	const uint ChildIndex = GroupIndex & MAX_BVH_NODE_FANOUT_MASK;
	const uint FetchIndex = min(LocalNodeIndex, BatchSize - 1);

	uint4 NodeData = GetGroupNodeData(FetchIndex);
	
	FCandidateNode CandidateNode = UnpackCandidateNode(NodeData, bIsPostPass);
	uint CandidateNodesOffset = 0;

	FNaniteView NaniteView = GetNaniteView( CandidateNode.ViewId );
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	if (CandidateNode.Flags & CULLING_FLAG_FROM_DISOCCLUDED_INSTANCE)
		NaniteView.LODScale *= DisocclusionLodScaleFactor;
#endif

	FInstanceSceneData InstanceData = GetInstanceData(CandidateNode.InstanceId);
	FInstanceDynamicData DynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);

	// Depth clipping should only be disabled with orthographic projections
	const bool bNearClip = (NEAR_CLIP != 0);
	const bool bViewHZB = ((NaniteView.Flags & VIEW_FLAG_HZBTEST) != 0);

#if DEBUG_FLAGS && COMPILER_PSSL
	const bool bSkipBoxCullFrustum = (DebugFlags & DEBUG_FLAG_CULL_FRUSTUM_BOX) == 0;
	const bool bSkipBoxCullHZB = (DebugFlags & DEBUG_FLAG_CULL_HZB_BOX) == 0;
#else
	const bool bSkipBoxCullFrustum = false;
	const bool bSkipBoxCullHZB = false;
#endif

	const  int HierarchyOffset   = InstanceData.NaniteHierarchyOffset;
	const uint RuntimeResourceID = InstanceData.NaniteRuntimeResourceID;

	const FHierarchyNodeSlice HierarchyNodeSlice = GetHierarchyNodeSlice( HierarchyOffset + CandidateNode.NodeIndex, ChildIndex );

#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	bool bVisible = HierarchyNodeSlice.bEnabled && (CandidateNode.EnabledBitmask & ( 1u << ChildIndex ) ) != 0u;	// Need to check bEnabled because instance cull always writes full mask
#else
	bool bVisible = HierarchyNodeSlice.bEnabled;
#endif
	bool bLoaded = HierarchyNodeSlice.bLoaded;

	if(LocalNodeIndex >= BatchSize)
		bVisible = false;

	bool bWasOccluded = false;
	bool bUseHWRaster = false;
	float StreamingPriority = 0.0f;

	BRANCH
	if (bVisible)
	{
		float4 LODBounds	= HierarchyNodeSlice.LODBounds;

#if CULLING_PASS == CULLING_PASS_NO_OCCLUSION || CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
		bVisible = ShouldVisitChild( NaniteView, InstanceData, DynamicData, LODBounds, HierarchyNodeSlice.MinLODError, HierarchyNodeSlice.MaxParentLODError, StreamingPriority );
		
		BRANCH
		if (bVisible)
		{
			FFrustumCullData Cull = BoxCullFrustum( HierarchyNodeSlice.BoxBoundsCenter, HierarchyNodeSlice.BoxBoundsExtent, DynamicData.LocalToClip, bNearClip, bSkipBoxCullFrustum );
			FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );

			bVisible = Cull.bIsVisible && Rect.bOverlapsPixelCenter;

#if VIRTUAL_TEXTURE_TARGET
			BRANCH
			if( bVisible )
			{
				bVisible = OverlapsAnyValidPage( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, NaniteView.ViewRect.xy, Rect, DynamicData.bHasMoved);
			}
#endif
		}

#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN || VIRTUAL_TEXTURE_TARGET
		BRANCH
		if( bViewHZB && bVisible )
		{
			FFrustumCullData PrevCull = BoxCullFrustum( HierarchyNodeSlice.BoxBoundsCenter, HierarchyNodeSlice.BoxBoundsExtent, DynamicData.PrevLocalToClip, bNearClip, bSkipBoxCullFrustum );
			
			BRANCH
			if( PrevCull.bIsVisible && !PrevCull.bCrossesNearPlane )
			{
				#if VIRTUAL_TEXTURE_TARGET
					FScreenRect PrevRect = GetScreenRect( NaniteView.ViewRect, PrevCull, 4 );		// Assume HZBTestViewRect=ViewRect for VSM. Don't load it redundantly.
					bVisible = bSkipBoxCullHZB ? true : IsVisibleHZB( NaniteView.TargetPrevLayerIndex, NaniteView.TargetMipLevel, PrevRect );
				#else
					FScreenRect PrevRect = GetScreenRect( NaniteView.HZBTestViewRect, PrevCull, 4 );
					bWasOccluded = bSkipBoxCullHZB ? false : !IsVisibleHZB(PrevRect, true);
				#endif
			}
		}
#endif

#elif CULLING_PASS == CULLING_PASS_OCCLUSION_POST
		if (bVisible && (CandidateNode.Flags & CULLING_FLAG_TEST_LOD))
		{
			bVisible = ShouldVisitChild( NaniteView, InstanceData, DynamicData, LODBounds, HierarchyNodeSlice.MinLODError, HierarchyNodeSlice.MaxParentLODError, StreamingPriority );
		}
		
		BRANCH
		if (bVisible)
		{
			FFrustumCullData Cull = BoxCullFrustum( HierarchyNodeSlice.BoxBoundsCenter, HierarchyNodeSlice.BoxBoundsExtent, DynamicData.LocalToClip, bNearClip, bSkipBoxCullFrustum );
			FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );
			Cull.bIsVisible = Cull.bIsVisible && Rect.bOverlapsPixelCenter;
				
			BRANCH
			if (Cull.bIsVisible && !Cull.bCrossesNearPlane)
			{
				bWasOccluded = bSkipBoxCullHZB ? false : !IsVisibleHZB(Rect, true);
			}
		}
#endif
	}

	BRANCH
	if(bVisible)
	{
		BRANCH
		if (!bWasOccluded)
		{
			if(!HierarchyNodeSlice.bLeaf)
			{
				WaveInterlockedAddScalar_( GroupNumCandidateNodes, 1, CandidateNodesOffset );
			}
		}
#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
		else
		{
			if( bLoaded )
			{
				InterlockedOr( GroupOccludedBitmask[ LocalNodeIndex ], 1u << ChildIndex );
			}
		}
#endif
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupIndex == 0)
	{
		InterlockedAdd(MainAndPostPassPersistentStates[PersistentStateIndex].NodeWriteOffset, GroupNumCandidateNodes, GroupCandidateNodesOffset);
		InterlockedAdd(MainAndPostPassPersistentStates[PersistentStateIndex].NodeCount, (int)GroupNumCandidateNodes);	// NodeCount needs to be conservative, so child count is added before the actual children.
	}

	AllMemoryBarrierWithGroupSync();

	// GPU might not be filled, so latency is important here. Kick new jobs as soon as possible.
	bool bOutputChild = bVisible && bLoaded && !bWasOccluded;
	if( bOutputChild && !HierarchyNodeSlice.bLeaf)
	{
		CandidateNodesOffset += GroupCandidateNodesOffset;

		if (CandidateNodesOffset < MaxNodes)
		{
			FCandidateNode Node;
			Node.Flags = CandidateNode.Flags | CULLING_FLAG_TEST_LOD;
			Node.ViewId = CandidateNode.ViewId;
			Node.InstanceId = CandidateNode.InstanceId;
			Node.NodeIndex = HierarchyNodeSlice.ChildStartReference;
			Node.EnabledBitmask = BVH_NODE_ENABLE_MASK;
			StoreCandidateNodeCoherent( InOutCandidateNodesAndClusters, CandidateNodesOffset, Node, bIsPostPass );
		}
	}
	DeviceMemoryBarrierWithGroupSync();

	// Continue with remaining independent work
	if( bOutputChild && HierarchyNodeSlice.bLeaf )
	{
		const uint NumChildren = HierarchyNodeSlice.NumChildren;

		uint CandidateClustersOffset = 0;
		WaveInterlockedAdd_( MainAndPostPassPersistentStates[PersistentStateIndex].ClusterWriteOffset, NumChildren, CandidateClustersOffset );
		
		FVisibleCluster CandidateCluster;
		CandidateCluster.Flags = CandidateNode.Flags | CULLING_FLAG_TEST_LOD;
		CandidateCluster.ViewId = CandidateNode.ViewId;
		CandidateCluster.InstanceId = CandidateNode.InstanceId;
		CandidateCluster.PageIndex = HierarchyNodeSlice.ChildStartReference >> MAX_CLUSTERS_PER_PAGE_BITS;
		const uint BaseClusterIndex = HierarchyNodeSlice.ChildStartReference & MAX_CLUSTERS_PER_PAGE_MASK;
		
		const uint StartIndex = CandidateClustersOffset;
		const uint EndIndex = min(CandidateClustersOffset + NumChildren, MaxCandidateClusters);

		// Clusters in a group are consecutive. Instead of writing them all, we only write
		// the first cluster in each PERSISTENT_CLUSTER_CULLING_GROUP_SIZE-sized batch the group is a part of.
		// The cluster culling can infer the rest using bitscan.
		for (uint Index = StartIndex; Index < EndIndex;)
		{
			CandidateCluster.ClusterIndex = BaseClusterIndex + (Index - StartIndex);
			StoreCandidateClusterCoherent(InOutCandidateNodesAndClusters, Index, CandidateCluster);
			Index = (Index & ~(PERSISTENT_CLUSTER_CULLING_GROUP_SIZE - 1u)) + PERSISTENT_CLUSTER_CULLING_GROUP_SIZE;
		}

		DeviceMemoryBarrier();
		
		// Once the cluster indices have been committed to memory, we can update the cluster counters of the overlapping cluster batches.
		for (uint Index = StartIndex; Index < EndIndex;)
		{
			uint Bucket = Index / PERSISTENT_CLUSTER_CULLING_GROUP_SIZE;
			uint NextIndex = (Index & ~(PERSISTENT_CLUSTER_CULLING_GROUP_SIZE - 1u)) + PERSISTENT_CLUSTER_CULLING_GROUP_SIZE;
			uint MaxIndex = min(NextIndex, EndIndex);
			uint Num = MaxIndex - Index;
			InOutCandidateNodesAndClusters.InterlockedAdd(GetCullingBatchesOffset() + Bucket * 4, Num);
			Index = NextIndex;
		}
	}

	DeviceMemoryBarrierWithGroupSync();
	if (GroupIndex == 0)
	{
		// Done writing clusters/nodes for current pass. Subtract us from NodeCount.
		InterlockedAdd(MainAndPostPassPersistentStates[PersistentStateIndex].NodeCount, -(int)BatchSize);
	}

	if( bVisible && !bWasOccluded && HierarchyNodeSlice.bLeaf )
	{
		RequestPageRange(RuntimeResourceID, HierarchyNodeSlice.StartPageIndex, HierarchyNodeSlice.NumPages, NaniteView.StreamingPriorityCategory, StreamingPriority);
	}

#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
	if( ChildIndex == 0 && GroupOccludedBitmask[LocalNodeIndex] )
	{
		uint OccludedNodesOffset;
		WaveInterlockedAddScalar_( MainAndPostPassPersistentStates[1].NodeWriteOffset, 1, OccludedNodesOffset );
		WaveInterlockedAddScalar( MainAndPostPassPersistentStates[1].NodeCount, 1 );

		if(OccludedNodesOffset < MaxNodes)
		{
			FCandidateNode Node;
			Node.Flags = CandidateNode.Flags & ~CULLING_FLAG_TEST_LOD;
			Node.ViewId = CandidateNode.ViewId;
			Node.InstanceId = CandidateNode.InstanceId;
			Node.NodeIndex = CandidateNode.NodeIndex;
			Node.EnabledBitmask = GroupOccludedBitmask[LocalNodeIndex];
			StoreCandidateNode( OutOccludedNodesAndClusters, OccludedNodesOffset, Node, true );
		}
	}
#endif
}

void ProcessClusterBatch(uint BatchStartIndex, uint BatchSize, uint GroupIndex)
{
	const uint CandidateIndex = BatchStartIndex * PERSISTENT_CLUSTER_CULLING_GROUP_SIZE + GroupIndex;
	const bool bLaneEnabled = (GroupIndex < BatchSize);
	uint2 CandidateRawData = bLaneEnabled ? InOutCandidateNodesAndClusters.Load2(GetCandidateClustersOffset() + CandidateIndex * CandidateClusterSize) : uint2(0xFFFFFFFFu, 0xFFFFFFFFu);
	bool bValid = CandidateRawData.x != 0xFFFFFFFFu;
	GroupCandidateData[GroupIndex] = CandidateRawData;

	if (bValid)
	{
		InterlockedOr(GroupClusterMask[GroupIndex >> 5], 1u << (GroupIndex & 31u));
	}
	GroupMemoryBarrierWithGroupSync();
	uint2 ValidMask = uint2(GroupClusterMask[0], GroupClusterMask[1]);

	// Find our own cluster or the last one written before us.
	// Search for highest 1-bit with index <= GroupIndex in ReadyMask.
	uint FetchIndex = GroupIndex & 32;
	{
		const uint LaneMask = BitFieldMaskU32(GroupIndex & 31u, 1) | 1u;
		uint SearchMask = (FetchIndex ? ValidMask.y : ValidMask.x) & LaneMask;
		if (SearchMask == 0u)
		{
			// Masked high dword of ValidMask was 0. Keep searching in unmasked low dword.
			// Low dword can never be 0.
			SearchMask = ValidMask.x;
			FetchIndex = 0;
		}
		FetchIndex += firstbithigh(SearchMask);
	}

	if (bLaneEnabled)
	{
		FVisibleCluster VisibleCluster = UnpackVisibleCluster(uint4(GroupCandidateData[FetchIndex], 0, 0));
		VisibleCluster.ClusterIndex += GroupIndex - FetchIndex;
		ClusterCull(VisibleCluster, VisibleCluster.InstanceId);
	}

	// Clear processed elements so we leave the buffer cleared for next pass.
	if (bValid)
	{
		ClearCandidateClusterCoherent(InOutCandidateNodesAndClusters, CandidateIndex);
	}
	InOutCandidateNodesAndClusters.Store(GetCullingBatchesOffset() + BatchStartIndex * 4, 0);
}

// Persistent threads culling shader
// This shader is responsible for the recursive culling and traversal of the per-mesh cluster hierarchies.
// It is also responsible for culling the triangle clusters found during this traversal and producing
// lists of visible clusters for rasterization. Clusters are binned for SW or HW rasterization based on
// screen-projected size.

// Mapping tree-culling to the GPU is awkward as the number of leaf nodes that need to be accepted
// is dynamic and can be anywhere from none to hundreds of thousands. Mapping threads 1:1 to trees can result in
// extremely long serial processing that severely underutilizes the GPU. Conversely, mapping threads 1:1 to
// leaf nodes can end up leaving most threads idle.

// What we really need is the ability to dynamically spawn threads for children as they are determined
// to be visible during the traversal. This is unfortunately not possible (yet), so instead we use
// persistent threads. We spawn just enough worker threads to fill the GPU, keep them running and manually
// distribute work to them.

// For this we use a simple MPMC job queue. Instead of spawning new threads, new jobs are added to the queue
// to be consumed by workers. Initially the queue is populated with work generated by preceding shader passes.
// When the persistent shader is running, its workers will continuously consuming items from the queue, but also
// produce new items.

// When BVH nodes are processed they will append work items to the queue for each of the visible children.
// Clusters are only consumed and will never generate new work. The workers keep running until the queue is empty.
// At that point the trees have been recursively traversed and all the relevant clusters have been processed.

// A given node can't be processed before all of its ancestors have been processed. This forms a dependency chain
// of jobs that can be as long as the height of the tree. Especially for small or moderately-sized scenes, the total
// latency from these dependent jobs can end up determining the total BVH processing time, leaving the GPU underutilized.
// This issue is one of the main motivations for handling the cluster culling in the same shader.
// Workers always favor node processing to make progress on the critical path, but when no nodes are available
// they process clusters while waiting, instead of going idle.

[numthreads( PERSISTENT_CLUSTER_CULLING_GROUP_SIZE, 1, 1 )]
void PersistentClusterCull(uint GroupIndex : SV_GroupIndex)  
{
	bool bProcessNodes			= true;						// Should we still try to consume nodes?
	uint NodeBatchReadyOffset	= MAX_BVH_NODES_PER_GROUP;
	uint NodeBatchStartIndex	= 0;
	uint ClusterBatchStartIndex = 0xFFFFFFFFu;
	
	while(true)
	{
		GroupMemoryBarrierWithGroupSync();	// Make sure we are done reading from group shared
		if (GroupIndex == 0)
		{
			GroupNumCandidateNodes	= 0;
			GroupNodeMask			= 0;
			GroupClusterMask[0]		= 0;
			GroupClusterMask[1]		= 0;
		}

#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
		if (GroupIndex < MAX_BVH_NODES_PER_GROUP)
		{
			GroupOccludedBitmask[GroupIndex] = 0u;
		}
#endif
		
		GroupMemoryBarrierWithGroupSync();

		uint NodeReadyMask = 0;
		if (bProcessNodes)	// Try grabbing and processing nodes if they could be available.
		{
			if (NodeBatchReadyOffset == MAX_BVH_NODES_PER_GROUP)
			{
				// No more data in current batch. Grab a new batch.
				if (GroupIndex == 0)
				{
					InterlockedAdd(MainAndPostPassPersistentStates[PersistentStateIndex].NodeReadOffset, MAX_BVH_NODES_PER_GROUP, GroupNodeBatchStartIndex);
				}
				GroupMemoryBarrierWithGroupSync();

				NodeBatchReadyOffset = 0;
				NodeBatchStartIndex = GroupNodeBatchStartIndex;
				if (NodeBatchStartIndex >= MaxNodes)
				{
					// The node range is out of bounds and so will any future range be.
					bProcessNodes = false;
					continue;
				}	
			}

			// Check which nodes in the range have been completely written and are ready for processing.
			const uint NodeIndex = NodeBatchStartIndex + NodeBatchReadyOffset + GroupIndex;
			bool bNodeReady = (NodeBatchReadyOffset + GroupIndex < MAX_BVH_NODES_PER_GROUP);
			if (bNodeReady)
			{
				uint4 NodeData = LoadCandidateNodeDataCoherent(InOutCandidateNodesAndClusters, NodeIndex, bIsPostPass);
				bNodeReady = IsNodeDataReady(NodeData, bIsPostPass);
				if(bNodeReady)
				{
					SetGroupNodeData(GroupIndex, NodeData);
				}
			}

			if (bNodeReady)
			{
				InterlockedOr(GroupNodeMask, 1u << GroupIndex);
			}
			AllMemoryBarrierWithGroupSync();
			NodeReadyMask = GroupNodeMask;

			// Process nodes if at least the first one is ready.
			if (NodeReadyMask & 1u)
			{
				uint BatchSize = firstbitlow(~NodeReadyMask);
				NodeCull(BatchSize, GroupIndex);
				if (GroupIndex < BatchSize)
				{
					ClearCandidateNodeCoherent(InOutCandidateNodesAndClusters, NodeIndex, bIsPostPass);			// Clear processed element so we leave the buffer cleared for next pass.
				}

				NodeBatchReadyOffset += BatchSize;
				continue;
			}
		}

		// No nodes were ready. Process clusters instead.

		// Grab a range of clusters, if we don't already have one.
		if (ClusterBatchStartIndex == 0xFFFFFFFFu)
		{
			if (GroupIndex == 0)
			{
				InterlockedAdd(MainAndPostPassPersistentStates[PersistentStateIndex].ClusterBatchReadOffset, 1, GroupClusterBatchStartIndex);
			}
			GroupMemoryBarrierWithGroupSync();
			ClusterBatchStartIndex = GroupClusterBatchStartIndex;
		}

		if (!bProcessNodes && GroupClusterBatchStartIndex >= GetMaxCandidateClusterBatches())
			break;	// Has to be break instead of return to make FXC happy.

		if (GroupIndex == 0)
		{
			GroupNodeCount = MainAndPostPassPersistentStates[PersistentStateIndex].NodeCount;
			GroupClusterBatchReadySize = InOutCandidateNodesAndClusters.Load(GetCullingBatchesOffset() + ClusterBatchStartIndex * 4);
		}
		GroupMemoryBarrierWithGroupSync();

		uint ClusterBatchReadySize = GroupClusterBatchReadySize;
		if (!bProcessNodes && ClusterBatchReadySize == 0)	// No more clusters to process and no nodes are available to 
			break;	// Has to be break instead of return to make FXC happy.

		if ((bProcessNodes && ClusterBatchReadySize == PERSISTENT_CLUSTER_CULLING_GROUP_SIZE) || (!bProcessNodes && ClusterBatchReadySize > 0))
		{
			ProcessClusterBatch(ClusterBatchStartIndex, ClusterBatchReadySize, GroupIndex);
			ClusterBatchStartIndex = 0xFFFFFFFFu;
		}

		if (bProcessNodes && GroupNodeCount == 0)
		{
			bProcessNodes = false;
		}
	}
}

RWByteAddressBuffer		OutCandidateNodesAndClusters;
uint					InitIsPostPass;

[numthreads(64, 1, 1)]
void InitCandidateClusters(uint GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID)
{
	const uint Index = ((GroupID.y << 8) + GroupID.x) * 64 + GroupIndex;
	if (Index < GetMaxCandidateClusterBatches())
	{
		OutCandidateNodesAndClusters.Store(Index * 4, 0);
	}

	if (Index < MaxCandidateClusters)
	{
		ClearCandidateCluster(OutCandidateNodesAndClusters, Index);
	}
}

[numthreads(64, 1, 1)]
void InitCandidateNodes(uint GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID)
{
	const uint Index = GroupID.x * 64 + GroupIndex;
	ClearCandidateNode(OutCandidateNodesAndClusters, Index, InitIsPostPass != 0);
}

RWBuffer< uint > OutOccludedInstancesArgs;

RWStructuredBuffer<FPersistentState>	OutMainAndPostPassPersistentStates;
RWStructuredBuffer< uint2 >				InOutTotalPrevDrawClusters;
RWBuffer< uint >						InOutMainPassRasterizeArgsSWHW;
RWBuffer< uint >						InOutPostPassRasterizeArgsSWHW;

[numthreads(1, 1, 1)]
void InitArgs()
{
	const uint HWClusterCounterIndex = GetHWClusterCounterIndex(RenderFlags);

	uint2 DrawnClusterCounts = 0;

	for (uint i = 0; i < 2; i++)
	{
		OutMainAndPostPassPersistentStates[i].ClusterBatchReadOffset	= 0;
		OutMainAndPostPassPersistentStates[i].ClusterWriteOffset		= 0;
		OutMainAndPostPassPersistentStates[i].NodeReadOffset			= 0;
		OutMainAndPostPassPersistentStates[i].NodeWriteOffset			= 0;
		OutMainAndPostPassPersistentStates[i].NodeCount					= 0;
	}

	DrawnClusterCounts += uint2(InOutMainPassRasterizeArgsSWHW[0], InOutMainPassRasterizeArgsSWHW[HWClusterCounterIndex]);
	InOutMainPassRasterizeArgsSWHW[ 0 ] = 0;
	InOutMainPassRasterizeArgsSWHW[ 1 ] = 1;
	InOutMainPassRasterizeArgsSWHW[ 2 ] = 1;
	InOutMainPassRasterizeArgsSWHW[ 3 ] = 0;

	if (RenderFlags & RENDER_FLAG_PRIMITIVE_SHADER)
	{
		InOutMainPassRasterizeArgsSWHW[ 4 ] = 0;							// VertexCountPerInstance
		InOutMainPassRasterizeArgsSWHW[ 5 ] = 1;							// InstanceCount
	}
	else
	{
		InOutMainPassRasterizeArgsSWHW[ 4 ] = MAX_CLUSTER_TRIANGLES * 3;	// VertexCountPerInstance
		InOutMainPassRasterizeArgsSWHW[ 5 ] = 0;							// InstanceCount
	}

	InOutMainPassRasterizeArgsSWHW[ 6 ] = 0;
	InOutMainPassRasterizeArgsSWHW[ 7 ] = 0;

#if OCCLUSION_CULLING
	OutOccludedInstancesArgs[0] = 0;
	OutOccludedInstancesArgs[1] = 1;
	OutOccludedInstancesArgs[2] = 1;
	OutOccludedInstancesArgs[3] = 0;

	DrawnClusterCounts += uint2(InOutPostPassRasterizeArgsSWHW[0], InOutPostPassRasterizeArgsSWHW[HWClusterCounterIndex]);
	InOutPostPassRasterizeArgsSWHW[0] = 0;
	InOutPostPassRasterizeArgsSWHW[1] = 1;
	InOutPostPassRasterizeArgsSWHW[2] = 1;
	InOutPostPassRasterizeArgsSWHW[3] = 0;

	if (RenderFlags & RENDER_FLAG_PRIMITIVE_SHADER)
	{
		InOutPostPassRasterizeArgsSWHW[4] = 0;							// VertexCountPerInstance 
		InOutPostPassRasterizeArgsSWHW[5] = 1;							// InstanceCount
	}
	else
	{
		InOutPostPassRasterizeArgsSWHW[4] = MAX_CLUSTER_TRIANGLES * 3;	// VertexCountPerInstance 
		InOutPostPassRasterizeArgsSWHW[5] = 0;							// InstanceCount
	}

	InOutPostPassRasterizeArgsSWHW[6] = 0;								// StartVertexLocation
	InOutPostPassRasterizeArgsSWHW[7] = 0;								// StartInstanceLocation

#endif

#if DRAW_PASS_INDEX == 1
	InOutTotalPrevDrawClusters[ 0 ] = DrawnClusterCounts;
#elif DRAW_PASS_INDEX == 2
	InOutTotalPrevDrawClusters[ 0 ] += DrawnClusterCounts;
#endif
}

[numthreads(1, 1, 1)]
void ClearStreamingRequestCount()
{
	OutStreamingRequests[0].RuntimeResourceID = 0;	// First entry holds count
}