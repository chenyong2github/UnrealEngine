// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../WaveOpUtil.ush"
#include "../VirtualShadowMaps/PageOverlap.ush"

#include "Culling.ush"
#include "NaniteDataDecode.ush"
#include "HZBCull.ush"
#include "WritePixel.ush"
#include "Imposter.ush"

void DrawImposter( FNaniteView NaniteView, FInstanceSceneData InstanceData, uint InstanceId, FScreenRect Rect )
{
	// High bit flags it as an imposter
	uint BaseCode = (1 << 31) | (1 << 7);
	uint RootClusterCode = ( InstanceId << 8 ) | BaseCode;
	uint RootClusterIndex = InstanceData.NaniteRuntimeResourceID & MAX_GPU_PAGES_MASK;

	bool bOrtho = NaniteView.ViewToClip[3][3] >= 1;

	for( int y = Rect.Pixels.y; y <= Rect.Pixels.w; y++ )
	{
		for( int x = Rect.Pixels.x; x <= Rect.Pixels.z; x++ )
		{
			uint2 PixelPos = uint2(x,y);

			// FIXME
			float2 Jitter = NaniteView.ViewToClip[2].xy * 0.5 * NaniteView.ViewSizeAndInvSize.xy;
			int FrameRand = (int)(Jitter.x * 417.0f);

			float2 Noise = Rand3DPCG16( int3( PixelPos, FrameRand ) ).xy / 65535.0;
			float2 PixelClip = ( ( PixelPos + 0.5 ) * NaniteView.ViewSizeAndInvSize.zw - 0.5 ) * float2(2, -2);

			FRay RayWorld;
			if( bOrtho )
			{
				RayWorld.Origin = mul( float4( PixelClip, 1, 1 ), NaniteView.ClipToWorld ).xyz;
				RayWorld.Direction = mul( float4( PixelClip, 0, 1 ), NaniteView.ClipToWorld ).xyz - RayWorld.Origin;
				Noise = 0.5;
			}
			else
			{
				RayWorld.Origin = NaniteView.WorldCameraOrigin.xyz;
				RayWorld.Direction = mul( float4( PixelClip, 0, 1 ), NaniteView.ClipToWorld ).xyz;
			}
	
			FRay RayLocal;
			RayLocal.Origin		= mul( float4( RayWorld.Origin, 1 ),	InstanceData.WorldToLocal ).xyz;
			RayLocal.Direction	= mul( float4( RayWorld.Direction, 0 ),	InstanceData.WorldToLocal ).xyz;

			uint2 ImposterPixel = RayIntersectImposter( RayLocal, RootClusterIndex, InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, Noise );

			if( ImposterPixel.y != 0 )
			{
				float Depth = asfloat( ImposterPixel.y );
				float4 HitClip = mul( float4( 0, 0, Depth, 1 ), NaniteView.ViewToClip );
				float DeviceZ = HitClip.z / HitClip.w;
				
				if( bOrtho )
					DeviceZ = 1 - Depth;

				uint TriIndex = ImposterPixel.x;
				uint PixelValue = RootClusterCode + TriIndex;
				WritePixel( OutVisBuffer64, PixelValue, NaniteView.ViewRect.xy + PixelPos, DeviceZ, NaniteView, false );

				#if 0//VISUALIZE
					WritePixel( OutDbgBuffer64, 0, PixelPos, DeviceZ, NaniteView, false );
					InterlockedAdd(OutDbgBuffer32[ PixelPos ], 1);
				#endif
			}
		}
	}
}

//======================
// Instance culling
//
// Culls instances and outputs list of clusters to further cull.
//======================

uint NumInstances;
uint NumViews;
uint NumPrimaryViews;
int ImposterMaxPixels;
int OnlyCastShadowsPrimitives;

StructuredBuffer<FInstanceDraw>			InInstanceDraws;
Buffer<uint>							InOccludedInstancesArgs;

RWStructuredBuffer<FInstanceDraw>		OutOccludedInstances;
RWBuffer<uint>							OutOccludedInstancesArgs;
RWByteAddressBuffer						OutCandidateNodesAndClusters;
RWStructuredBuffer<FPersistentState>	OutMainAndPostPassPersistentStates;

#if DEBUG_FLAGS
RWStructuredBuffer<FStats>				OutStatsBuffer;
#endif

[numthreads(64, 1, 1)]
void InstanceCull(
	uint DispatchIndex : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex)
{
#if DEBUG_FLAGS && CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	if (DebugFlags & DEBUG_FLAG_WRITE_STATS && DispatchIndex == 0)
	{
		OutStatsBuffer[0].NumPostInstancesPreCull = InOccludedInstancesArgs[3];
	}
#endif

	const bool bIsPostPass = (CULLING_PASS == CULLING_PASS_OCCLUSION_POST);

#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
	uint NumInstancesLocal = InOccludedInstancesArgs[3];
#else
	uint NumInstancesLocal = NumInstances;
#endif

	if (DispatchIndex < NumInstancesLocal)
	{
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST || CULLING_PASS == CULLING_PASS_EXPLICIT_LIST
		uint InstanceId = InInstanceDraws[DispatchIndex].InstanceId;
#else
		uint InstanceId = DispatchIndex;
#endif
		FInstanceSceneData InstanceData = GetInstanceData(InstanceId);
		const uint RuntimeResourceID = InstanceData.NaniteRuntimeResourceID;

		BRANCH
		if (!InstanceData.ValidInstance || RuntimeResourceID == 0xFFFFFFFFu)
		{
			// Only process valid Nanite instances
			return;
		}

		FPrimitiveSceneData PrimitiveData = GetPrimitiveData(InstanceData.PrimitiveId);
		const bool bCastShadows = (PrimitiveData.Flags & 1u) != 0u;

		// JonO/Note: Depth-Only pass indicates its a shadow map... but this may not technically always be the case?
		//if(OnlyCastShadowsPrimitives && !InstanceData.CastShadows) 

		BRANCH
		if (OnlyCastShadowsPrimitives && !bCastShadows) 
		{
			return;
		}

		uint ViewId = 0;
#if NANITE_MULTI_VIEW
	#if CULLING_PASS == CULLING_PASS_NO_OCCLUSION || CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
		for (ViewId = 0; ViewId < NumViews; ++ViewId)
	#else
		ViewId = InInstanceDraws[DispatchIndex].ViewId;
	#endif
#endif
		{
			bool bIsVisible = false;
			bool bWasOccluded = false;

			FNaniteView NaniteView = GetNaniteView(ViewId);

			// Depth clipping should only be disabled with orthographic projections
			const bool bNearClip = (NEAR_CLIP != 0);

#if DEBUG_FLAGS && COMPILER_PSSL
			const bool bSkipBoxCullFrustum = (DebugFlags & DEBUG_FLAG_CULL_FRUSTUM_BOX) == 0;
			const bool bSkipBoxCullHZB     = (DebugFlags & DEBUG_FLAG_CULL_HZB_BOX) == 0;
#else
			const bool bSkipBoxCullFrustum = false;
			const bool bSkipBoxCullHZB     = false;
#endif

			float4x4 LocalToTranslatedWorld = InstanceData.LocalToWorld;
			LocalToTranslatedWorld[3].xyz += NaniteView.PreViewTranslation.xyz;
			float4x4 LocalToClip = mul( LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip );

			float BoundsRadiusSq = dot(InstanceData.LocalBoundsExtent, InstanceData.LocalBoundsExtent);
			bIsVisible = BoundsRadiusSq > NaniteView.MinBoundsRadiusSq; // Only process valid Nanite primitives
			const bool bViewHZB = ((NaniteView.Flags & VIEW_FLAG_HZBTEST) != 0);

			FFrustumCullData Cull;
#if CULLING_PASS == CULLING_PASS_NO_OCCLUSION || CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
			// Frustum test against current frame
			BRANCH
			if( bIsVisible )
			{
				Cull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, bSkipBoxCullFrustum);
				bIsVisible = Cull.bIsVisible;
			}
#endif

#if CULLING_PASS == CULLING_PASS_OCCLUSION_MAIN
			// HZB occlusion test against previous frame
			BRANCH
			if( bViewHZB && bIsVisible )
			{
				float4x4 LocalToPrevTranslatedWorld = InstanceData.LocalToWorld;
				LocalToPrevTranslatedWorld[ 3 ].xyz += NaniteView.PrevPreViewTranslation.xyz;
				float4x4 LocalToPrevClip = mul(LocalToPrevTranslatedWorld, NaniteView.PrevTranslatedWorldToClip);

				FFrustumCullData PrevCull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToPrevClip, bNearClip, bSkipBoxCullFrustum);
				
				BRANCH
				if ((PrevCull.bIsVisible || PrevCull.bFrustumSideCulled) && !PrevCull.bCrossesNearPlane)
				{
					FScreenRect PrevRect = GetScreenRect( NaniteView.HZBTestViewRect, PrevCull, 4 );
					bWasOccluded = bSkipBoxCullHZB ? false : !IsVisibleHZB( PrevRect, true );
				}

				if( bWasOccluded )
				{
					uint OccludedInstanceOffset = 0;
					WaveInterlockedAddScalarInGroups( OutOccludedInstancesArgs[3], OutOccludedInstancesArgs[0], 64, 1, OccludedInstanceOffset );
					OutOccludedInstances[OccludedInstanceOffset].ViewId = ViewId;
					OutOccludedInstances[OccludedInstanceOffset].InstanceId = InstanceId;
				}
			}
#endif

#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
			// Retest occluded against current frame HZB
			BRANCH
			if( bIsVisible )
			{
				Cull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, bSkipBoxCullFrustum);

				BRANCH
				if (Cull.bIsVisible && !Cull.bCrossesNearPlane)
				{
					FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );
					bWasOccluded = bSkipBoxCullHZB ? false : !IsVisibleHZB( Rect, true );
				}
			}
#endif

#if CULLING_PASS != CULLING_PASS_EXPLICIT_LIST
			// Draw imposters
			if( InstanceData.NaniteHasImposter && bIsVisible && !bWasOccluded )
			{
				FScreenRect Rect = GetScreenRect( NaniteView.ViewRect, Cull, 4 );

				if( all( Rect.Pixels.zw - Rect.Pixels.xy <= ImposterMaxPixels ) )
				{
					DrawImposter( NaniteView, InstanceData, InstanceId, Rect );
					bIsVisible = false;
				}
			}
#endif
		
			if( bIsVisible && !bWasOccluded )
			{
				uint NodeOffset = 0;
				uint PersistentStateIndex = ( CULLING_PASS == CULLING_PASS_OCCLUSION_POST );
				WaveInterlockedAddScalar_( OutMainAndPostPassPersistentStates[ PersistentStateIndex ].NodeWriteOffset, 1, NodeOffset );
				WaveInterlockedAddScalar(  OutMainAndPostPassPersistentStates[ PersistentStateIndex ].NodeCount, 1 );

#if DEBUG_FLAGS
				if (DebugFlags & DEBUG_FLAG_WRITE_STATS)
				{
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
					WaveInterlockedAddScalar( OutStatsBuffer[0].NumPostInstancesPostCull, 1 );
#else
					WaveInterlockedAddScalar( OutStatsBuffer[0].NumMainInstancesPostCull, 1 );
#endif
				}
#endif

				if(NodeOffset < MaxNodes)
				{
					uint Flags = CULLING_FLAG_TEST_LOD;
#if CULLING_PASS == CULLING_PASS_OCCLUSION_POST
					Flags |= CULLING_FLAG_FROM_DISOCCLUDED_INSTANCE;
#endif
		
					FCandidateNode Node;
					Node.Flags = Flags;
					Node.ViewId = ViewId;
					Node.InstanceId = InstanceId;
					Node.NodeIndex = 0;
					Node.EnabledBitmask = BVH_NODE_ENABLE_MASK;
					StoreCandidateNode( OutCandidateNodesAndClusters, NodeOffset, Node, bIsPostPass );
				}
			}
		}
	}
}

struct FCompactedViewInfo
{
	uint StartOffset;
	uint NumValidViews;
};

RWStructuredBuffer< FPackedNaniteView > CompactedViewsOut;
RWStructuredBuffer< FCompactedViewInfo > CompactedViewInfoOut;
RWStructuredBuffer< uint > CompactedViewsAllocationOut;


[numthreads(64, 1, 1)]
void CompactViewsVSM_CS(uint PrimaryViewId : SV_DispatchThreadID)
{
	if (PrimaryViewId >= NumPrimaryViews)
	{
		return;
	}

	FNaniteView PrimaryNaniteView = GetNaniteView(PrimaryViewId);
	uint NumValidViews = 0U;
	{
		for (uint TargetMipLevel = 0; TargetMipLevel < (uint)PrimaryNaniteView.TargetNumMipLevels; TargetMipLevel++)
		{
			uint MipViewId = TargetMipLevel * NumPrimaryViews + PrimaryViewId;
			FNaniteView MipView = GetNaniteView(MipViewId);

			uint4 RectPages = PageRectBounds[MipView.TargetLayerIndex * VSM_MAX_MIP_LEVELS + MipView.TargetMipLevel];

			// Always keep the primary view
			if (all(RectPages.zw >= RectPages.xy))
			{
				NumValidViews += 1U;
			}
		}
	}

	// Neither primary nor mip views have valid pages
	if (NumValidViews == 0U)
	{
		return;
	}

	uint CompactedOutputOffset = 0;
	InterlockedAdd(CompactedViewsAllocationOut[1], NumValidViews, CompactedOutputOffset);

	FCompactedViewInfo CompactedViewInfo;
	CompactedViewInfo.StartOffset = CompactedOutputOffset;
	CompactedViewInfo.NumValidViews = NumValidViews;

	uint InfoOutputOffset = 0;
	InterlockedAdd(CompactedViewsAllocationOut[0], 1, InfoOutputOffset);
	CompactedViewInfoOut[InfoOutputOffset] = CompactedViewInfo;

	for (uint TargetMipLevel = 0; TargetMipLevel < (uint)PrimaryNaniteView.TargetNumMipLevels; TargetMipLevel++)
	{
		uint MipViewId = TargetMipLevel * NumPrimaryViews + PrimaryViewId;
		FNaniteView MipView = GetNaniteView(MipViewId);

		uint4 RectPages = PageRectBounds[MipView.TargetLayerIndex * VSM_MAX_MIP_LEVELS + MipView.TargetMipLevel];

		if (all(RectPages.zw >= RectPages.xy))
		{
			CompactedViewsOut[CompactedOutputOffset] = InViews[MipViewId];
			CompactedOutputOffset += 1U;
		}
	}
}


StructuredBuffer< FCompactedViewInfo > CompactedViewInfo;
StructuredBuffer< uint > CompactedViewsAllocation;

[numthreads(64, 1, 1)]
void InstanceCullVSM(
	uint DispatchIndex : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex)
{
	// Depth clipping should only be disabled with orthographic projections
	const bool bNearClip = ( NEAR_CLIP != 0 );

#if DEBUG_FLAGS && COMPILER_PSSL
	const bool bSkipBoxCullFrustum = (DebugFlags & DEBUG_FLAG_CULL_FRUSTUM_BOX) == 0;
	const bool bSkipBoxCullHZB     = (DebugFlags & DEBUG_FLAG_CULL_HZB_BOX) == 0;
#else
	const bool bSkipBoxCullFrustum = false;
	const bool bSkipBoxCullHZB     = false;
#endif

	const uint InstanceId = DispatchIndex;

	BRANCH
	if (InstanceId >= NumInstances)
	{
		return;
	}

	FInstanceSceneData InstanceData = GetInstanceData(InstanceId);
	const uint RuntimeResourceID = InstanceData.NaniteRuntimeResourceID;

	BRANCH
	if (!InstanceData.ValidInstance || RuntimeResourceID == 0xFFFFFFFFu)  //if(!InstanceData.CastShadows) 
	{
		// Only process valid Nanite instances
		return;
	}

	FPrimitiveSceneData PrimitiveData = GetPrimitiveData(InstanceData.PrimitiveId);
	bool bCastShadow = (PrimitiveData.Flags & 1u) != 0u;
	
	BRANCH
	if (!bCastShadow) 
	{
		return;
	}

	const bool bHasMoved = GetGPUSceneFrameNumber() == InstanceData.LastUpdateSceneFrameNumber;

	// Loop over each of the views
#if USE_COMPACTED_VIEWS
	uint NumCompactedPrimaryViews = CompactedViewsAllocation[0];
	for (uint CompactedViewInfoIndex = 0; CompactedViewInfoIndex < NumCompactedPrimaryViews; ++CompactedViewInfoIndex)
	{
		FCompactedViewInfo ViewInfo = CompactedViewInfo[CompactedViewInfoIndex];
		uint PrimaryViewId = ViewInfo.StartOffset;
#else // USE_COMPACTED_VIEWS
	for (uint PrimaryViewId = 0; PrimaryViewId < NumPrimaryViews; ++PrimaryViewId)
	{
#endif // USE_COMPACTED_VIEWS
		uint VisibleMipsMask = 0U;

		{
			FNaniteView NaniteView = GetNaniteView( PrimaryViewId );
			// NOTE: With view compaction, the "primary view" may be any of the mip levels
			// const uint2 TargetViewSize = uint2( NaniteView.ViewSizeAndInvSize.xy );
			
			float4x4 LocalToTranslatedWorld = InstanceData.LocalToWorld;
			LocalToTranslatedWorld[ 3 ].xyz += NaniteView.PreViewTranslation.xyz;
			float4x4 LocalToClip = mul( LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip );

			FFrustumCullData Cull = BoxCullFrustum( InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, bSkipBoxCullFrustum );

			const bool bViewHZB = ((NaniteView.Flags & VIEW_FLAG_HZBTEST) != 0);
			
#if USE_COMPACTED_VIEWS
			for (uint MipViewInfoIndex = 0; MipViewInfoIndex < ViewInfo.NumValidViews; ++MipViewInfoIndex)
			{
				uint MipViewId = ViewInfo.StartOffset + MipViewInfoIndex;
#else // USE_COMPACTED_VIEWS
			for(uint TargetMipLevel = 0; TargetMipLevel < (uint)NaniteView.TargetNumMipLevels; TargetMipLevel++)
			{
				uint MipViewId = TargetMipLevel * NumPrimaryViews + PrimaryViewId;
#endif // USE_COMPACTED_VIEWS
				FNaniteView MipView = GetNaniteView(MipViewId);
				float2 ViewSize = MipView.ViewSizeAndInvSize.xy;

				// TODO: minor optimization possible, but need to duplicate setup from CullRasterize for virtual targets
				//float2 ViewSize = float2( ( TargetViewSize + ( 1u << TargetMipLevel ) - 1u ) >> TargetMipLevel );

				FScreenRect Rect = GetScreenRect(MipView.ViewRect, Cull, 4 );

				bool bVisible = Cull.bIsVisible && Rect.bOverlapsPixelCenter;
		
				BRANCH
				if( bVisible && !Cull.bCrossesNearPlane )
				{
					bVisible = OverlapsAnyValidPage(MipView.TargetLayerIndex, MipView.TargetMipLevel, MipView.ViewRect.xy, Rect, bHasMoved );
				}

				BRANCH
				if( bViewHZB && bVisible )
				{
					float4x4 LocalToPrevTranslatedWorld = InstanceData.LocalToWorld;
					LocalToPrevTranslatedWorld[ 3 ].xyz += MipView.PrevPreViewTranslation.xyz;
					float4x4 LocalToPrevClip = mul(LocalToPrevTranslatedWorld, MipView.PrevTranslatedWorldToClip);

					FFrustumCullData PrevCull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToPrevClip, bNearClip, bSkipBoxCullFrustum);
				
					BRANCH
					if( PrevCull.bIsVisible && !PrevCull.bCrossesNearPlane )
					{
						FScreenRect PrevRect = GetScreenRect(MipView.ViewRect, PrevCull, 4 );	// Assume HZBTestViewRect=ViewRect for VSM. Don't load it redundantly.
						bVisible = bSkipBoxCullHZB ? true : IsVisibleHZB(MipView.TargetPrevLayerIndex, MipView.TargetMipLevel, PrevRect );
					}
				}

				if( bVisible )
				{
#if USE_COMPACTED_VIEWS
					VisibleMipsMask |= ( 1u << MipViewInfoIndex);
#else // USE_COMPACTED_VIEWS
					VisibleMipsMask |= ( 1u << TargetMipLevel );
#endif // USE_COMPACTED_VIEWS
				}
			}
		}

		uint NodeOffset = 0;

		BRANCH
		if( VisibleMipsMask )
		{
			uint NumNodes = countbits( VisibleMipsMask );
			WaveInterlockedAdd_( OutMainAndPostPassPersistentStates[0].NodeWriteOffset, NumNodes, NodeOffset );
			WaveInterlockedAdd(  OutMainAndPostPassPersistentStates[0].NodeCount, NumNodes );

	#if DEBUG_FLAGS
			if (DebugFlags & DEBUG_FLAG_WRITE_STATS)
			{
				WaveInterlockedAdd(OutStatsBuffer[0].NumMainInstancesPostCull, NumNodes);
			}
	#endif
		}

		// Output visible nodes. Get compaction for free by only looping over set bits in VisibleMipsMask.
		// Iteration count is equal to the maximum lane output count.
		while( VisibleMipsMask && NodeOffset < MaxNodes)
		{
#if USE_COMPACTED_VIEWS
			uint MipViewInfoIndex = firstbitlow( VisibleMipsMask );	// Jump to next set bit.
			uint MipViewId = ViewInfo.StartOffset + MipViewInfoIndex;
#else // !USE_COMPACTED_VIEWS
			uint TargetMipLevel = firstbitlow( VisibleMipsMask );	// Jump to next set bit.
			uint MipViewId = TargetMipLevel * NumPrimaryViews + PrimaryViewId;
#endif // USE_COMPACTED_VIEWS
			VisibleMipsMask &= VisibleMipsMask - 1u;				// Remove bottom bit.


			FCandidateNode Node;
			Node.Flags = CULLING_FLAG_TEST_LOD;
			Node.ViewId = MipViewId;
			Node.InstanceId = InstanceId;
			Node.NodeIndex = 0;
			Node.EnabledBitmask = BVH_NODE_ENABLE_MASK;
			StoreCandidateNode( OutCandidateNodesAndClusters, NodeOffset, Node, false );
			NodeOffset++;
		}
	}
}
