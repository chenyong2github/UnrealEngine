// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../VertexFactoryCommon.ush"
#include "../LightmapData.ush"
#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

struct FVertexFactoryInterpolantsVSToPS
{
#if NEEDS_LIGHTMAP_COORDINATE
	nointerpolation float4 LightMapCoordinate : TEXCOORD3;
#endif
#if VF_USE_PRIMITIVE_SCENE_DATA && NEEDS_LIGHTMAP_COORDINATE
	nointerpolation uint LightmapDataIndex : LIGHTMAP_ID;
#endif
#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

#if NEEDS_LIGHTMAP_COORDINATE

void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1, out uint LightmapDataIndex)
{
	LightmapUV0 = Interpolants.LightMapCoordinate.xy * float2(1.0, 0.5);
	LightmapUV1 = LightmapUV0 + float2(0.0, 0.5);

#if VF_USE_PRIMITIVE_SCENE_DATA
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
}

void GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 ShadowMapCoordinate, out uint LightmapDataIndex)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
	ShadowMapCoordinate = Interpolants.LightMapCoordinate.zw;
}

void SetLightMapCoordinate(inout FVertexFactoryInterpolantsVSToPS Interpolants, float2 InLightMapCoordinate, float2 InShadowMapCoordinate)
{
	Interpolants.LightMapCoordinate.xy = InLightMapCoordinate;
	Interpolants.LightMapCoordinate.zw = InShadowMapCoordinate;
}

void SetLightMapDataIndex(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint LightmapDataIndex)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	Interpolants.LightmapDataIndex = LightmapDataIndex;
#endif
}

#endif // NEEDS_LIGHTMAP_COORDINATE

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	FMaterialPixelParameters Result = (FMaterialPixelParameters)0;

	const uint2 PixelPos = SvPosition.xy - float2(0.5f, 0.5f);
	const UlongType Pixel = Nanite.VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(Pixel, DepthInt, VisibleClusterIndex, TriIndex);

	const FNaniteView NaniteView = GetNaniteView(0);
	
	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster           = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData          = GetInstanceData(VisibleCluster);
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);
		FPrimitiveSceneData PrimitiveData        = GetPrimitiveData(InstanceData.PrimitiveId);
		FCluster Cluster                         = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

		const uint3 TriIndices = ReadTriangleIndices(Cluster, TriIndex);

		const float3 PointLocal0 = DecodePosition(TriIndices.x, Cluster);
		const float3 PointLocal1 = DecodePosition(TriIndices.y, Cluster);
		const float3 PointLocal2 = DecodePosition(TriIndices.z, Cluster);

		const float4 PointClip0 = mul(float4(PointLocal0, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip1 = mul(float4(PointLocal1, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip2 = mul(float4(PointLocal2, 1), InstanceDynamicData.LocalToClip);

		const float2 PixelClip = (SvPosition.xy - View.ViewRectMin.xy) * View.ViewSizeAndInvSize.zw * float2(2, -2) + float2(-1, 1);

		// Calculate perspective correct barycentric coordinates with screen derivatives
		const FBarycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2);

	#if NEEDS_LIGHTMAP_COORDINATE
		// Materials without any texture coordinates referenced will
		// set NUM_TEX_COORD_INTERPOLATORS to 0 which will cause GetAttributeData
		// to skip loading any texture coordinates from Nanite data, including light
		// map UVs. In this case we cannot use the literal constant and must use the
		// count stored on the cluster data.
		const uint NumTexCoords = Cluster.NumUVs;
	#else
		// Prefer literal constant to optimize shader codegen.
		const uint NumTexCoords = NUM_TEX_COORD_INTERPOLATORS;
	#endif

		const FNaniteAttributeData AttributeData = GetAttributeData(
			Cluster,
			TriIndices,
			PointLocal0,
			PointLocal1,
			PointLocal2,
			Barycentrics,
			InstanceData,
			NumTexCoords
		);

	#if INTERPOLATE_VERTEX_COLOR
		Result.VertexColor = AttributeData.VertexColor;
	#else
		// Coerce compiler into DCE as much code as possible.
		Result.VertexColor = float4(1, 1, 1, 1);
	#endif

		Result.TangentToWorld = AttributeData.TangentToWorld;
		Result.UnMirrored = AttributeData.UnMirrored;

	#if NUM_TEX_COORD_INTERPOLATORS > 0
		UNROLL
		for (uint TexCoordIndex = 0; TexCoordIndex < NUM_TEX_COORD_INTERPOLATORS; TexCoordIndex++)
		{
			// Protect against case where Nanite max UV count is lower than what the material may define.
			Result.TexCoords[TexCoordIndex] = (TexCoordIndex < MAX_NANITE_UVS) ? AttributeData.TexCoords[TexCoordIndex] : float2(0.0f, 0.0f);
		}
	#endif

		const float3 PointLocal = Barycentrics.UVW.x * PointLocal0 + Barycentrics.UVW.y * PointLocal1 + Barycentrics.UVW.z * PointLocal2;

		Result.PrevScreenPosition = mul( float4(PointLocal, 1), InstanceDynamicData.PrevLocalToClip );
		//Result.PrevScreenPosition = float4( Result.PrevScreenPosition.xyz / Result.PrevScreenPosition.w, 1 );

		// Update to real depth from VisBuffer
		SvPosition.z = asfloat(DepthInt);

	#if USE_PARTICLE_SUBUVS && NUM_TEX_COORD_INTERPOLATORS > 0
		// Output TexCoord0 for when previewing materials that use ParticleSubUV.
		Result.Particle.SubUVCoords[0] = Result.TexCoords[0];
		Result.Particle.SubUVCoords[1] = Result.TexCoords[0];
	#endif

		// Required for previewing materials that use ParticleColor
		Result.Particle.Color = half4(1, 1, 1, 1);

		// X = per-instance random, Y = per-instance fade out amount, Z = hide/show flag, W = dither fade cutoff
		Result.PerInstanceParams = float4(InstanceData.PerInstanceRandom, 0.0f, 0.0f, 0.0f);

	#if NEEDS_LIGHTMAP_COORDINATE
		float2 LightMapCoordinate = 0;
		float2 ShadowMapCoordinate = 0;

		const uint LightMapDataIndex = PrimitiveData.LightmapDataIndex;
		const uint LightMapUVIndex   = PrimitiveData.LightmapUVIndex;
		//UnpackLightmapDataAndUVIndex(PrimitiveData.LightmapDataAndUVIndex, LightmapDataIndex, LightmapUVIndex);

		float2 LightMapCoordinateInput = AttributeData.TexCoords[LightMapUVIndex];
		const float2 LightMapUVs = LightMapCoordinateInput;

		const float4 LightMapCoordinateScaleBias = GetLightmapData(LightMapDataIndex).LightMapCoordinateScaleBias;
		if (PrimitiveData.NumInstanceDataEntries > 1)
		{
			LightMapCoordinate = LightMapCoordinateInput * LightMapCoordinateScaleBias.xy + InstanceData.LightMapAndShadowMapUVBias.xy;
		}
		else
		{
			LightMapCoordinate = LightMapCoordinateInput * LightMapCoordinateScaleBias.xy + LightMapCoordinateScaleBias.zw;
		}

	#if STATICLIGHTING_TEXTUREMASK
		const float4 ShadowMapCoordinateScaleBias = GetLightmapData(LightMapDataIndex).ShadowMapCoordinateScaleBias;
		if (PrimitiveData.NumInstanceDataEntries > 1)
		{
			ShadowMapCoordinate = LightMapCoordinateInput * ShadowMapCoordinateScaleBias.xy + InstanceData.LightMapAndShadowMapUVBias.zw;
		}
		else
		{
			ShadowMapCoordinate = LightMapCoordinateInput * ShadowMapCoordinateScaleBias.xy + ShadowMapCoordinateScaleBias.zw;
		}
	#endif

		SetLightMapCoordinate(Interpolants, LightMapCoordinate, ShadowMapCoordinate);
		SetLightMapDataIndex(Interpolants, LightMapDataIndex);
	#else
		const float2 LightMapUVs = float2(0.0f, 0.0f);
	#endif

	#if LIGHTMAP_UV_ACCESS
		// Store unscaled/unbiased lightmap UVs
		Result.LightmapUVs = LightMapUVs;
	#endif

		Result.TwoSidedSign = 1;
		Result.PrimitiveId = InstanceData.PrimitiveId;
	}

	return Result;
}

struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

float2 VertexFactoryGetTextureCoordinateDS( FVertexFactoryInterpolantsVSToDS Interpolants )
{
	return float2(0,0);
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	return a;
}
