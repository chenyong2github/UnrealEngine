// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingThinGlass.ush: Microfacet BSDF for thin glass
===============================================================================================*/

#pragma once

#include "PathTracingMaterialCommon.ush"
#include "PathTracingFresnel.ush"
#include "PathTracingGlossy.ush"
#include "PathTracingEnergyConservation.ush"

struct FThinSlabWeights
{
	float3 Reflected;
	float3 Transmitted;
};

// return the amount of reflected and transmitted energy for an infinite slab viewed from a particular direction
// taking into account the (repeated) Fresnel terms and the transmittance through the slab
FThinSlabWeights ComputeThinSlabWeights(float3 SlabColor, float CosV, float Eta, float F0)
{
	// Compute Fresnel reflection off the top of the slab
	// The Fresnel refletion at the bottom layer is exactly equal so we can assume energy is split into R and T at each bounce
	// NOTE: we don't need to pass Eta through here because TIR (which could only occur in contrived scenarios) isn't really supported
	const float R = FresnelReflectance(CosV, 1.0, F0);

	// The slab color is normalized to unit thickness, so we only need to account for the refracted viewing angle
	// Note that we only allow Eta > 1.0 here so that we don't need to worry about TIR
	const float3 A = pow(SlabColor, Eta > 1.0 ? Eta * rsqrt(Eta * Eta - 1.0 + CosV * CosV) : rcp(abs(CosV)));

	// figure out how much is reflected/transmitted from a single interaction
	float3 SlabR = R;
	float3 SlabT = A - R * A; // (1 - R) * A

#if 1
	// Enable bounces within the slab
	if (R < 1.0)
	{
		// If there was some transmission we must also account for the infinite series of bounces within the slab
		// which can be computed exactly with a geometric series. Note that this causes a bit of energy loss because we don't
		// account for this non-linear fresnel term in the energy conservation calculation. However, this is fairly minimal in
		// practice, and the added visual richness seems worth it.
		float3 InvDenom = rcp(1.0 - Pow2(R * A));
		SlabR += R * Pow2(SlabT) * InvDenom;
		SlabT *= InvDenom - R * InvDenom; // (1 - R) * InvDenom
	}
#endif

	FThinSlabWeights Result = (FThinSlabWeights) 0;
	Result.Reflected = SlabR;
	Result.Transmitted = SlabT;
	return Result;
}

FMaterialEval RoughThinGlass_EvalMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	FPathTracingPayload Payload
)
{
	const float3 V_World = -IncomingDirection;
	const float3 L_World = OutgoingDirection;
	const float3 N_World = Payload.WorldNormal;

	const float Eta = Payload.Ior;
	const float F0 = F0RGBToF0(Payload.SpecularColor);
	const float F90 = saturate(50.0 * F0);
	const float3 SlabColor = Payload.GetTransmittanceColor();

	// transmitted lobe should have slightly less roughness due to the squeeze implied by the IOR (eventually converging to 0.0 as Ior approaches 1.0)
	const float RoughnessR = Payload.Roughness;
	const float RoughnessT = Payload.Roughness * sqrt(1.0 - min(Eta, rcp(Eta)));

	float2 AlphaR;
	const float3x3 Basis = GetGGXBasis(RoughnessR, Payload.Anisotropy, Payload.WorldNormal, Payload.WorldTangent, AlphaR);
	const float2 AlphaT = GetGGXAlpha(RoughnessT, Payload.Anisotropy);

	// move vectors into right shading frame
	float3 V = mul(Basis, V_World);
	float3 L = mul(Basis, L_World);

	if (V.z <= 0)
	{
		// invalid input
		return NullMaterialEval();
	}

	const bool bIsReflection = L.z >= 0;
	L.z = abs(L.z); // push L to the same side as V

	const float NoV = saturate(V.z);
	const float3 H = normalize(L + V);
	const float VoH = saturate(dot(V, H));


	// because the roughnesses may not match, we need to measure the response for each individually, taking into account the reflected and transmitted fresnel respectively
#if 1
	// NOTE: 1.0 - F_Schlick(NoV, F0, F90) == F_Schlick(NoV, 1.0 - F0, 1.0 - F90)
	const FBxDFEnergyTerms SpecR = ComputeGGXSpecEnergyTerms(RoughnessR, NoV, F0, F90);
	const FBxDFEnergyTerms SpecT = ComputeGGXSpecEnergyTerms(RoughnessT, NoV, 1.0 - F0, 1.0 - F90);
	// Approximate the transmission as just a plain tint by slab color because we can't depend on the half-vector for lobe selection
	const float NudgeE = rcp(SpecR.E.x + SpecT.E.x);
	const float ProbR = LobeSelectionProb(SpecR.E, Payload.HasRefraction() ? SpecT.E * SlabColor : 0.0);
#else
	const float Er = GGXEnergyLookup(RoughnessR, NoV).x;
	const float Et = GGXEnergyLookup(RoughnessT, NoV).x;
	const float ProbR = LobeSelectionProb(F0 * Er, Payload.HasRefraction() ? (1 - F0) * Et * SlabColor : 0.0);
#endif

	const FThinSlabWeights Result = ComputeThinSlabWeights(SlabColor, VoH, Payload.Ior, F0);
	const float2 GGXResult = GGXEvalReflection(L, V, H, bIsReflection ? AlphaR : AlphaT);
	if (bIsReflection)
	{
		if (ProbR > 0.0)
		{
			const float OutWeight = NudgeE * GGXResult.x * SpecR.W.x;
			return CreateMaterialEval(OutWeight / ProbR * Result.Reflected, GGXResult.y * ProbR);
		}
	}
	else
	{
		if (ProbR < 1.0)
		{
			const float OutWeight = NudgeE * GGXResult.x * SpecT.W.x;
			return CreateMaterialEval(OutWeight / (1.0 - ProbR) * Result.Transmitted, GGXResult.y * (1.0 - ProbR));
		}
	}
	return NullMaterialEval();
}


FMaterialSample RoughThinGlass_SampleMaterial(
	float3 RayDirection,
	FPathTracingPayload Payload,
	float4 RandSample)
{
	const float3 N_World = Payload.WorldNormal;
	const float3 V_World = -RayDirection;

	const float Eta = Payload.Ior;
	const float F0 = F0RGBToF0(Payload.SpecularColor);
	const float F90 = saturate(50.0 * F0);
	const float3 SlabColor = Payload.GetTransmittanceColor();

	// transmitted lobe should have slightly less roughness due to the squeeze implied by the IOR (eventually converging to 0.0 as Ior approaches 1.0)
	const float RoughnessR = Payload.Roughness;
	const float RoughnessT = Payload.Roughness * sqrt(1.0 - min(Eta, rcp(Eta)));

	float2 AlphaR;
	const float3x3 Basis = GetGGXBasis(RoughnessR, Payload.Anisotropy, Payload.WorldNormal, Payload.WorldTangent, AlphaR);
	const float2 AlphaT = GetGGXAlpha(RoughnessT, Payload.Anisotropy);

	const float3 V = mul(Basis, V_World);
	const float NoV = saturate(V.z);

	if (NoV == 0)
	{
		// invalid grazing angle
		return NullMaterialSample();
	}

	// because the roughnesses may not match, we need to measure the response for each individually, taking into account the reflected and transmitted fresnel respectively
#if 1
	// NOTE: 1.0 - F_Schlick(NoV, F0, F90) == F_Schlick(NoV, 1.0 - F0, 1.0 - F90)
	const FBxDFEnergyTerms SpecR = ComputeGGXSpecEnergyTerms(RoughnessR, NoV, F0, F90);
	const FBxDFEnergyTerms SpecT = ComputeGGXSpecEnergyTerms(RoughnessT, NoV, 1.0 - F0, 1.0 - F90);
	// Approximate the transmission as just a plain tint by slab color because we can't depend on the half-vector for lobe selection
	const float NudgeE = rcp(SpecR.E.x + SpecT.E.x);
	const float ProbR = LobeSelectionProb(SpecR.E, Payload.HasRefraction() ? SpecT.E * SlabColor : 0.0);
#else
	const float Er = GGXEnergyLookup(RoughnessR, NoV).x;
	const float Et = GGXEnergyLookup(RoughnessT, NoV).x;
	const float ProbR = LobeSelectionProb(F0 * Er, Payload.HasRefraction() ? (1 - F0) * Et * SlabColor : 0.0);
#endif

	const bool bIsReflection = RandSample.z < ProbR;

	const float3 H = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(RandSample.xy), bIsReflection ? AlphaR : AlphaT, V).xyz;
	const float NoH = saturate(H.z);
	const float VoH = saturate(dot(V, H));

	const float3 L = reflect(-V, H);
	if (L.z <= 0)
	{
		// invalid output direction, exit early
		return NullMaterialSample();
	}

	const float NoL = saturate(L.z);

	FThinSlabWeights Result = ComputeThinSlabWeights(SlabColor, VoH, Payload.Ior, F0);

	const float2 GGXResult = GGXEvalReflection(L, V, H, bIsReflection ? AlphaR : AlphaT);

	float3 OutWeight = GGXResult.x;
	float OutPdf = GGXResult.y;
	if (bIsReflection)
	{
		// reflected ray
		OutWeight *= NudgeE * SpecR.W.x * Result.Reflected / ProbR;
		OutPdf *= ProbR;
		float3 OutDirection = normalize(mul(L, Basis));
		return CreateMaterialSample(OutDirection, OutWeight, OutPdf, 1.0, Payload.Roughness);
	}
	else
	{
		// transmitted ray
		OutWeight *= NudgeE * SpecT.W.x * Result.Transmitted / (1.0 - ProbR);
		OutPdf *= 1.0 - ProbR;
		float3 OutDirection = normalize(mul(float3(L.xy, -L.z), Basis)); // flip reflection to other side
		return CreateMaterialSample(OutDirection, OutWeight, OutPdf, -1.0, Payload.Roughness);
	}
}
