// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
DirectionalLight.usf: Light sampling functions for Directional light implementation
===============================================================================================*/

#pragma once

#include "PathTracingLightCommon.ush"

float4 DirectionalLight_TraceLight(RayDesc Ray, int LightId, float HitT)
{
	if (Ray.TMax == HitT) // we hit the background
	{
		float3 LightDirection = GetNormal(LightId);
		float SinThetaMax = GetRadius(LightId); // Sin(Angle / 2)
		float SinThetaMax2 = SinThetaMax * SinThetaMax;
		// See explanation in UniformSampleConeRobust
		float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);

		float CosTheta = saturate(dot(normalize(Ray.Direction), LightDirection));

		// Is ray pointing inside the cone of directions?
		if (1 - CosTheta < OneMinusCosThetaMax)
		{
			// We divide the color of the light by the solid angle so
			// that the overall illumination stays constant as the angle changes.
			float SolidAngle = 2 * PI * OneMinusCosThetaMax;
			float3 Radiance = GetColor(LightId) / SolidAngle;
			return float4(Radiance, 1.0 / SolidAngle);
		}
	}
	return 0.0;
}

bool DirectionalLight_SampleLight(
	int LightId,
	float4 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	float SinThetaMax = GetRadius(LightId); // currently sin(Angle / 2)
	float4 DirAndPdf = UniformSampleConeRobust(RandSample.yz, SinThetaMax * SinThetaMax);

	OutDirection = TangentToWorld(DirAndPdf.xyz, GetNormal(LightId));
	OutDistance = 1.0e27;

	// Because the light is normalized by the solid angle, the ratio is just the color
	OutRadianceOverPdf = GetColor(LightId);
	OutPdf = DirAndPdf.w;

	return true;
}

void DirectionalLight_EstimateLight(
	int LightId,
	float3 WorldPos,
	float3 WorldNormal,
	bool IsTransmissiveMaterial,
	out float OutIrradiance
)
{
	float3 LightDirection = GetNormal(LightId);
	float3 SurfaceNormal = WorldNormal;

	float NoL = 1.0; // trivial upper bound -- trying to be more accurate appears to reduce performance
	float LightPower = Luminance(GetColor(LightId));
	OutIrradiance = LightPower * NoL;
}

void DirectionalLight_SampleLight(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	int LightId,
	out float3 OutLightUV,
	out float OutPdf
)
{
	float3 N = GetNormal(LightId);
	float Radius = GetRadius(LightId);

	if (Radius == 0)
	{
		// singular case
		// #dxr_todo: should return +inf PDF to disable MIS
		OutLightUV = N;
		OutPdf = 1.0;
	}
	else
	{
		// soft case - build a frame, and sample the distant cone
		float SinThetaMax = Radius; // currently sin(Angle / 2)

		float4 DirAndPdf = UniformSampleConeRobust(RandSample.yz, SinThetaMax * SinThetaMax);
		OutLightUV = TangentToWorld(DirAndPdf.xyz, N);
		OutPdf = DirAndPdf.w;
	}
}