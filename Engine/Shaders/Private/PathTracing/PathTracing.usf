// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracing.usf: Reference path tracing
===============================================================================================*/

#define PATH_TRACING  1

#define PATH_TRACING_SHADER_VERSION 0x51478b68 // Bump to force-compile this shader

#include "PathTracingCore.ush"

#if PATH_TRACER_USE_COMPACTION

int Bounce;
RWBuffer<uint> PathStateData;
Buffer<int> ActivePaths;
RWBuffer<int> NextActivePaths;
RWBuffer<int> NumPathStates;


// TODO: Experiment with AoS vs SoA vs AoSoA?
#define PATH_STATE_STRIDE   PATHTRACER_PATHSTATE_NUM_WORDS

FPathState LoadPathStateData(uint Index)
{
	FPathState Output = (FPathState)0;
	uint PackedPixelIndex = PathStateData[PATH_STATE_STRIDE * Index + 0];
	Output.PixelIndex = uint2(PackedPixelIndex & 0xFFFFu, PackedPixelIndex >> 16);

	Output.RandSequence.SampleIndex = PathStateData[PATH_STATE_STRIDE * Index + 1];
	Output.RandSequence.SampleSeed  = PathStateData[PATH_STATE_STRIDE * Index + 2];

	Output.Radiance.x = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 3]);
	Output.Radiance.y = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 4]);
	Output.Radiance.z = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 5]);

	uint3 PackedAlbedoNormal;
	PackedAlbedoNormal.x = PathStateData[PATH_STATE_STRIDE * Index + 6];
	PackedAlbedoNormal.y = PathStateData[PATH_STATE_STRIDE * Index + 7];
	PackedAlbedoNormal.z = PathStateData[PATH_STATE_STRIDE * Index + 8];
	Output.Albedo.x = f16tof32(PackedAlbedoNormal.x);
	Output.Albedo.y = f16tof32(PackedAlbedoNormal.x >> 16);
	Output.Albedo.z = f16tof32(PackedAlbedoNormal.y);
	Output.Normal.x = f16tof32(PackedAlbedoNormal.y >> 16);
	Output.Normal.y = f16tof32(PackedAlbedoNormal.z);
	Output.Normal.z = f16tof32(PackedAlbedoNormal.z >> 16);

	Output.Ray.Origin.x = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 9]);
	Output.Ray.Origin.y = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 10]);
	Output.Ray.Origin.z = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 11]);
	Output.Ray.Direction.x = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 12]);
	Output.Ray.Direction.y = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 13]);
	Output.Ray.Direction.z = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 14]);
	Output.Ray.TMin = 0;
	Output.Ray.TMax = POSITIVE_INFINITY;

	uint PackedRayCone = PathStateData[PATH_STATE_STRIDE * Index + 15];
	Output.RayCone.Width = f16tof32(PackedRayCone);
	Output.RayCone.SpreadAngle = f16tof32(PackedRayCone >> 16);

	Output.PathThroughput.x = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 16]);
	Output.PathThroughput.y = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 17]);
	Output.PathThroughput.z = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 18]);

	Output.PathRoughness = asfloat(PathStateData[PATH_STATE_STRIDE * Index + 19]);

	return Output;
}

void StorePathStateData(FPathState PathState, uint Index)
{
	PathStateData[PATH_STATE_STRIDE * Index + 0] = PathState.PixelIndex.x + PathState.PixelIndex.y * 65536;

	PathStateData[PATH_STATE_STRIDE * Index + 1] = PathState.RandSequence.SampleIndex;
	PathStateData[PATH_STATE_STRIDE * Index + 2] = PathState.RandSequence.SampleSeed;

	PathStateData[PATH_STATE_STRIDE * Index + 3] = asuint(PathState.Radiance.x);
	PathStateData[PATH_STATE_STRIDE * Index + 4] = asuint(PathState.Radiance.y);
	PathStateData[PATH_STATE_STRIDE * Index + 5] = asuint(PathState.Radiance.z);

	PathStateData[PATH_STATE_STRIDE * Index + 6] = f32tof16(PathState.Albedo.x) | (f32tof16(PathState.Albedo.y) << 16);
	PathStateData[PATH_STATE_STRIDE * Index + 7] = f32tof16(PathState.Albedo.z) | (f32tof16(PathState.Normal.x) << 16);
	PathStateData[PATH_STATE_STRIDE * Index + 8] = f32tof16(PathState.Normal.y) | (f32tof16(PathState.Normal.z) << 16);

	PathStateData[PATH_STATE_STRIDE * Index + 9]  = asuint(PathState.Ray.Origin.x);
	PathStateData[PATH_STATE_STRIDE * Index + 10] = asuint(PathState.Ray.Origin.y);
	PathStateData[PATH_STATE_STRIDE * Index + 11] = asuint(PathState.Ray.Origin.z);
	PathStateData[PATH_STATE_STRIDE * Index + 12] = asuint(PathState.Ray.Direction.x);
	PathStateData[PATH_STATE_STRIDE * Index + 13] = asuint(PathState.Ray.Direction.y);
	PathStateData[PATH_STATE_STRIDE * Index + 14] = asuint(PathState.Ray.Direction.z);

	PathStateData[PATH_STATE_STRIDE * Index + 15] = f32tof16(PathState.RayCone.Width) | (f32tof16(PathState.RayCone.SpreadAngle) << 16);

	PathStateData[PATH_STATE_STRIDE * Index + 16] = asuint(PathState.PathThroughput.x);
	PathStateData[PATH_STATE_STRIDE * Index + 17] = asuint(PathState.PathThroughput.y);
	PathStateData[PATH_STATE_STRIDE * Index + 18] = asuint(PathState.PathThroughput.z);

	PathStateData[PATH_STATE_STRIDE * Index + 19] = asuint(PathState.PathRoughness);
}

RAY_TRACING_ENTRY_RAYGEN(PathTracingMainRG)
{
	const uint2 DispatchIdx = DispatchRaysIndex().xy;
	const uint2 DispatchDim = DispatchRaysDimensions().xy;

	int LinearPixelIndex = DispatchIdx.x + DispatchDim.x * DispatchIdx.y;
	FPathState PathState;
	if (Bounce == 0)
	{
		PathState = CreatePathState(DispatchIdx, DispatchDim);
	}
	else
	{
		LinearPixelIndex = ActivePaths[LinearPixelIndex];
		if (LinearPixelIndex < 0)
		{
			return; // nothing left to do on this thread
		}
		PathState = LoadPathStateData(LinearPixelIndex);
	}

	const bool KeepGoing = PathTracingKernel(PathState, Bounce);
	// check how many lanes in our wave want to keep tracing forward
	const uint NumActive = WaveActiveCountBits(KeepGoing);

	uint GroupWriteStart;
	if (WaveIsFirstLane() && NumActive > 0)
	{
		// increment the global counter to know which lane to map to
		// NOTE: we reduce contention by only incrementing once per wave, but this is still sub-optimal
		InterlockedAdd(NumPathStates[0], NumActive, GroupWriteStart);
	}
	// Broadcast the global write offset to all lanes.
	GroupWriteStart = WaveReadLaneFirst(GroupWriteStart);

	if (KeepGoing)
	{
		// the path should still be extended - store the path state
		uint PathStateIndex = GroupWriteStart + WavePrefixCountBits(KeepGoing);
		NextActivePaths[PathStateIndex] = LinearPixelIndex;
		StorePathStateData(PathState, LinearPixelIndex);
	}
	else
	{
		// nothing left to do
		// Accumulate radiance and update pixel variance
		PathState.WritePixel(BlendFactor);
	}
}

#else

RAY_TRACING_ENTRY_RAYGEN(PathTracingMainRG)
{
	const uint2 DispatchIdx = DispatchRaysIndex().xy;
	const uint2 DispatchDim = DispatchRaysDimensions().xy;

	FPathState PathState = CreatePathState(DispatchIdx, DispatchDim);

	for (int Bounce = 0; Bounce <= MaxBounces; Bounce++)
	{
		if (!PathTracingKernel(PathState, Bounce))
		{
			// kernel had nothing more to do
			break;
		}
	}

	// Accumulate radiance and update pixel variance
	PathState.WritePixel(BlendFactor);
}

#endif