// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "../Common.ush"
#include "HairStrandsVisibilityCommon.ush"

#define TILE_SIZE 8
#define GROUP_THREAD_COUNT (TILE_SIZE*TILE_SIZE)

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_GENERATION
int2 BufferResolution;
uint bUintTexture;
Texture2D<float> InputFloatTexture;
Texture2D<uint> InputUintTexture;
RWBuffer<uint> TileCountBuffer;
RWBuffer<uint2> TileDataBuffer;
RWBuffer<uint2> TileClearBuffer;

groupshared bool s_HasTileHair[GROUP_THREAD_COUNT];

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileMainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	const uint2 PixelCoord = DispatchThreadId;

	bool bHasHairData = false;
	if (all(PixelCoord < uint2(BufferResolution)))
	{
		if (bUintTexture)
		{
			bHasHairData = InputUintTexture.Load(uint3(PixelCoord, 0)) > 0;
		}
		else
		{
			bHasHairData = InputFloatTexture.Load(uint3(PixelCoord, 0)) < 1.0f;
		}
	}
	s_HasTileHair[LinearIndex] = bHasHairData;

	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 1)
	{
		if ((s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 1]))
		{
			uint WriteToIndex;
			InterlockedAdd(TileCountBuffer[0], 1, WriteToIndex);
			TileDataBuffer[WriteToIndex] = GroupId.xy;
		}
		else
		{
			uint WriteToIndex;
			InterlockedAdd(TileCountBuffer[1], 1, WriteToIndex);
			TileClearBuffer[WriteToIndex] = GroupId.xy;
		}
	}
}
#endif // SHADER_TILE_GENERATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_COPY_ARGS
uint2 TileCountXY;
uint  TilePerThread_GroupSize;
uint bRectPrimitive;
Buffer<uint> TileCountBuffer;
RWBuffer<uint> TileIndirectDrawBuffer;
RWBuffer<uint> TileIndirectDispatchBuffer;
RWBuffer<uint> TilePerThreadIndirectDispatchBuffer;
RWBuffer<uint> TileClearIndirectDrawBuffer;

[numthreads(1, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	if (all(DispatchThreadId == 0))
	{
		const uint TileCount = TileCountBuffer[0];

		// Indirect draw
		TileIndirectDrawBuffer[0] = bRectPrimitive > 0 ? 4 : 6;  // VertexCountPerInstance
		TileIndirectDrawBuffer[1] = TileCount;  // InstanceCount
		TileIndirectDrawBuffer[2] = 0;  // StartVertexLocation
		TileIndirectDrawBuffer[3] = 0;  // StartInstanceLocation

		// Indirect dispatch
		TileIndirectDispatchBuffer[0] = TileCount >= TileCountXY.x ? TileCountXY.x : TileCount;
		TileIndirectDispatchBuffer[1] = (TileCount+TileCountXY.x-1) / TileCountXY.x;
		TileIndirectDispatchBuffer[2] = 1;

		// Indirect dispatch with one thread
		// At 4k, with 8x8 tiles: 4096 x 4096 / 8 x 8 = 512 x 512 tiles 
		// With a group size of 64 (8x8), the total dispatch count should be 512 x 512 / 8 x 8 = 64 x 64 = 4096, which is below the 65k limit per dimension
		TilePerThreadIndirectDispatchBuffer[0] = (TileCount + TilePerThread_GroupSize -1) / TilePerThread_GroupSize;
		TilePerThreadIndirectDispatchBuffer[1] = 1;
		TilePerThreadIndirectDispatchBuffer[2] = 1;

		const uint TileClearCount = TileCountBuffer[1];

		TileClearIndirectDrawBuffer[0] = bRectPrimitive > 0 ? 4 : 6;  // VertexCountPerInstance
		TileClearIndirectDrawBuffer[1] = TileClearCount;  // InstanceCount
		TileClearIndirectDrawBuffer[2] = 0;  // StartVertexLocation
		TileClearIndirectDrawBuffer[3] = 0;  // StartInstanceLocation
	}
}
#endif // SHADER_TILE_COPY_ARGS

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_DEBUG

void MainPS(
	in FScreenVertexOutput Input,
	out float4 OutColor0 : SV_Target0)
{
	const uint2 InTileCoord = uint2(Input.Position.xy) >> 3u; // TILE_SIZE == 8;
	const bool bTileX = (InTileCoord.x & 1) == 0;
	const bool bTileY = (InTileCoord.y & 1) == 0;
	const bool bChecker = (bTileX && bTileY) || (!bTileX && !bTileY);
	OutColor0 = 255;
	OutColor0 = bChecker ? float4(0.0f, 0.5f, 0.f, 1.0f) : float4(0.f, 1.0f, 0.f, 1.0f);
}

#endif //SHADER_TILE_DEBUG

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_DEBUG_PRINT
#include "../ShaderPrintCommon.ush"

int2 MaxResolution;
uint TileGroupSize;
uint TileSize;
uint TileCount;
int2 TileCountXY;
uint bRectPrimitive;

void AddNewLine(float2 OriginalPos, inout float2 Pos)
{
	Pos = ShaderPrintNewline(Pos); Pos.x = OriginalPos.x;
}

[numthreads(1, 1, 1)]
void MainCS(uint GroupIndex : SV_GroupIndex, uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (any(DispatchThreadId != 0)) return;

	// Pixel coord
	float2 OriginalPos = float2(50, 50) / float2(MaxResolution);
	float2 Pos = OriginalPos;

	Pos = ShaderPrintText(Pos, TEXT("Tile Count XY: "), FontWhite);
	Pos = ShaderPrint(Pos, TileCountXY, FontEmerald);
	AddNewLine(OriginalPos, Pos);

	const uint ActiveTileCount = HairStrands.HairTileCount[0];
	Pos = ShaderPrintText(Pos, TEXT("Tile Count   : "), FontWhite);
	Pos = ShaderPrint(Pos, ActiveTileCount, FontYellow);
	Pos = ShaderPrint(Pos, 100.f * float(ActiveTileCount)/float(TileCount), FontOrange);
	Pos = ShaderPrintText(Pos, TEXT("%"), FontOrange);
	AddNewLine(OriginalPos, Pos);

	Pos = ShaderPrintText(Pos, TEXT("Tile Size    : "), FontWhite);
	Pos = ShaderPrint(Pos, TileSize, FontYellow);
	AddNewLine(OriginalPos, Pos);

	Pos = ShaderPrintText(Pos, TEXT("Tile Threads : "), FontWhite);
	Pos = ShaderPrint(Pos, TileGroupSize, FontYellow);
	AddNewLine(OriginalPos, Pos);

	Pos = ShaderPrintText(Pos, TEXT("Primitive    : "), FontWhite);
	if (bRectPrimitive)
		Pos = ShaderPrintText(Pos, TEXT("Rect."), FontOrange);
	else
		Pos = ShaderPrintText(Pos, TEXT("Triangle"), FontOrange);
	AddNewLine(OriginalPos, Pos);
}

#endif //SHADER_TILE_DEBUG_PRINT

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_VS
int2 ViewMin;
float2 ViewInvSize;
Buffer<uint2> TileDataBuffer;

void MainVS(
	in uint InVertexId : SV_VertexID,
	in uint InInstanceId : SV_InstanceID,
	out FScreenVertexOutput Out)
{
	Out = (FScreenVertexOutput)0;
	const uint2 TileCoord = TileDataBuffer[InInstanceId];

	uint2 TileVertex = TileCoord * TILE_SIZE;
	TileVertex.x += InVertexId == 1 || InVertexId == 2 || InVertexId == 4 ? TILE_SIZE : 0;
	TileVertex.y += InVertexId == 2 || InVertexId == 4 || InVertexId == 5 ? TILE_SIZE : 0;
	Out.UV = float2(TileVertex - ViewMin) * ViewInvSize;
	Out.Position = float4(Out.UV * float2(2.0f, -2.0f) + float2(-1.0, 1.0f), 0.5f, 1.0f);
}

#endif //SHADER_TILE_VS
