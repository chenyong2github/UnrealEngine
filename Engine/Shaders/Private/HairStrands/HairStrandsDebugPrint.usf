// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../ShaderPrintCommon.ush"
#include "../ShaderDrawDebug.ush"
#include "HairStrandsVisibilityCommon.ush"
#include "HairStrandsAABBCommon.ush" 

int2 PixelCoord;
int2 MaxResolution;
uint FastResolveMask;
uint HairMacroGroupCount;
uint2 GroupSize; 
uint HairVisibilityNodeGroupSize;

Texture2D<float> HairCountTexture;
Texture2D<uint> HairCountUintTexture;

Texture2D<uint2> DepthStencilTexture;
SamplerState LinearSampler;
Buffer<uint> HairVisibilityIndirectArgsBuffer;

Buffer<int> HairMacroGroupAABBBuffer;

#define MATERIAL_DATA 1
#define DETAIL_DATA 1

void AddNewLine(float2 OriginalPos, inout float2 Pos)
{
	Pos = ShaderPrintNewline(Pos); Pos.x = OriginalPos.x;
}

[numthreads(1, 1, 1)]
void MainCS(uint GroupIndex : SV_GroupIndex, uint3 DispatchThreadId : SV_DispatchThreadID)
{	
	// Draw AABB of the instance groups
	if (DispatchThreadId.x == 0 && DispatchThreadId.y == 0 && DispatchThreadId.z == 0)
	{
		for (uint GroupIndex =0;GroupIndex< HairMacroGroupCount; GroupIndex++)
		{
			const float4 InstanceBoundColor = float4(1.f, 0.5f, 0.5f, 1.0f);
			FHairAABB Bound = ReadHairAABB(GroupIndex, HairMacroGroupAABBBuffer);
			AddAABB(Bound.Min, Bound.Max, InstanceBoundColor);
		}

		const uint DispatchX = HairVisibilityIndirectArgsBuffer[0];
		const uint DispatchY = HairVisibilityIndirectArgsBuffer[1];
		const uint TotalSampleCount = DispatchX * DispatchY * HairVisibilityNodeGroupSize;
		const uint2 EquivalentResolution = ceil(sqrt(TotalSampleCount));

		// Pixel coord
		float2 OriginalPos = float2(50, 50) / float2(MaxResolution);
		float2 Pos = OriginalPos;
		Pos = ShaderPrintText(Pos, TEXT("Total Sample Count "), FontCyan);
		Pos = ShaderPrint(Pos, TotalSampleCount, FontCyan);
		Pos = ShaderPrint(Pos, HairStrands.HairSampleCount.Load(uint3(0,0,0)), FontCyan);
		AddNewLine(OriginalPos, Pos);

		Pos = ShaderPrintText(Pos, TEXT("Equivalent Res     "), FontCyan);
		Pos = ShaderPrint(Pos, EquivalentResolution, FontCyan);
		AddNewLine(OriginalPos, Pos);

		Pos = ShaderPrintText(Pos, TEXT("MacroGroup Count   "), FontYellow);
		Pos = ShaderPrint(Pos, HairMacroGroupCount, FontYellow);
		AddNewLine(OriginalPos, Pos);
	}

	const float2 PixelPos = PixelCoord;
	if (PixelCoord.x < 0 || PixelCoord.y < 0 || PixelCoord.x >= MaxResolution.x || PixelCoord.y >= MaxResolution.y)
		return;

	ShaderPrintFilter(true);

	const float HairPixelCoverage = HairStrands.HairCoverageTexture.Load(uint3(PixelPos, 0));
	const bool bIsValid = HairPixelCoverage > 0;
	if (!bIsValid)
		return;

	const float ViewHairCount = HairCountTexture.Load(uint3(PixelPos, 0));
	const float ViewHairCountUint = HairCountUintTexture.Load(uint3(PixelPos, 0)) /  1000.f;

//	const float2 OriginalPos = PixelPos / float2(MaxResolution);
	const float2 OriginalPos = float2(50,500) / float2(MaxResolution);
	float2 Pos = OriginalPos;

	uint Total8BitCoverage = 0;
	const FNodeDesc NodeDesc = DecodeNodeDesc(HairStrands.HairSampleOffset.Load(uint3(PixelCoord, 0)));
	for (uint SampleIt0 = 0; SampleIt0 < NodeDesc.Count; SampleIt0++)
	{
		const uint LocalOffset = NodeDesc.Offset + SampleIt0;
		const FPackedHairSample NodeData = HairStrands.HairSampleData[LocalOffset];
		const FHairSample Sample = UnpackHairSample(NodeData);
		Total8BitCoverage += Sample.Coverage8bit;
	}

	// Pixel coord
	Pos = ShaderPrintText(Pos, TEXT("Pixel           "), FontTurquoise);
	Pos = ShaderPrint(Pos, PixelCoord, FontTurquoise);
	AddNewLine(OriginalPos, Pos);

	// Max sample
	Pos = ShaderPrintText(Pos, TEXT("Max Sample      "));
	Pos = ShaderPrint(Pos, HairStrands.MaxSamplePerPixelCount);
	AddNewLine(OriginalPos, Pos);

	// Unique sample
	Pos = ShaderPrintText(Pos, TEXT("Sample          "), FontOrange);
	Pos = ShaderPrint(Pos, NodeDesc.Count, FontOrange);
	AddNewLine(OriginalPos, Pos);

	// Accurate coverage (if coverage pass is activated)
	Pos = ShaderPrintText(Pos, TEXT("Hair Count      "));
	Pos = ShaderPrint(Pos, ViewHairCount);
	AddNewLine(OriginalPos, Pos);

	// Accurate coverage (if coverage pass is activated) uint
	Pos = ShaderPrintText(Pos, TEXT("Hair Count Uint "));
	Pos = ShaderPrint(Pos, ViewHairCountUint);
	AddNewLine(OriginalPos, Pos);
	
	// Accurate coverage (if coverage pass is activated)
	Pos = ShaderPrintText(Pos, TEXT("Coverage        "), FontOrange);
	Pos = ShaderPrint(Pos, HairPixelCoverage, FontOrange);
	AddNewLine(OriginalPos, Pos);

	// 8 bit Coverage (summed)
	Pos = ShaderPrintText(Pos, TEXT("Sum cov. 8bits  "));
	Pos = ShaderPrint(Pos, Total8BitCoverage);
	AddNewLine(OriginalPos, Pos);

	// Resolve type
	const uint Stencil = DepthStencilTexture.Load(uint3(PixelPos,0)).y;
	const bool bIsFastResolve = (Stencil & FastResolveMask) != 0;
	Pos = ShaderPrintText(Pos, TEXT("Resolve         "));

	if (bIsFastResolve)
	{
		Pos = ShaderPrintText(Pos, TEXT("Fast"), FontEmerald);
	}
	else
	{
		Pos = ShaderPrintText(Pos, TEXT("Regular"), FontEmerald);
	}

	AddNewLine(OriginalPos, Pos);
	AddNewLine(OriginalPos, Pos);

	const float2 ColumnPos = Pos;

	// Sample Description
	{	
		Pos = ShaderPrintText(Pos, TEXT("Sample ID       "), FontWhite);	AddNewLine(OriginalPos, Pos);
	#if MATERIAL_DATA
		Pos = ShaderPrintText(Pos, TEXT(".Base Color R   "), FontRed);		AddNewLine(OriginalPos, Pos); 
		Pos = ShaderPrintText(Pos, TEXT(".Base Color G   "), FontGreen);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Base Color B   "), FontBlue);		AddNewLine(OriginalPos, Pos);
		AddNewLine(OriginalPos, Pos);

		Pos = ShaderPrintText(Pos, TEXT(".Tangent X      "), FontEmerald);	AddNewLine(OriginalPos, Pos); 
		Pos = ShaderPrintText(Pos, TEXT(".Tangent Y      "), FontEmerald);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Tangent Z      "), FontEmerald);	AddNewLine(OriginalPos, Pos);
		AddNewLine(OriginalPos, Pos);

		Pos = ShaderPrintText(Pos, TEXT(".Roughness      "), FontOrange);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Specular       "), FontEmerald);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Backlit        "), FontOrange);	AddNewLine(OriginalPos, Pos);
		AddNewLine(OriginalPos, Pos);
	#endif 													  
	#if DETAIL_DATA											  
		Pos = ShaderPrintText(Pos, TEXT(".Light Channels "), FontEmerald);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Scatter Scene  "), FontOrange);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Depth          "), FontEmerald);	AddNewLine(OriginalPos, Pos);
		AddNewLine(OriginalPos, Pos);

		Pos = ShaderPrintText(Pos, TEXT(".Macro Group ID "), FontYellow);	AddNewLine(OriginalPos, Pos);
		Pos = ShaderPrintText(Pos, TEXT(".Primitive		 "), FontEmerald);	AddNewLine(OriginalPos, Pos);
	#endif													  
		Pos = ShaderPrintText(Pos, TEXT(".Coverage       "), FontOrange);	AddNewLine(OriginalPos, Pos);
	}

	// Per sample description
	for (uint SampleIt = 0; SampleIt < NodeDesc.Count; SampleIt++)
	{
		const uint LocalOffset = NodeDesc.Offset + SampleIt;
		const FHairSample Sample = UnpackHairSample(HairStrands.HairSampleData[LocalOffset]);

		float2 StartSamplePos = ColumnPos + float2(150.f + 80.f * SampleIt, 0.f) / float2(MaxResolution);
		Pos = StartSamplePos;

		Pos = ShaderPrint(Pos, SampleIt, FontWhite);									AddNewLine(StartSamplePos, Pos);

	#if MATERIAL_DATA
		Pos = ShaderPrint(Pos, Sample.BaseColor.x,	FontRed);							AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.BaseColor.y,	FontGreen);							AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.BaseColor.z,	FontBlue);							AddNewLine(StartSamplePos, Pos);
		AddNewLine(StartSamplePos, Pos);

		Pos = ShaderPrint(Pos, Sample.Tangent.x,	FontEmerald);						AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.Tangent.y,	FontEmerald);						AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.Tangent.z,	FontEmerald);						AddNewLine(StartSamplePos, Pos);
		AddNewLine(StartSamplePos, Pos);

		Pos = ShaderPrint(Pos, Sample.Roughness,	FontOrange);						AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.Specular,		FontEmerald);						AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.Backlit,		FontOrange);						AddNewLine(StartSamplePos, Pos);
		AddNewLine(StartSamplePos, Pos);
	#endif 

	#if DETAIL_DATA
		Pos = ShaderPrint(Pos,(Sample.LightChannelMask & 0x1) ? 1u : 0u, FontEmerald);	AddNewLine(StartSamplePos, Pos);
//		Pos = ShaderPrint(Pos,(Sample.LightChannelMask & 0x1) ? 1u : 0u);				AddNewLine(StartSamplePos, Pos);
//		Pos = ShaderPrint(Pos,(Sample.LightChannelMask & 0x2) ? 1u : 0u);				AddNewLine(StartSamplePos, Pos);
//		Pos = ShaderPrint(Pos,(Sample.LightChannelMask & 0x4) ? 1u : 0u);				AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.bScatterSceneLighting ? 1u : 0u, FontOrange);		AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.Depth, FontEmerald);								AddNewLine(StartSamplePos, Pos);
		AddNewLine(StartSamplePos, Pos);

		Pos = ShaderPrint(Pos, Sample.MacroGroupId, FontYellow);						AddNewLine(StartSamplePos, Pos);
		Pos = ShaderPrint(Pos, Sample.PrimitiveId, FontEmerald);						AddNewLine(StartSamplePos, Pos);
	#endif
		Pos = ShaderPrint(Pos, Sample.Coverage8bit, FontOrange);						AddNewLine(StartSamplePos, Pos);
	}
}
