// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "HairStrandsVisibilityCommon.ush" 

#if PERMUTATION_GROUPSIZE == 0
#define TILE_PIXEL_SIZE_X 8
#define TILE_PIXEL_SIZE_Y 4
#else
#define TILE_PIXEL_SIZE_X 8
#define TILE_PIXEL_SIZE_Y 8
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

int2 OutputResolution;
uint MaxNodeCount;
float CoverageThreshold;

//float LUT_HairCount;
//float LUT_HairRadiusCount;
//
//SamplerState					LinearSampler;
//Texture2D<float>				HairCoverageLUT;

RWTexture2D<uint> 				OutCompactNodeCounter;
RWTexture2D<uint> 				OutCompactNodeIndex;
RWStructuredBuffer<FNodeVis> 	OutCompactNodeData;
RWStructuredBuffer<uint> 		OutCompactNodeCoord;
RWTexture2D<uint4> 				OutCategorizationTexture;

float TransmittanceToCoverage(float InTransmittance)
{
	return saturate(min(1 - InTransmittance, 1) / CoverageThreshold);
}

groupshared uint AllocationNodeCount;
groupshared uint AllocationNodeOffset;


struct FSampleSetDesc
{
	uint   UniqueSampleCount;
	uint   ValidSampleCount;
	uint   HairSampleCount;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Compute raster visibility buffer
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

Texture2D<uint2> VisibilityTexture0;
Texture2D<uint2> VisibilityTexture1;
Texture2D<uint2> VisibilityTexture2;
Texture2D<uint2> VisibilityTexture3;

Texture2D<uint>  VisibilityHairCount;
Texture2D<float> ViewTransmittanceTexture;

[numthreads(TILE_PIXEL_SIZE_X, TILE_PIXEL_SIZE_Y, 1)]
void MainCS(uint GroupIndex : SV_GroupIndex, uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (GroupIndex == 0)
	{
		AllocationNodeCount = 0;
		AllocationNodeOffset = 0;
	}

	uint2 PixelCoord = DispatchThreadId.xy;// +ResolutionOffset;
	if (PixelCoord.x >= uint(OutputResolution.x) || PixelCoord.y >= uint(OutputResolution.y))
		PixelCoord = uint2(0, 0);

	FSampleSetDesc SampleDesc;

	const float OpaqueDepth = SceneTexturesStruct.SceneDepthTexture.Load(uint3(PixelCoord, 0)).r;

	//const uint HairCountAndRadius = VisibilityHairCount.Load(uint3(PixelCoord, 0)); // Contains both hair count and the radius;
	//const uint HairRadius = 0; // TODO
	//const uint HairCount  = HairCountAndRadius;

	const uint2 VisData0 = VisibilityTexture0.Load(uint3(PixelCoord, 0));
	const uint2 VisData1 = VisibilityTexture1.Load(uint3(PixelCoord, 0));
	const uint2 VisData2 = VisibilityTexture2.Load(uint3(PixelCoord, 0));
	const uint2 VisData3 = VisibilityTexture3.Load(uint3(PixelCoord, 0));

	uint2  VisData[4];
	float2 VisDepthAndCoverage[4];
	float  TotalCoverage = 0;
	uint   UniqueSampleCount = 0;

	if (VisData0.y)
	{
		VisData[UniqueSampleCount]				 = VisData0;
		VisDepthAndCoverage[UniqueSampleCount]	 = UnpackHairVisSampleDepth(VisData0.y);
		TotalCoverage							+= VisDepthAndCoverage[UniqueSampleCount].y;

		UniqueSampleCount++;
	}

	if (VisData1.y)
	{
		VisData[UniqueSampleCount]				 = VisData1;
		VisDepthAndCoverage[UniqueSampleCount]	 = UnpackHairVisSampleDepth(VisData1.y);
		TotalCoverage							+= VisDepthAndCoverage[UniqueSampleCount].y;
		UniqueSampleCount++;
	}

	if (VisData2.y)
	{
		VisData[UniqueSampleCount]				 = VisData2;
		VisDepthAndCoverage[UniqueSampleCount]	 = UnpackHairVisSampleDepth(VisData2.y);
		TotalCoverage							+= VisDepthAndCoverage[UniqueSampleCount].y;
		UniqueSampleCount++;
	}

	if (VisData3.y)
	{
		VisData[UniqueSampleCount]				 = VisData3;
		VisDepthAndCoverage[UniqueSampleCount]	 = UnpackHairVisSampleDepth(VisData3.y);
		TotalCoverage							+= VisDepthAndCoverage[UniqueSampleCount].y;
		UniqueSampleCount++;
	}

	FNodeDesc NodeDesc;
	NodeDesc.Count = UniqueSampleCount;
	NodeDesc.Offset = 0;

	if (NodeDesc.Count > 0)
	{
		InterlockedAdd(AllocationNodeCount, NodeDesc.Count, NodeDesc.Offset);
	}
	GroupMemoryBarrierWithGroupSync();
	if (GroupIndex == 0 && AllocationNodeCount > 0)
	{
		InterlockedAdd(OutCompactNodeCounter[uint2(0, 0)], AllocationNodeCount, AllocationNodeOffset);
	}
	GroupMemoryBarrierWithGroupSync();

	// Allocate node space
	FCategorizationData Categorization = (FCategorizationData)0;
	if (NodeDesc.Count > 0)
	{
		NodeDesc.Offset += AllocationNodeOffset;

		// Store final sort node data 
		if (NodeDesc.Offset + NodeDesc.Count < MaxNodeCount)
		{
			for (uint OutIndex = 0; OutIndex < NodeDesc.Count; ++OutIndex)
			{
				const FHairVisSample VisSample = UnpackHairVisSample(VisData[OutIndex].x);

				// VisibilityData.Coverage8bit is a weight normalising to 1 the contribution of all the compacted samples. Because later it is weighted by Categorization.PixelCoverage.
				FNodeVis OutNodeVis;
				OutNodeVis.PrimitiveId	= VisSample.PrimitiveId;
				OutNodeVis.Depth		= VisDepthAndCoverage[OutIndex].x;
				OutNodeVis.Coverage8bit = To8bitCoverage(VisDepthAndCoverage[OutIndex].y / TotalCoverage); // To8bitCoverage(Samples[OutIndex].y / float(SampleDesc.ValidSampleCount));
				OutNodeVis.MaterialId	= VisSample.MaterialId;

				Categorization.TotalCoverage8bit += OutNodeVis.Coverage8bit;
				Categorization.ClosestDepth = max(Categorization.ClosestDepth, OutNodeVis.Depth); // Inverse-Z

				const uint StoreIndex = NodeDesc.Offset + OutIndex;
				OutCompactNodeData[StoreIndex] = OutNodeVis;
				OutCompactNodeCoord[StoreIndex] = (PixelCoord.x & 0xFFFF) | ((PixelCoord.y & 0xFFFF) << 16);
			}

			NodeDesc.Count = NodeDesc.Count;
			Categorization.SampleCount = NodeDesc.Count;

			Categorization.PixelCoverage = TransmittanceToCoverage(ViewTransmittanceTexture.Load(uint3(PixelCoord, 0)));
		}
	}

	OutCompactNodeIndex[PixelCoord] = EncodeNodeDesc(NodeDesc);
	OutCategorizationTexture[PixelCoord] = EncodeCategorizationData(Categorization);
}
