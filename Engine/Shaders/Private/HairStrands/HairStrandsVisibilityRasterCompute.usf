// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "HairStrandsClusterCommon.ush"
#include "HairStrandsVertexFactoryCommon.ush"
#include "HairStrandsVisibilityCommon.ush"

///////////////////////////////////////////////////////////////////////////
// Common parameters

uint	TileSizeAsShift;
uint	TileSize;
float	RcpTileSize;
uint	SqrTileSize;
int2	TileRes;

uint	NumBinners;
float	RcpNumBinners;
uint	NumRasterizers;
float	RcpNumRasterizers;

uint	MaxRasterCount;
uint	FrameIdMod8;
uint	ResolutionMultiplier;
int2	OutputResolution;
float2	OutputResolutionf;

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_BINNING || SHADER_RASTERCOMPUTE_RASTER || SHADER_RASTERCOMPUTE_DEPTH_GRID

///////////////////////////////////////////////////////////////////////////
// 
// Wave size
#if SHADER_RASTERCOMPUTE_DEPTH_GRID == 0

#if PERMUTATION_GROUP_SIZE == 64
#define WAVE_SIZE 32
#elif PERMUTATION_GROUP_SIZE == 32
#define WAVE_SIZE 32
#else
#error Unknown group size	
#endif

#endif //SHADER_RASTERCOMPUTE_DEPTH_GRID

///////////////////////////////////////////////////////////////////////////

/* 
// use untyped buffer for segment tiles to reduce VGPR usage - 16 bytes
struct FVisTile
{
	uint PrimOffset;
	uint PrimCount;
	uint TileCoord;
	uint MinDepth;
};
*/
#define VT_SIZE 4

#define VT_PrimOffset 0
#define VT_PrimCount 1
#define VT_Coord 2
#define VT_NearestDepth 3

uint PackVisTileCoord(uint2 Coord)
{
	return uint(((Coord.x & 0xff) << 0) | (((Coord.y) & 0xff) << 8));
}

uint2 UppackVisTileCoord(uint Packed)
{
	return uint2(((Packed >> 0) & 0xff), ((Packed >> 8) & 0xff));
}

///////////////////////////////////////////////////////////////////////////

uint			MacroGroupId;
uint			HairMaterialId;
uint			HairStrandsVF_bIsCullingEnable;
float			HairStrandsVF_Radius;
float			HairStrandsVF_RootScale;
float			HairStrandsVF_TipScale;
float			HairStrandsVF_Length;
float			HairStrandsVF_Density;
uint			HairStrandsVF_bUseStableRasterization;
float3			HairStrandsVF_PositionOffset;
uint			HairStrandsVF_VertexCount;
float4x4		HairStrandsVF_LocalToWorldPrimitiveTransform;
Buffer<uint4>	HairStrandsVF_PositionBuffer;
Buffer<float4>	HairStrandsVF_PositionOffsetBuffer;

Texture2D<float> SceneDepthTexture;

uint 			VertexCount;
uint 			VertexStart;
float			SampleWeight;

float3 NDCToPixelCoord(float4 InDC)
{
	const float3 NDC = InDC.xyz / InDC.w;
	float2 UV = NDC.xy * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz;
	return float3(UV * OutputResolution, NDC.z);
}

void CalcScreenPos(in uint4 PB, in float3 PBO, out float3 SP, out uint Type)
{
	const FHairControlPoint CP = UnpackHairControlPoint(
		PB,
		PBO,
		HairStrandsVF_Radius,
		HairStrandsVF_RootScale,
		HairStrandsVF_TipScale);

	const float3 WP = mul(float4(CP.Position, 1), HairStrandsVF_LocalToWorldPrimitiveTransform).xyz;
	float4 NDC = mul(float4(WP, 1), LWCHackToFloat(PrimaryView.WorldToClip));

	SP = NDCToPixelCoord(NDC);

	Type = CP.Type;
}

void CalcScreenPosAndRad(in uint4 PB, in float3 PBO, out float4 SP, out float Rad)
{
	const FHairControlPoint CP = UnpackHairControlPoint(
		PB,
		PBO,
		HairStrandsVF_Radius,
		HairStrandsVF_RootScale,
		HairStrandsVF_TipScale);

	const float3 WP = mul(float4(CP.Position, 1), HairStrandsVF_LocalToWorldPrimitiveTransform).xyz;
	float4 NDC = mul(float4(WP, 1), LWCHackToFloat(PrimaryView.WorldToClip));

	SP = float4(NDCToPixelCoord(NDC).xy, NDC.zw);

	Rad = CP.WorldRadius*2000.0; // OutputResolutionf.x; //TODO: figure this out correctly?
}

#endif // Common rasetrizer helper function & parameters

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_DEPTH_GRID

RWTexture2D<uint>	OutVisTileDepthGrid;
RWTexture2D<uint>	OutDepthCovTexture;

groupshared uint group_FurthestDepth; // (4 bytes)

[numthreads(1024, 1, 1)]
void PrepareDepthGridCS(uint dId : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID)
{
	uint tw = TileRes.x;
	uint th = TileRes.y;

	if (GroupThreadID == 0) group_FurthestDepth = 0xffffffff;

	GroupMemoryBarrierWithGroupSync();

	uint t = dId / 1024;

	uint ty = uint((float(t)+0.5) / float(tw));
	uint tx = t - (ty*tw);

	for (uint p = GroupThreadID; p < SqrTileSize; p += 1024)
	{
		if (p < SqrTileSize)
		{
			uint py = (float(p)+0.5) * RcpTileSize;
			uint px = p - (py*TileSize);

			uint2 Coord = uint2(tx * TileSize + px, ty * TileSize + py);

			if (Coord.x < uint(OutputResolution.x) && Coord.y < uint(OutputResolution.y))
			{
				float Depth = SceneDepthTexture.Load(uint3(Coord, 0));
				uint packedDepth = PackHairVisDepthCoverage(Depth, 1.0);

				InterlockedMin(group_FurthestDepth, packedDepth);

				InterlockedMax(OutDepthCovTexture[Coord], packedDepth);
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	OutVisTileDepthGrid[uint2(tx, ty)] = group_FurthestDepth;
}

#endif //SHADER_RASTERCOMPUTE_DEPTH_GRID

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_BINNING

#if PERMUTATION_CULLING
Buffer<uint>	HairStrandsVF_CullingIndirectBuffer;
Buffer<uint>	HairStrandsVF_CullingIndexBuffer;
Buffer<float>	HairStrandsVF_CullingRadiusScaleBuffer;
Buffer<uint>	IndirectBufferArgs;
#endif

RWTexture3D<uint> 					OutVisTileBinningGrid;
Texture2D<uint>						VisTileDepthGrid;
RWBuffer<uint>						OutVisTilePrims;
RWBuffer<uint>						OutVisTileArgs;
RWByteAddressBuffer					OutVisTileData;

uint LoadOutVisTileData(uint index, uint offset)
{
	return OutVisTileData.Load((((index)) * VT_SIZE * 4) + ((offset) * 4));
}

void StoreOutVisTileData(uint index, uint offset, uint value)
{
	OutVisTileData.Store((((index)) * VT_SIZE * 4) + ((offset) * 4), (value));
}

groupshared uint group_LoopNum;
groupshared uint group_BatchNum;

// The total number of line segments (VertexCount) is divided up equally between N binners - each binner = a workgroup which loops through the designated set segments in batches of 1024
// NB there is still potential to use LDS to prevent/reduce contention when adding segments to the binning grid and this may improve perf

[numthreads(1024, 1, 1)]
void BinningCS(uint2 DispatchThreadID : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID, uint GroupID : SV_GroupID)
{
	ResolvedView = ResolveView();
	if (GroupThreadID == 0)
	{
#if PERMUTATION_CULLING	
		if (HairStrandsVF_bIsCullingEnable)
		{
			group_BatchNum = (HairStrandsVF_CullingIndirectBuffer[3] + 1023) / 1024;
		}
		else
		{
			group_BatchNum = (VertexCount + 1023) / 1024;
		}
#else
		group_BatchNum = (VertexCount + 1023) / 1024;
#endif
		
		group_LoopNum = (group_BatchNum + (NumBinners - 1)) * RcpNumBinners;
	}

	GroupMemoryBarrierWithGroupSync();

	[loop]
	for (uint LoopIndex = 0; LoopIndex < group_LoopNum; LoopIndex++)
	{
		uint BatchIndex = LoopIndex + (GroupID * group_LoopNum);

		bool bSegValid = (BatchIndex < group_BatchNum) ? true : false;

		bool bTileIntersected[3] = { false, false, false };

		int2 TileCoord[3] = { int2(-1, -1), int2(-1, -1), int2(-1, -1) };

		uint SegIndex[3] = { 0xffffffff, 0xffffffff, 0xffffffff };


#if PERMUTATION_CULLING
		uint PrimID = BatchIndex * 1024 + GroupThreadID;
		if (HairStrandsVF_bIsCullingEnable)
		{
			group_BatchNum = (HairStrandsVF_CullingIndirectBuffer[3] + 1023) / 1024;
			if (bSegValid) bSegValid = (PrimID < (HairStrandsVF_CullingIndirectBuffer[3])) ? true : false;
		}
		else
		{
			if (bSegValid) bSegValid = (PrimID < (VertexCount)) ? true : false;
		}

		if (bSegValid && HairStrandsVF_bIsCullingEnable)
		{
			const uint VertexCountAfterCulling = HairStrandsVF_CullingIndirectBuffer[3];
			uint FetchIndex0 = PrimID;
			if (FetchIndex0 >= (VertexCountAfterCulling-1))
			{
				bSegValid = false;
			}
			else
			{
				uint FetchIndex1 = min(FetchIndex0 + 1, VertexCountAfterCulling - 1);

				uint VertexIndex0 = HairStrandsVF_CullingIndexBuffer[FetchIndex0];
				float LodRadiusScale0 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex0];

				uint VertexIndex1 = HairStrandsVF_CullingIndexBuffer[FetchIndex1];
				float LodRadiusScale1 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex1];

				if ((LodRadiusScale0 <= 0.0f) || (VertexIndex1 != VertexIndex0 + 1))
				{
					bSegValid = false;
				}
				else
				{
					PrimID = VertexIndex0;
				}
			}
		}
#else
		uint PrimID = BatchIndex * 1024 + GroupThreadID + VertexStart;
		if (bSegValid) bSegValid = (PrimID < (VertexStart + VertexCount)) ? true : false;
#endif

		uint BinID = GroupID - (uint(float(GroupID + 0.5) * RcpNumBinners)* NumBinners);
		uint BinID2 = BinID + NumBinners;


		if (bSegValid) //currently hardcoded to a maximum of 3 tile bins - this only works corectly when segment length does not exceed TileSize - TODO: add support for N bins
		{
			float3 SP0;
			float3 SP1;

			uint Type;
			CalcScreenPos(HairStrandsVF_PositionBuffer[PrimID], HairStrandsVF_PositionOffsetBuffer[0].xyz, SP0, Type);

			bool bIsEndCV = (Type == HAIR_CONTROLPOINT_END); 

			if (!bIsEndCV)
			{
				CalcScreenPos(HairStrandsVF_PositionBuffer[PrimID + 1], HairStrandsVF_PositionOffsetBuffer[0].xyz, SP1, Type);

				uint NearestDepth = PackHairVisDepthCoverage(max(SP0.z, SP1.z), 1.0);

				TileCoord[0] = int2(SP0.x * RcpTileSize, SP0.y * RcpTileSize);

				if (all(TileCoord[0] >= 0) && all(TileCoord[0] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[0]])
				{
					InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[0], BinID)], 1, SegIndex[0]);
					bTileIntersected[0] = true;
				}

				TileCoord[1] = int2(SP1.x * RcpTileSize, SP1.y * RcpTileSize);

				if ( any(TileCoord[1] != TileCoord[0]) && all(TileCoord[1] >= 0) && all(TileCoord[1] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[1]])
				{
					InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[1], BinID)], 1, SegIndex[1]);
					bTileIntersected[1] = true;
				}

				if ((bTileIntersected[0] || bTileIntersected[1]) && all(TileCoord[1] != TileCoord[0]))
				{
					float2 MP = (TileCoord[0] + float2(0.5, 0.5) + TileCoord[1] + float2(0.5, 0.5)) * 0.5 * 32;

					float2 SPI;
					SPI.x = SP0.x + (SP1.x - SP0.x) * ((MP.y - SP0.y) / (SP1.y - SP0.y));
					SPI.y = SP0.y + (SP1.y - SP0.y) * ((MP.x - SP0.x) / (SP1.x - SP0.x));

					TileCoord[2] = int2(SPI.x * RcpTileSize, SPI.y * RcpTileSize);

					if (all(TileCoord[2] >= 0) && all(TileCoord[2] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[2]])
					{
						InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[2], BinID)], 1, SegIndex[2]);
						bTileIntersected[2] = true;
					}
				}
			}
		}
		
		GroupMemoryBarrierWithGroupSync();

		if (bSegValid) //add tiles if any needed - this is unlikely to happen in all batches
		{
			for (int i = 0; i < 3; i++)
			{
				if ((SegIndex[i] != 0xffffffff) && ((SegIndex[i] % 1024)==0))
				{
					uint NewTile;
					InterlockedAdd(OutVisTileArgs[0], 1, NewTile);
					
					StoreOutVisTileData(NewTile, VT_Coord, PackVisTileCoord(TileCoord[i]));
					StoreOutVisTileData(NewTile, VT_PrimOffset, NewTile * 1024);
					StoreOutVisTileData(NewTile, VT_NearestDepth, SegIndex[i]); //tmp - use this to decide if seg should go in new or prev tile.

					uint PrevTile = (OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)] & 0xffff);
					
					if (SegIndex[i]>0)	StoreOutVisTileData(PrevTile, VT_PrimCount, 1024);

					OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)] = (PrevTile << 16) | (NewTile & 0xffff);

				}
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bSegValid) //now set the PrimID at the location indicated by the prev/current tile.
		{
			for (int i = 0; i < 3; i++)
			{
				if (SegIndex[i] != 0xffffffff)
				{
					uint PackedTiles = OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)];
					uint CurTile = (PackedTiles & 0xffff);
					uint PrevTile = ((PackedTiles >> 16) & 0xffff);

					if (SegIndex[i] >= LoadOutVisTileData(CurTile, VT_NearestDepth))
					{
						uint PrimIndex = LoadOutVisTileData(CurTile, VT_PrimOffset) + (SegIndex[i] % 1024);
						OutVisTilePrims[PrimIndex] = PrimID;

						if ((SegIndex[i] + 1) == OutVisTileBinningGrid[uint3(TileCoord[i], BinID)])
						{
							StoreOutVisTileData(CurTile, VT_PrimCount, (SegIndex[i]==1023) ? 1024 : ((SegIndex[i] + 1) % 1024));
						}
					}
					else
					{
						uint PrimIndex = LoadOutVisTileData(PrevTile, VT_PrimOffset) + (SegIndex[i] % 1024);
						OutVisTilePrims[PrimIndex] = PrimID;
					}

					//InterlockedAdd(OutVisTileArgs[1], 1); //debug
				}
			}
		}
	}
}
#endif //SHADER_RASTERCOMPUTE_BINNING

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_RASTER

RWTexture2D<uint> 					RWVisTileDepthGrid;
Buffer<uint> 						VisTilePrims;
Buffer<uint> 						VisTileArgs;
RWByteAddressBuffer					RWVisTileData;
Buffer<uint>						VisTileIndirect;

uint LoadRWVisTileData(uint index, uint offset)
{
	return RWVisTileData.Load((((index)) * VT_SIZE * 4) + ((offset) * 4));
}

void StoreRWVisTileData(uint index, uint offset, uint value)
{
	RWVisTileData.Store((((index)) * VT_SIZE * 4) + ((offset) * 4), (value));
}

RWTexture2D<uint> OutHairCountTexture;
RWTexture2D<uint> OutDepthCovTexture;
RWTexture2D<uint> OutPrimMatTexture;


groupshared uint4 group_SubTile[1024]; //(32 x 32 x 4 x 4 bytes = 16k bytes)

groupshared float3 group_PositionOffset;
groupshared float group_ooTileLODScale;

groupshared uint group_LoopNum;
groupshared uint group_TileNum;

groupshared uint group_ThreadsPerSeg;

#define GS_SEGS 320 //this number is limited by group shared memory

groupshared float4 group_SP0[GS_SEGS];
groupshared float4 group_SP1[GS_SEGS];
groupshared float group_Rad0[GS_SEGS];
groupshared float group_Rad1[GS_SEGS];
groupshared uint group_PrimMatID[GS_SEGS];

groupshared uint group_TileIndex;

[numthreads(1024, 1, 1)]
void RasterCS(uint DispatchThreadID : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID, uint GroupID : SV_GroupID)
{
	ResolvedView = ResolveView();

	if (GroupThreadID == 0)
	{
		group_TileNum = VisTileArgs[0];
		group_LoopNum = (float(group_TileNum) + float(NumRasterizers - 1))* RcpNumRasterizers;

		group_PositionOffset = HairStrandsVF_PositionOffsetBuffer[0].xyz;

		/* no longer in use - keep for ref? Moving these values to group shared memory did seem to reduce VGPRs - more experimentation needed
		group_RadScale = (((HairStrandsVF_TipScale - HairStrandsVF_RootScale) * HairStrandsVF_Radius * OutputResolutionf.x) / 63.0) / 255.0;
		group_RadOffset = (HairStrandsVF_RootScale * HairStrandsVF_Radius * OutputResolutionf.x)/63.0;
		*/
	}

	GroupMemoryBarrierWithGroupSync();

	[loop]
	for (uint LoopIndex = 0; LoopIndex < group_LoopNum; LoopIndex++)
	{
		if (GroupThreadID == 0)
		{
			group_TileIndex = LoopIndex + (GroupID * group_LoopNum);
		}
		
		GroupMemoryBarrierWithGroupSync();

		bool bTileValid = (group_TileIndex < group_TileNum) ? true : false;

		uint PrimOffset = LoadRWVisTileData(group_TileIndex, VT_PrimOffset);
		uint PrimCount = LoadRWVisTileData(group_TileIndex, VT_PrimCount);

		uint PackedCoord = LoadRWVisTileData(group_TileIndex, VT_Coord);
		uint2 SubTileMin = UppackVisTileCoord(PackedCoord)*TileSize;

		uint PackedTileMin = ((SubTileMin.x & 0xffff) << 0) | ((SubTileMin.y & 0xffff) << 16);

		if (GroupThreadID == 0)
		{
			group_ThreadsPerSeg = 1;

			if (PrimCount <= 512)
				group_ThreadsPerSeg = 2;
			if (PrimCount <= 341)
				group_ThreadsPerSeg = 3;
			if (PrimCount <= 256)
				group_ThreadsPerSeg = 4;
			if (PrimCount <= 204)
				group_ThreadsPerSeg = 5;
			if (PrimCount <= 170)
				group_ThreadsPerSeg = 6;
			if (PrimCount <= 146)
				group_ThreadsPerSeg = 7;
			if (PrimCount <= 128)
				group_ThreadsPerSeg = 8;
			if (PrimCount <= 64)
				group_ThreadsPerSeg = 16;
			if (PrimCount <= 32)
				group_ThreadsPerSeg = 32;
		}
		
		GroupMemoryBarrierWithGroupSync();

		bool bThreadValid = (bTileValid && (GroupThreadID < (PrimCount*group_ThreadsPerSeg) )) ? true : false;

		uint WaveCount = ((PrimCount* group_ThreadsPerSeg) + (WAVE_SIZE-1) ) / WAVE_SIZE;
		uint WaveThreadCount = WaveCount * WAVE_SIZE;

		bool bWaveThreadValid = (bTileValid && (GroupThreadID < WaveThreadCount)) ? true : false;

		bool bUseGroupSPs = (bThreadValid && (GroupThreadID < (min(PrimCount, GS_SEGS)* group_ThreadsPerSeg) )) ? true : false;

		bool bGenGroupSPs = (bThreadValid && (GroupThreadID < (min(PrimCount, GS_SEGS)) )) ? true : false;

		if (bGenGroupSPs)
		{
			uint Prim = GroupThreadID;
			uint PrimID = VisTilePrims[PrimOffset + Prim];

			group_PrimMatID[Prim] = PackHairVisPrimitiveMaterialId(PrimID, HairMaterialId);

			CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID], group_PositionOffset, group_SP0[Prim], group_Rad0[Prim]);
			CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID+1], group_PositionOffset, group_SP1[Prim], group_Rad1[Prim]);
		}

		if (bWaveThreadValid)
		{
			for (uint LinearIndex = GroupThreadID; LinearIndex < SqrTileSize; LinearIndex += WaveThreadCount)
			{
				uint2 Coord;

				Coord.y = (float(LinearIndex) + 0.5) * RcpTileSize;
				Coord.x = LinearIndex - (Coord.y * TileSize);

				Coord += uint2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				group_SubTile[LinearIndex].x = OutDepthCovTexture[Coord];
				group_SubTile[LinearIndex].y = 0;
				group_SubTile[LinearIndex].z = 0;
				group_SubTile[LinearIndex].w = PackHairVisDepthCoverage(SceneDepthTexture.Load(uint3(Coord, 0)), 1.0);
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bThreadValid)
		{
			uint Prim = uint((float(GroupThreadID)+0.5) / float(group_ThreadsPerSeg));
			uint PModTPS = GroupThreadID - (Prim * group_ThreadsPerSeg);

			uint PrimMatID;
			float4 SP0;
			float4 SP1;
			float Rad0;
			float Rad1;

			if (bUseGroupSPs)
			{
				PrimMatID = group_PrimMatID[Prim];
				SP0 = group_SP0[Prim];
				SP1 = group_SP1[Prim];
				Rad0 = group_Rad0[Prim];
				Rad1 = group_Rad1[Prim];
			}
			else
			{
				uint PrimID = VisTilePrims[PrimOffset + Prim];
				PrimMatID = PackHairVisPrimitiveMaterialId(PrimID, HairMaterialId);

				CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID], group_PositionOffset, SP0, Rad0);
				CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID+1], group_PositionOffset, SP1, Rad1);
			}

			uint NumSteps = min(max(abs(SP1.x - SP0.x), abs(SP1.y - SP0.y))+1.0, TileSize);

			[loop]
			for (int J = PModTPS; J < NumSteps; J+=group_ThreadsPerSeg)
			{
				const float4 SP = lerp(SP0, SP1, J / float(NumSteps));

				const int2 SPi = int2(SP.xy)-int2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				if (SPi.x >= 0 && SPi.x < TileSize && SPi.y >= 0 && SPi.y < TileSize)
				{
					uint PackedDepthCov = PackHairVisDepthCoverage(SP.z / SP.w, 1.0);

					uint LinearIndex = SPi.x + SPi.y * TileSize;

					uint OldValue;
					InterlockedMax(group_SubTile[LinearIndex].x, PackedDepthCov, OldValue);
					if (PackedDepthCov > OldValue)
					{
						group_SubTile[LinearIndex].y = PrimMatID;
					}

					if (PackedDepthCov > group_SubTile[LinearIndex].w)
					{
						const float Rad = lerp(Rad0, Rad1, J / float(NumSteps)) / SP.w;

						InterlockedAdd(group_SubTile[LinearIndex].z, min(Rad, 0.5) * 2.0 * 1000.0 * SampleWeight);
					}
				}					
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bWaveThreadValid) 
		{
			for (uint LinearIndex = GroupThreadID; LinearIndex < SqrTileSize; LinearIndex += WaveThreadCount)
			{
				uint2 Coord;

				Coord.y = (float(LinearIndex) + 0.5) * RcpTileSize;
				Coord.x = LinearIndex - (Coord.y * TileSize);

				Coord += uint2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				if (group_SubTile[LinearIndex].y != 0)
				{
					uint oldValue;
					InterlockedMax(OutDepthCovTexture[Coord], group_SubTile[LinearIndex].x, oldValue);
					if (group_SubTile[LinearIndex].x > oldValue)
					{
						OutPrimMatTexture[Coord] = group_SubTile[LinearIndex].y;
					}
				}
				InterlockedAdd(OutHairCountTexture[Coord], group_SubTile[LinearIndex].z);
			}
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

#endif //SHADER_RASTERCOMPUTE_RASTER

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_DEBUG

#include "../ShaderPrint.ush"
void PrintBool(inout FShaderPrintContext Ctx, bool In)
{
	if (In)
	{
		Print(Ctx, TEXT("Yes"), FontGreen);
	}
	else
	{
		Print(Ctx, TEXT("No"), FontRed);
	}
}

Texture2D<uint>						VisTileDepthGrid;
Texture3D<uint> 					VisTileBinningGrid;
//Buffer<uint>						OutVisTilePrims;
Buffer<uint>						VisTileArgs;
//ByteAddressBuffer					OutVisTileData;

uint MacroGroupId;
uint PrimitiveInfoIndex;
uint TotalPrimitiveInfoCount;

#define TilePrintOffset (TileSize >> 1)

float4 Transparent(float4 Color) { return float4(Color.xyz, 0.5f); }

uint GetTileTotalSegment(uint2 TileCoord, bool bPrintDetails)
{
	const float TileDisplayScale = 1.5f;
	const uint DisplayTileSize = TileSize * TileDisplayScale;
	uint2 InlinedTileCoord = uint2(0, 0);

	uint TotalSegments = 0;
	const uint BinCount = NumBinners;// * 2; // Each binner fill in 2 bins, see binning algo.
	for (uint BinIt = 0; BinIt < BinCount; ++BinIt)
	{
		const uint CurrTileSegments = VisTileBinningGrid.Load(uint4(TileCoord, BinIt, 0));
		TotalSegments += CurrTileSegments;

		if (bPrintDetails)
		{
			AddFilledQuadSS(InlinedTileCoord * DisplayTileSize, (InlinedTileCoord + 1) * DisplayTileSize, CurrTileSegments > 0 ? Transparent(ColorLightGreen) : Transparent(ColorLightRed));
			AddQuadSS(InlinedTileCoord * DisplayTileSize, (InlinedTileCoord + 1) * DisplayTileSize, ColorYellow);

			FShaderPrintContext Context = InitShaderPrintContext(true, InlinedTileCoord * DisplayTileSize + TilePrintOffset);
			Print(Context, CurrTileSegments, FontWhite);
			++InlinedTileCoord.x;

			// Span details onto 2 lines
			if (BinIt == NumBinners-1)
			{
				InlinedTileCoord.x = 0;
				++InlinedTileCoord.y;
			}
		}
	}
	return TotalSegments;
}

void PrintTile(uint2 TileCoord, uint TotalSegments, bool bPrintText)
{
	AddFilledQuadSS(TileCoord * TileSize, (TileCoord + 1) * TileSize, TotalSegments > 0 ? Transparent(ColorLightGreen) : Transparent(ColorLightRed));
	if (bPrintText)
	{
		FShaderPrintContext Context = InitShaderPrintContext(true, TileCoord * TileSize + uint2(0, TileSize * 1.5f));
		Print(Context, TotalSegments, FontWhite);

		AddQuadSS(TileCoord * TileSize, (TileCoord + 1) * TileSize, ColorYellow);
	}
}

[numthreads(8, 8, 1)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{
	// Info/Stats
	if (all(ThreadId == 0))
	{
		FShaderPrintContext Context = InitShaderPrintContext(true, uint2(50, 110));
		Print(Context, TEXT("Raster compute         "), FontYellow); Newline(Context);
		Print(Context, TEXT("Macro Group Id       : "), FontSilver); Print(Context, MacroGroupId, FontWhite); Newline(Context);
		Print(Context, TEXT("Primitive Info       : "), FontSilver); Print(Context, PrimitiveInfoIndex, FontWhite, 2, 0); Print(Context, TEXT("/"), FontSilver); Print(Context, TotalPrimitiveInfoCount, FontWhite, 2, 0); Newline(Context);
		Newline(Context);

		Print(Context, TEXT("Configuration          "), FontYellow); Newline(Context);
		Print(Context, TEXT("Output Resolution    : "), FontSilver); Print(Context, OutputResolution, FontWhite); Newline(Context);
		Print(Context, TEXT("Resolution Multiplier: "), FontSilver); Print(Context, ResolutionMultiplier, FontWhite); Newline(Context);
		Newline(Context);
		
		Print(Context, TEXT("Tile Size            : "), FontSilver); Print(Context, TileSize, FontWhite); Newline(Context);
		Print(Context, TEXT("Tile Res             : "), FontSilver); Print(Context, TileRes.x, FontWhite, 2, 0); Print(Context, TEXT("x"), FontSilver); Print(Context, TileRes.y, FontWhite, 2, 0); Newline(Context);
		Newline(Context);
		
		Print(Context, TEXT("Num Binners          : "), FontSilver); Print(Context, NumBinners, FontWhite); Newline(Context);
		Print(Context, TEXT("Num Rasterizers      : "), FontSilver); Print(Context, NumRasterizers, FontWhite); Newline(Context);
		Print(Context, TEXT("Max Raster Count     : "), FontSilver); Print(Context, MaxRasterCount, FontWhite); Newline(Context);
		Newline(Context);

		Print(Context, TEXT("Allocated Tile Count : "), FontSilver); Print(Context, VisTileArgs[0], FontWhite); Newline(Context);
		

	}

	// Cursor info	
	if (all(ThreadId == 0) && all(ShaderPrintData.CursorCoord >= 0))
	{
		const uint2 PixelCoord = ShaderPrintData.CursorCoord;
		const uint2 TileCoord  = PixelCoord >> TileSizeAsShift;
	
		const uint TotalSegments = GetTileTotalSegment(TileCoord, true);
		PrintTile(TileCoord, TotalSegments, true);
	}

	// All tile
	{
		const uint2 TileCoord = ThreadId.xy;
		const uint TotalSegments = GetTileTotalSegment(TileCoord, false);
		if (TotalSegments)
		{
			PrintTile(TileCoord, TotalSegments, false);
		}
	}
}
#endif //SHADER_RASTERCOMPUTE_RASTER

