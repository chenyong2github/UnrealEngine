// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once


// VOXEL_TRAVERSAL_TYPE needs to be defined for selecting which type of traversal needs to be used
// Definition of traversal types are defined in HairStrandsVoxelPageCommon.ush
#ifndef VOXEL_TRAVERSAL_TYPE
#define VOXEL_TRAVERSAL_TYPE VOXEL_TRAVERSAL_NONE
#endif

#ifndef VOXEL_TRAVERSAL_DEBUG
#define VOXEL_TRAVERSAL_DEBUG 0
#else
#include "../ShaderDrawDebug.ush"
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if VOXEL_TRAVERSAL_DEBUG 
void AddLine(bool bEnabled, float3 P0, float3 P1)
{
	if (!bEnabled)
		return;
	const float4 DebugColor = float4(1, 1, 0, 1);
	AddLine(P0, P1, DebugColor, DebugColor);
}

void AddMacroGroupAABB(bool bEnabled, float3 P0, float3 P1)
{
	if (!bEnabled)
		return;
	AddAABB(P0, P1, float4(1, 0, 1, 1));
}

void AddPageAABB(bool bEnabled, float3 P0, float3 P1, bool bIsPageValid)
{
	if (!bEnabled)
		return;
	const float4 DebugColor = bIsPageValid ? float4(0, 1, 1, 1) : float4(1, 0, 0, 1);
	AddAABB(P0, P1, DebugColor);
}

void AddStepAABB(bool bEnabled, float3 P0, float3 P1, float3 Color)
{
	if (!bEnabled)
		return;
	const float4 DebugColor = float4(Color, 1);
	AddAABB(P0, P1, DebugColor);
}

void AddAABBVolume(bool bEnabled, float3 P0, float3 P1)
{
	if (!bEnabled)
		return;
	const float4 DebugColor = float4(1,1,0, 1);
	AddAABB(P0, P1, DebugColor);
}

#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ShouldStopTraversal(const FHairTraversalResult InResult, float InHairCountThreshold)
{
	// Change this function once we have better result/control over the opaque filtering
	return InResult.Visibility == 0 || (InHairCountThreshold != 0 && InResult.HairCount > InHairCountThreshold);
}

float3 GetHairVoxelJitter(uint2 PixelCoord, uint Seed)
{
	return float3(
		InterleavedGradientNoise(PixelCoord.xy, Seed),
		InterleavedGradientNoise(PixelCoord.xy, Seed * 117),
		InterleavedGradientNoise(PixelCoord.xy, Seed * 7901));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Non-Sparse voxel traversal routines
#if VOXEL_TRAVERSAL_TYPE ==  VOXEL_TRAVERSAL_LEGACY
FHairTraversalResult ComputeHairCountVoxel(
	float3 WorldPosition0,
	float3 WorldPosition1,
	float3 InVoxelAABBMin,
	float3 InVoxelAABBMax,
	float InVoxelResolution,
	Texture3D<uint> InDensityTexture,
	float DensityScale,
	float CountThreshold,
	float DistanceThreshold)
{
	FHairTraversalResult Out = InitHairTraversalResult();

	const float3 VolumeBoundSize = InVoxelAABBMax - InVoxelAABBMin;
	const float3 VolumeBoundSizeInv = 1.0f / (InVoxelAABBMax - InVoxelAABBMin);
	const float VoxelWorldSize = VolumeBoundSize.x / InVoxelResolution;				// Only using voxel size along x for now...

	const float2 HitT = LineBoxIntersect(WorldPosition0, WorldPosition1, InVoxelAABBMin, InVoxelAABBMax);
	if (HitT.x < HitT.y)
	{
		// Count the number of fibers which are within a cylinder defined by the voxel size, 
		// and the distance between the origin and the extent of the volume
		// This assumes that the voxel volume is cubic (i.e. equal dimensions on all sides)
		float3 O = lerp(WorldPosition0, WorldPosition1, HitT.xxx);
		float3 E = lerp(WorldPosition0, WorldPosition1, HitT.yyy);
		const float OELength = min(length(E - O), DistanceThreshold);

		// Step according to voxel size
		const float StepCount = float(min(ceil(OELength / VoxelWorldSize), 256u));	// TO TRY: sample with fixed count budget and jitter temporally
		const float3 D = normalize(WorldPosition1 - WorldPosition0) * VoxelWorldSize;

		for (float StepIt = 0.0f; StepIt < StepCount; ++StepIt)
		{
			const float3 HitP = O + StepIt * D;
			const float3 UVW = (HitP - InVoxelAABBMin) * VolumeBoundSizeInv;
			const int3 VolumeCoord = clamp(int3(UVW * InVoxelResolution), int3(0, 0, 0), int3(InVoxelResolution.xxx - 1));
			const FHairTraversalResult StepResult = GetHairVoxelDensity(VolumeCoord, InDensityTexture, 0, DensityScale);
			Acc(Out, StepResult);

			if (ShouldStopTraversal(Out, CountThreshold))
				return Out;
		}
	}

	return Out;
}

FHairTraversalResult ComputeHairCountVoxelCone(
	float3 WorldPosition0,
	float3 WorldPosition1,
	float3 InVoxelAABBMin,
	float3 InVoxelAABBMax,
	float InVoxelResolution,
	Texture3D<uint> InDensityTexture,
	float InVoxelDensityScale,
	float CountThreshold,
	float DistanceThreshold,
	float TanConeAngle)
{
	FHairTraversalResult Out = InitHairTraversalResult();

	// Reverse-Z
	const float ConservativeAABBDiagonal = (InVoxelAABBMax.x - InVoxelAABBMin.x) * 3;
	const float3 O = WorldPosition0;
	const float3 E = WorldPosition1;
	const float3 D = E - O;
	const float3 NormD = normalize(D);

	// The rest of the code assumes O is within the AABB
	const bool bIsInAABB = IsInVoxelBounds(O, InVoxelAABBMin, InVoxelAABBMax);
	if (!bIsInAABB)
		return Out;

	const float2 HitT = LineBoxIntersect(O, E, InVoxelAABBMin, InVoxelAABBMax);
	if (HitT.x < HitT.y)
	{
		const float VolumeSize = (InVoxelAABBMax.x - InVoxelAABBMin.x);
		const float VoxelSize = VolumeSize / InVoxelResolution;

		// Count the number of fibers which are within a cylinder defined by the voxel size, 
		// and the distance between the origin and the extent of the volume
		// This assumes that the voxel volume is cubic (i.e. equal dimensions on all sides)
		const float DistanceThreshold2 = DistanceThreshold * DistanceThreshold;
		const float Distance = min(DistanceThreshold, length(HitT.y * D));
		const uint MaxStepCount = min(ceil(Distance / VoxelSize), 256u);
		float T = 0;
		float MipLevel = 0;
		float MipDensityScale = 1;
		for (uint StepIt = 0; StepIt < MaxStepCount; ++StepIt)
		{
			float3 StepOffset = 0;

			const float3 RaymarchOffset = T * NormD;
			const float3 HitP = O + RaymarchOffset + StepOffset;
			const float3 UVW = (HitP - InVoxelAABBMin) / (InVoxelAABBMax - InVoxelAABBMin);

			const float Distance2 = dot(RaymarchOffset, RaymarchOffset);
			if (Distance2 > DistanceThreshold2)
				return Out;

			if (!IsInVoxelBounds(UVW, 0, 1))
				return Out;

			const uint MipVoxelResolution = uint(InVoxelResolution) >> uint(MipLevel);
			const int3 VolumeCoord = clamp(int3(UVW * MipVoxelResolution), int3(0, 0, 0), int3(MipVoxelResolution.xxx - 1));
			const FHairTraversalResult StepResult = GetHairVoxelDensity(VolumeCoord, InDensityTexture, MipLevel, InVoxelDensityScale * MipDensityScale);
			Acc(Out, StepResult);

			if (ShouldStopTraversal(Out, CountThreshold))
				return Out;

			const float VoxelRadius = T * TanConeAngle;
			const float NumVoxel = VolumeSize / max(2 * VoxelRadius, VoxelSize);

			const float ResolutionBias = InVoxelResolution / NumVoxel;
			float MipBias = log2(max(0.5f, ResolutionBias));
			MipBias = floor(MipBias);
			MipLevel = MipBias;

			const float MipVoxelSize = VoxelSize * (MipLevel + 1);
			{
				MipDensityScale = VoxelSize * rcp(MipVoxelSize);
				MipDensityScale = MipDensityScale * MipDensityScale * MipDensityScale;
			}
			T += MipVoxelSize;
		}
	}

	return Out;
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct FHairTraversalSettings
{
	float	DensityScale;
	float	CountThreshold;
	float	DistanceThreshold;
	float	SteppingScale;		// Rate at which the raymarching step increase
	float3	Random;
	float	TanConeAngle;
	bool	bDebugEnabled;
};

FHairTraversalSettings InitHairTraversalSettings()
{
	FHairTraversalSettings Out;
	Out.DensityScale = 1;
	Out.CountThreshold = 0;
	Out.DistanceThreshold = 100000.f;
	Out.SteppingScale = 1;
	Out.Random = 0.5f;
	Out.TanConeAngle = 0;
	Out.bDebugEnabled = false;
	return Out;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sparse voxel traversal routines
FHairTraversalResult ComputeHairCountVirtualVoxel(
	float3 WorldPosition0,
	float3 WorldPosition1,
	FVirtualVoxelCommonDesc InCommonDesc,
	FVirtualVoxelNodeDesc InNodeDesc,
	Buffer<uint> InPageIndexBuffer,
	Texture3D<uint> InPageTexture,
	FHairTraversalSettings InSettings)
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_NONE
{
	Error: VOXEL TRAVERSAL TYPE is undefined
}
#endif
#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_LEGACY
; // This function is never used. When VOXEL_TRAVERSAL_LEGACY is defined, the old traversal (with plain voxel) is used instead
#endif
#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_LINEAR || VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_LINEAR_MIPMAP
{
	const float MipLevelDistanceScale = 1.0f / InCommonDesc.VoxelWorldSize;

	FHairTraversalResult Out = InitHairTraversalResult();

	int3 CurrentPageIndexCoord = -1;
	bool bIsPageValid = false;
	uint3 PageCoord = 0;

	const float2 HitT = LineBoxIntersect(WorldPosition0, WorldPosition1, InNodeDesc.MinAABB, InNodeDesc.MaxAABB);
	if (HitT.x < HitT.y)
	{
		// Count the number of fibers which are within a cylinder defined by the voxel size, 
		// and the distance between the origin and the extent of the volume
		// This assumes that the voxel volume is cubic (i.e. equal dimensions on all sides)
		const float3 O = lerp(WorldPosition0, WorldPosition1, HitT.xxx);
		const float3 E = lerp(WorldPosition0, WorldPosition1, HitT.yyy);
		const float OELength = min(length(E - O), InSettings.DistanceThreshold);
		#if VOXEL_TRAVERSAL_DEBUG
		if (InSettings.bDebugEnabled)
		{
			AddLine(true, O, E);
			AddAABBVolume(true, InNodeDesc.MinAABB, InNodeDesc.MaxAABB);
		}
		#endif

		// Step according to voxel size
		const float3 D = normalize(E - O) * InCommonDesc.VoxelWorldSize;
		const float MaxStep = float(min(ceil(OELength / InCommonDesc.VoxelWorldSize), 1024u));
		const float DeltaWorld = OELength / float(MaxStep);
		float StepScale = 1.0f;
		float3 PreviousP = O;

		const float3 RandomStepJitter = InSettings.Random.xyz * 2 - 1; // [-1..1]
		for (float StepIt = 0.0f; StepIt < MaxStep; StepIt += StepScale)
		{
			const float SteppingWorldSize = max(DeltaWorld * StepScale, InSettings.TanConeAngle * StepIt * InCommonDesc.VoxelWorldSize);
			const float3 HitP = O + StepIt * D + RandomStepJitter * SteppingWorldSize * 0.5f;

			#if VOXEL_TRAVERSAL_DEBUG
			AddStepAABB(InSettings.bDebugEnabled, PreviousP, HitP, float3(0, 1, 0));
			#endif

			const int3 VolumeCoord = PositionToCoord(HitP, InNodeDesc.MinAABB, InNodeDesc.MaxAABB, InNodeDesc.VirtualResolution);
			const int3 PageIndexCoord = VolumeCoord / InCommonDesc.PageResolution;

			// Update page index only when needed
			if (PageIndexCoord.x != CurrentPageIndexCoord.x ||
				PageIndexCoord.y != CurrentPageIndexCoord.y ||
				PageIndexCoord.z != CurrentPageIndexCoord.z)
			{
				CurrentPageIndexCoord = PageIndexCoord;
				const uint LinearPageIndexCoord = CoordToIndex(PageIndexCoord, InNodeDesc.PageIndexResolution, InNodeDesc.PageIndexOffset);
				const uint PageIndex = InPageIndexBuffer.Load(LinearPageIndexCoord);

				bIsPageValid = PageIndex != INVALID_VOXEL_PAGE_INDEX;
				if (bIsPageValid)
				{
					PageCoord = IndexToCoord(PageIndex, InCommonDesc.PageCountResolution);
				}
			}

			if (bIsPageValid)
			{
				const int3 VoxelPageBase = PageCoord * InCommonDesc.PageResolution;
				const int3 VoxelPageOffset = VolumeCoord - PageIndexCoord * InCommonDesc.PageResolution;
				const int3 VoxelPageCoord = VoxelPageBase + VoxelPageOffset;
				float HairCountScale = 1;
				float MipLevel = 0.0f;
				#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_LINEAR_MIPMAP
				HairCountScale = SteppingWorldSize * MipLevelDistanceScale;
				MipLevel = log2(SteppingWorldSize * MipLevelDistanceScale);
				#endif

				const FHairTraversalResult StepResult = GetHairVirtualVoxelDensity(VoxelPageCoord, InPageTexture, uint(MipLevel), InSettings.DensityScale * HairCountScale);
				Acc(Out, StepResult);

				#if VOXEL_TRAVERSAL_DEBUG
				if (InSettings.bDebugEnabled)
				{
					const float3 WorldOffset = PageIndexCoord * InCommonDesc.PageResolution * InCommonDesc.VoxelWorldSize;
					const float MipVoxelWorldSize = InCommonDesc.VoxelWorldSize * InCommonDesc.PageResolution / (InCommonDesc.PageResolution >> uint(MipLevel));

					const uint3 MinCoord = VoxelPageOffset >> uint(MipLevel);
					const uint3 MaxCoord = MinCoord+1;
					const float3 FetchMinAABB = InNodeDesc.MinAABB + WorldOffset + MinCoord * MipVoxelWorldSize;
					const float3 FetchMaxAABB = InNodeDesc.MinAABB + WorldOffset + MaxCoord * MipVoxelWorldSize;
					AddStepAABB(true, FetchMinAABB, FetchMaxAABB, StepResult.Visibility > 0.5f ? float3(0, 0.5f, 1) : float3(1, 0.5f, 0));
				}
				#endif

				if (ShouldStopTraversal(Out, InSettings.CountThreshold))
					return Out;
			}
			#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_LINEAR_MIPMAP
			StepScale = min(InCommonDesc.PageResolution, StepScale * InSettings.SteppingScale);
			#endif
			PreviousP = HitP;
		}

	}

	return Out;
}
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_SPARSE_LINEAR || VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_SPARSE_MIPMAP
{
	FHairTraversalResult Out = InitHairTraversalResult();

	int3 CurrentPageIndexCoord = -1;
	bool bIsPageValid = false;
	uint3 PageCoord = 0;

	#if VOXEL_TRAVERSAL_DEBUG
	AddMacroGroupAABB(InSettings.bDebugEnabled, InNodeDesc.MinAABB, InNodeDesc.MaxAABB);
	AddLine(InSettings.bDebugEnabled, WorldPosition0, WorldPosition1);
	#endif

	const float2 HitT = LineBoxIntersect(WorldPosition0, WorldPosition1, InNodeDesc.MinAABB, InNodeDesc.MaxAABB);
	if (HitT.x < HitT.y)
	{
		// Count the number of fibers which are within a cylinder defined by the voxel size, 
		// and the distance between the origin and the extent of the volume
		// This assumes that the voxel volume is cubic (i.e. equal dimensions on all sides)
		const float3 O = WorldPosition0; // lerp(WorldPosition, IntersectEndPoint, HitT.xxx);
		const float3 E = WorldPosition1; // lerp(WorldPosition, IntersectEndPoint, HitT.yyy);
		const float OELength = min(length(E - O), InSettings.DistanceThreshold);

	
		// Init to 1 or -1 depending of the orientation of stepping
		const float3 UNormD = WorldPosition1 - WorldPosition0;
		const int3 Step = sign(UNormD);

		// Step according to voxel size
		const float3 D = normalize(UNormD) * InCommonDesc.VoxelWorldSize;

		float t = HitT.x;

		// this is slop coeff for each axis: how far we need to move in units of t for each axis
		const float PageWorldSize = InCommonDesc.PageResolution * InCommonDesc.VoxelWorldSize;
		const float3 tDelta = Step * PageWorldSize / UNormD;

		// Init to the starting voxel
		int3 PageIndexCoord = -1;
		float3 tMax = 0;
		{
			const float3 HitP = O + HitT.x * UNormD;

			const float Epsilon = 0.000001f;
			const float3 Coords = clamp(
				saturate((HitP - InNodeDesc.MinAABB) / (InNodeDesc.MaxAABB - InNodeDesc.MinAABB)) * InNodeDesc.PageIndexResolution,
				0,
				InNodeDesc.PageIndexResolution - Epsilon);

			const float3 FractCoords = max(Step, 0) - Step * frac(Coords);
			tMax = FractCoords * tDelta;

			PageIndexCoord = clamp(int3(Coords), uint3(0, 0, 0), InNodeDesc.PageIndexResolution-1);
		}

		// Page stepping is the walking quantity (i.e. number of voxel) for fine ray-marching within a valid page
		float PageStepping = 1;

		const uint LoopCount = 256u;
		for (uint LoopIt = 0; LoopIt < LoopCount; ++LoopIt)
		{
			const bool bIsInside =
				PageIndexCoord.x >= 0 && 
				PageIndexCoord.y >= 0 && 
				PageIndexCoord.z >= 0 &&
				PageIndexCoord.x < int(InNodeDesc.PageIndexResolution.x) && 
				PageIndexCoord.y < int(InNodeDesc.PageIndexResolution.y) && 
				PageIndexCoord.z < int(InNodeDesc.PageIndexResolution.z);
			if (!bIsInside)
			{
				return Out;
			}

			const uint LinearPageIndexCoord = CoordToIndex(PageIndexCoord, InNodeDesc.PageIndexResolution, InNodeDesc.PageIndexOffset);
			const uint PageIndex = InPageIndexBuffer.Load(LinearPageIndexCoord);

			const bool bIsPageValid = PageIndex != INVALID_VOXEL_PAGE_INDEX;
			#if VOXEL_TRAVERSAL_DEBUG
			{
				const float3 PageMinAABB = PageIndexCoord * InCommonDesc.PageResolution * InCommonDesc.VoxelWorldSize + InNodeDesc.MinAABB;
				const float3 PageMaxAABB = (PageIndexCoord+float3(1,1,1)) * InCommonDesc.PageResolution * InCommonDesc.VoxelWorldSize + InNodeDesc.MinAABB;
				AddPageAABB(InSettings.bDebugEnabled, PageMinAABB, PageMaxAABB, bIsPageValid);
			}
			#endif

			if (bIsPageValid)
			{
				const uint3 PageCoord = IndexToCoord(PageIndex, InCommonDesc.PageCountResolution);

				float3 InnerO = O + t * UNormD;
				const uint MaxInnerStep = InCommonDesc.PageResolution * 1.75f; // ~ Diagonal step count

				#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_SPARSE_LINEAR
				const uint IntPageStepping = 1;
				const uint MipLevel = 0;
				#endif			

				#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_SPARSE_MIPMAP
				const uint IntPageStepping = uint(PageStepping);
				const uint MipLevel = log2(IntPageStepping);
				#endif

				const uint MipPageResolution = InCommonDesc.PageResolution;
				const int3 VoxelPageBase = PageCoord * MipPageResolution;

				for (uint InnerStepIt = 0; InnerStepIt < MaxInnerStep; InnerStepIt += IntPageStepping)
				{
					const float3 InnerHitP = InnerO + D * InnerStepIt;
					const int3 VolumeCoord = PositionToCoordUnclampled(InnerHitP, InNodeDesc.MinAABB, InNodeDesc.MaxAABB, InNodeDesc.VirtualResolution);
					const int3 VoxelPageOffset = VolumeCoord - PageIndexCoord * InCommonDesc.PageResolution;

					#if VOXEL_TRAVERSAL_DEBUG
					if (InSettings.bDebugEnabled)
					{
						if (InnerStepIt==0)
							AddStepAABB(InSettings.bDebugEnabled, InnerHitP - D * 2, InnerHitP + D*2, float3(0,1,0));
						else
							AddStepAABB(InSettings.bDebugEnabled, InnerHitP, InnerHitP + D, float3(1, 0, 1));
					}
					#endif

					const bool bIsInsideInner =
						VoxelPageOffset.x >= 0 && 
						VoxelPageOffset.y >= 0 && 
						VoxelPageOffset.z >= 0 &&
						VoxelPageOffset.x < int(MipPageResolution) &&
						VoxelPageOffset.y < int(MipPageResolution) &&
						VoxelPageOffset.z < int(MipPageResolution);
					if (!bIsInsideInner)
					{
						break;
					}

					const int3 VoxelPageCoord = VoxelPageBase + VoxelPageOffset;

					#if VOXEL_TRAVERSAL_DEBUG
					{
						const float VoxelExtent = InCommonDesc.VoxelWorldSize * (1 << MipLevel) * 0.5f;
						const float3 P = (PageIndexCoord*InCommonDesc.PageResolution + VoxelPageOffset) * InCommonDesc.VoxelWorldSize + InNodeDesc.MinAABB;
						AddStepAABB(InSettings.bDebugEnabled, P - VoxelExtent, P + VoxelExtent, float3(0, 0.5f, 1));
					}
					#endif

					const FHairTraversalResult StepResult = GetHairVirtualVoxelDensity(VoxelPageCoord, InPageTexture, MipLevel, InSettings.DensityScale);
					Acc(Out, StepResult);

					if (ShouldStopTraversal(Out, InSettings.CountThreshold))
					{
						#if VOXEL_TRAVERSAL_DEBUG
						AddStepAABB(InSettings.bDebugEnabled, InnerHitP - D * 2, InnerHitP + D * 2, float3(1, 0.25f, 0));
						#endif
						return Out;
					}
				}
			}

			#if VOXEL_TRAVERSAL_TYPE == VOXEL_TRAVERSAL_SPARSE_MIPMAP
			// Increase the stepping size as we walk away from the start point. 
			// Hypothesis: 
			// * don't increase the stepping too soon as we might miss important closeby details
			// * don't increase too much the stepping other wise we will miss important thing or look too coarse
			PageStepping = clamp(PageStepping += 0.5f, 1.f, 8.f);
			#endif		

			// t is used for defining the intersection point at the entry of a valid page
			t = min(tMax.x, min(tMax.y, tMax.z));

			// Find the next page indx to visit and update the tmax, accordingly
			const float3 Mask = tMax.x < tMax.y ?
				(tMax.x < tMax.z ? float3(1, 0, 0) : float3(0, 0, 1)) :
				(tMax.y < tMax.z ? float3(0, 1, 0) : float3(0, 0, 1));
			PageIndexCoord += Step * Mask;
			tMax += tDelta * Mask;
			
			const float3 NewDelta = tDelta * Mask;
		}
	}


	return Out;
}
#endif