// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneTexturesCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "HairStrandsVisibilityCommon.ush"

// Manual binding of the sample data as the uniform buffer is not created at this point
Texture2D<float>					CoverageTexture;
Texture2D<uint>						HairSampleOffset;
StructuredBuffer<FPackedHairSample> HairSampleData;

float ExtractClosestDeviceZ(uint3 PixelCoord)
{
	float Out = 0; // Inverse-Z

	const FNodeDesc NodeDesc = DecodeNodeDesc(HairSampleOffset.Load(PixelCoord));
	LOOP
	for (uint SampleIt = 0; SampleIt < NodeDesc.Count; SampleIt++)
	{
		const uint SampleIndex = NodeDesc.Offset + SampleIt;
		const FHairSample Sample = UnpackHairSample(HairSampleData[SampleIndex]);
		Out = max(Out, Sample.Depth); // Inverse-Z
	}
	return Out;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if PERMUTATION_OUTPUT_TYPE == 0
void MainPS(
	in FScreenVertexOutput Input,
	out float SvDepth		: SV_DEPTH,
	out float4 OutGBufferB	: SV_Target0,
	out float4 OutGBufferC	: SV_Target1,
	out float4 OutColor		: SV_Target2
)
{
	const uint3 PixelCoord = uint3(Input.Position.xy, 0);
	const float Coverage = CoverageTexture.Load(PixelCoord);
	if (Coverage < 1.0f)
	{
		discard;
	}

	// Add a depth bias in order to avoid precision issue during the composition pass, which would reject certain samples.
	// This depth is only used for screen passes like AO/SSGI/... so no need to be very accurate
	const float DepthBias = 0.001f; 
	const float DeviceZ = ExtractClosestDeviceZ(PixelCoord);
	SvDepth = DeviceZ - DepthBias;
	OutGBufferB = float4(0, 0, 0, 0); // EncodeShadingModelIdAndSelectiveOutputMask(SHADINGMODELID_HAIR, 0)
	OutGBufferC = 0;
	OutColor = 0;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if PERMUTATION_OUTPUT_TYPE == 1
uint bClear;
void MainPS(
	in FScreenVertexOutput Input,
	out float SvDepth : SV_DEPTH)
{
	SvDepth = 0; // Inverse-Z
	if (bClear == 0)
	{
		SvDepth = ExtractClosestDeviceZ(uint3(Input.Position.xy, 0));
	}
}
#endif