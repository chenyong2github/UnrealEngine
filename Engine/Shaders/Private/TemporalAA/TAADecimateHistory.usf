// Copyright Epic Games, Inc. All Rights Reserved.

#include "TAACommon.ush"


//------------------------------------------------------- CONFIG

#define TILE_SIZE 8

#define CONFIG_KERNEL 0

#define CONFIG_OUTPUT_HALF_RES (DIM_OUTPUT_HALF_RES)


//------------------------------------------------------- PARAMETERS

float4x4 RotationalClipToPrevClip;
float3 OutputQuantizationError;
float HistoryPreExposureCorrection;

Texture2D<taa_half3> InputSceneColorTexture;
Texture2D<float2> DilatedVelocityTexture;
Texture2D<float> ClosestDepthTexture;
Texture2D<uint> PrevUseCountTexture;
Texture2D<uint> PrevClosestDepthTexture;
Texture2D<uint> ParallaxFactorTexture;

Texture2D<taa_half3> PrevHistory_Textures_0;
Texture2D<taa_half3> PrevHistory_Textures_1;
Texture2D<taa_half2> PrevHistory_Textures_2;
Texture2D<uint>      PrevHistory_Textures_3;
Texture2D<taa_half>  PrevHistory_LowResTextures_0;

RWTexture2D<taa_half3> HalfResSceneColorOutput;
RWTexture2D<taa_half3> HalfResPredictionSceneColorOutput;
RWTexture2D<taa_half> HalfResParallaxRejectionMaskOutput;

RWTexture2D<taa_half3> PredictionSceneColorOutput;
RWTexture2D<taa_half> ParallaxRejectionMaskOutput;
RWTexture2D<taa_half4> InterferenceSeedOutput;


//------------------------------------------------------- LDS

groupshared taa_half3 SharedInputColor[TILE_SIZE * TILE_SIZE];
groupshared taa_half4 SharedHistoryColorAndMask[TILE_SIZE * TILE_SIZE];


//------------------------------------------------------- ENTRY POINT

taa_half3 TransformToComparisonColorSpace(taa_half3 Color)
{
	return Color;
	//return log2(Color);
	//return Color *HdrWeight4(Color); // *float3(HdrWeightY(Color.r), HdrWeightY(Color.g), HdrWeightY(Color.b));
}


//------------------------------------------------------- ENTRY POINT

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	float4 Debug = 0;
	
	uint2 DispatchThreadId = (
		ZOrder2D(GroupThreadIndex, log2(TILE_SIZE)) +
		GroupId * uint2(TILE_SIZE, TILE_SIZE));

	uint2 InputPixelPos = InputInfo_ViewportMin + DispatchThreadId;
	
	float2 ViewportUV = (float2(DispatchThreadId) + 0.5f) * InputInfo_ViewportSizeInverse;
	float2 ScreenPos = ViewportUVToScreenPos(ViewportUV);
	float2 InputBufferUV = (InputPixelPos + 0.5) * InputInfo_ExtentInverse;
	
	float2 EncodedVelocity = DilatedVelocityTexture[InputPixelPos];
	float DeviceZ = ClosestDepthTexture[InputPixelPos];
	taa_half ParallaxFactor = UncompressParallaxFactor((ParallaxFactorTexture[InputPixelPos] >> 4) & 0xF);
	taa_half3 InputSceneColor = InputSceneColorTexture[InputPixelPos];
	
	taa_half ClosestInputLuma4 = Luma4(InputSceneColor);


	float WorldDepth = ConvertFromDeviceZ(DeviceZ);
	
	// Compute the parralax rejection mask
	taa_half ParallaxRejectionMask = 0.0;
	{
		float2 PrevScreenPos = ScreenPos - DecodeVelocityFromTexture(float4(EncodedVelocity, 0.0, 0.0)).xy;
		float2 PrevInputBufferUV = (InputInfo_ScreenPosToViewportScale * PrevScreenPos + InputInfo_ScreenPosToViewportBias) * InputInfo_ExtentInverse;
		
		FBilinearSampleInfos BilinearInter = GetBilinearSampleLevelInfos(PrevInputBufferUV, InputInfo_Extent, InputInfo_ExtentInverse);

		UNROLL_N(4)
		for (uint i = 0; i < 4; i++)
		{
			float BilinearWeight = GetSampleWeight(BilinearInter, i);
			uint2 PixelPos = GetSamplePixelCoord(BilinearInter, i);

			bool bValidPixelPos = all(PixelPos >= InputInfo_ViewportMin && PixelPos < InputInfo_ViewportMax);

			uint HistoryUseCount = PrevUseCountTexture[PixelPos];
			float HistoryClosestDeviceZ = f16tof32(PrevClosestDepthTexture[PixelPos]);
			float HistoryClosestWorldDepth = ConvertFromDeviceZ(HistoryClosestDeviceZ);

			taa_half DepthRejection;
			{
				const float WorldDepthToPixelWorldRadius = GetTanHalfFieldOfView().x * InputInfo_ExtentInverse.x;
				const float PixelDepthError = 3.0;
				const float RadiusToDiamater = 2.0;
			
				float WorldDepthEpsilon = (WorldDepthToPixelWorldRadius * RadiusToDiamater * PixelDepthError) * HistoryClosestWorldDepth; 
				float DeltaDepth = abs(HistoryClosestWorldDepth - WorldDepth);

				DepthRejection = saturate(taa_half(2.0) - taa_half(DeltaDepth / WorldDepthEpsilon));
			}

			taa_half HistoryGhostingRejection = saturate(taa_half(1.0) - taa_half(3.0) * abs(taa_half(HistoryUseCount) * rcp(taa_half(256)) - taa_half(1.0)));

			FLATTEN
			if (bValidPixelPos)
				ParallaxRejectionMask += taa_half(BilinearWeight) * max(DepthRejection, HistoryGhostingRejection);
		}
	}

	// Pixel coordinate of the input pixel in the predictor viewport.
	float2 InputPPCk = float2(InputPixelPos - InputInfo_ViewportMin) + 0.5f - InputJitter;
	float2 OutputViewportUV = InputPPCk * InputInfo_ViewportSizeInverse;
	float2 OutputScreenPos = ViewportUVToScreenPos(OutputViewportUV);

	float2 PrevOutputScreenPos = OutputScreenPos - DecodeVelocityFromTexture(float4(EncodedVelocity, 0.0, 0.0)).xy;

	float2 PrevOutputViewportUV = ScreenPosToViewportUV(PrevOutputScreenPos);

	float2 HistoryPPCk = PrevOutputViewportUV * PrevHistoryInfo_ViewportSize;

	// Pixel coordinate of the center of the nearest predictor pixel O.
	float2 HistoryPPCo = floor(HistoryPPCk) + 0.5;
	float2 HistoryBufferUV = HistoryPPCo * PrevHistoryInfo_ExtentInverse;

	// Vector in pixel between pixel K -> O.
	taa_half2 dKO = taa_half2(HistoryPPCo - HistoryPPCk);
	
	// Sample the history
	taa_half3 DecimatedColor;
	taa_half HistoryMaxRejectionFactor;

	taa_half ClosestInterferenceSeed;
	taa_half IntegratedInterferenceSeed;
	taa_half MinInterferenceSeed;
	taa_half MaxInterferenceSeed;
	{
		float2 KernelHistoryBufferUV = clamp(
			HistoryPPCk * PrevHistoryInfo_ExtentInverse,
			PrevHistoryInfo_UVViewportBilinearMin,
			PrevHistoryInfo_UVViewportBilinearMax);
		
		float2 PrevInputBufferUV = (InputInfo_ScreenPosToViewportScale * PrevOutputScreenPos + InputInfo_ScreenPosToViewportBias) * InputInfo_ExtentInverse;

		taa_half PrevUninterferenceSeed = PrevHistory_LowResTextures_0.SampleLevel(GlobalBilinearClampedSampler, PrevInputBufferUV, 0);
		taa_half PrevUninterferenceLuma = PrevUninterferenceSeed * HdrWeightInvY(PrevUninterferenceSeed);

		#if 0
		{
			DecimatedColor = PrevHistory_Textures_0.SampleLevel(GlobalBilinearClampedSampler, KernelHistoryBufferUV, 0);
			
			// Cancels out the flickering Luma component with the interference free luma from the inteference seed of the history.
			if (bEnableInterferenceHeuristic)
			{
				DecimatedColor *= PrevUninterferenceLuma * SafeRcp(Luma4(DecimatedColor));
			}
		}
		#else
		{
			DecimatedColor = 0.0;
			UNROLL_N(4)
			for (uint i = 0; i < 4; i++)
			{
				const float2 PixelOffset = float2(Offsets2x2[i]) - 0.5;

				float2 SampleBufferUV = KernelHistoryBufferUV + PixelOffset * PrevHistoryInfo_ExtentInverse; 
				SampleBufferUV = clamp(
					SampleBufferUV,
					PrevHistoryInfo_UVViewportBilinearMin,
					PrevHistoryInfo_UVViewportBilinearMax);
				
				taa_half3 HistorySample = PrevHistory_Textures_0.SampleLevel(GlobalBilinearClampedSampler, SampleBufferUV, 0);

				// Cancels out the flickering Luma component with the interference free luma from the inteference seed of the history.
				if (bEnableInterferenceHeuristic)
				{
					HistorySample *= PrevUninterferenceLuma * SafeRcp(Luma4(HistorySample));
				}

				DecimatedColor += HistorySample;
			}

			DecimatedColor *= rcp(4.0);
		}
		#endif

		// Compute the parallax rejection factor of the details in the history.
		FSubpixelNeighborhood SubpixelNeigborhood = GatherPrevSubpixelNeighborhood(PrevHistory_Textures_3, KernelHistoryBufferUV);
		{
			uint EncodedHistoryMaxRejectionFactor = 0;

			UNROLL_N(SUB_PIXEL_COUNT)
			for (uint SubpixelId = 0; SubpixelId < SUB_PIXEL_COUNT; SubpixelId++)
			{
				taa_subpixel_payload SubpixelPayload = GetSubpixelPayload(SubpixelNeigborhood, SubpixelId);
				taa_subpixel_payload EncodedRejectionFactor = (SubpixelPayload >> SUB_PIXEL_PARALLAX_FACTOR_BIT_OFFSET) & SUB_PIXEL_PARALLAX_FACTOR_BIT_MASK;
				taa_subpixel_payload EncodedInterference = (SubpixelPayload >> SUB_PIXEL_INTERFERENCE_BIT_OFFSET) & SUB_PIXEL_INTERFERENCE_BIT_MASK;

				EncodedHistoryMaxRejectionFactor = max(EncodedHistoryMaxRejectionFactor, EncodedRejectionFactor);
			}

			HistoryMaxRejectionFactor = UncompressParallaxFactor(EncodedHistoryMaxRejectionFactor);
		}

		// Compute the inteference seeds for detection of the interference
		{
			const taa_half RefInterferenceSeed = LumaToInterferenceSeed(ClosestInputLuma4);
			ClosestInterferenceSeed = 0.0;
			taa_half RefInterferenceSeedDist = 2.0;

			MinInterferenceSeed = 1.0;
			MaxInterferenceSeed = 0.0;

			// Searches in the entire 2x2 neighborhood instead because this history is nearest reproject that can causes subpixel
			// shifts over multiple frames.
			UNROLL_N(4)
			for (uint SampleId = 0; SampleId < 4; SampleId++)
			{
				UNROLL_N(SUB_PIXEL_COUNT)
				for (uint SubpixelId = 0; SubpixelId < SUB_PIXEL_COUNT; SubpixelId++)
				{
					taa_subpixel_payload SubpixelPayload = SubpixelNeigborhood.SampleArray[SampleId] >> (SubpixelId * SUB_PIXEL_BIT_COUNT);
					taa_subpixel_payload EncodedInterference = (SubpixelPayload >> SUB_PIXEL_INTERFERENCE_BIT_OFFSET) & SUB_PIXEL_INTERFERENCE_BIT_MASK;
					
					// TODO(G5TAA): move out of the loop.
					taa_half SubpixelSeed = UncompressInteferenceSeed(EncodedInterference);

					FLATTEN
					if (abs(RefInterferenceSeed - SubpixelSeed) < RefInterferenceSeedDist)
					{
						ClosestInterferenceSeed = SubpixelSeed;
						RefInterferenceSeedDist = abs(RefInterferenceSeed - SubpixelSeed);
					}

					MinInterferenceSeed = min(MinInterferenceSeed, SubpixelSeed);
					MaxInterferenceSeed = max(MaxInterferenceSeed, SubpixelSeed);
				}
			}
			
			// actually integrating SubpixelSeed stil suffer interference that causes instability. So instead take
			// average of min and max that turns out interference free.
			IntegratedInterferenceSeed = (MinInterferenceSeed + MaxInterferenceSeed) * 0.5;
		}
	}
	
	// Reject subpixel details that might be in history but not input just based on their parrallax
	{
		taa_half HistorySubdetailRejectionFactor = max(HistoryMaxRejectionFactor / ParallaxFactor, taa_half(1.0));

		float4 ThisClip = float4(ScreenPos, DeviceZ, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
		float2 PrevScreen = PrevClip.xy / PrevClip.w;
			
		float4 RotationalPrevClip = mul(ThisClip, RotationalClipToPrevClip);
		float2 RotationalPrevScreen = RotationalPrevClip.xy / RotationalPrevClip.w;
			
		taa_half PixelParallaxVelocity = taa_half(0.5) * length(taa_half2(RotationalPrevScreen - PrevScreen) * InputInfo_Extent);
		taa_half HistorySubdetailAdditionalParralax = (HistorySubdetailRejectionFactor - taa_half(1.0)) * PixelParallaxVelocity;

		taa_half HistoryParallaxRejectionMask = saturate(taa_half(1.0) - HistorySubdetailAdditionalParralax);

		ParallaxRejectionMask = min(ParallaxRejectionMask, HistoryParallaxRejectionMask);
	}

	// Immediately reject based on the rejection mask
	FLATTEN
	if ((PrevOutputScreenPos.x < -1.0) ||
		(PrevOutputScreenPos.y < -1.0) ||
		(PrevOutputScreenPos.x > 1.0) ||
		(PrevOutputScreenPos.y > 1.0))
	//if (IsOffScreen2(bCameraCut, PrevOutputScreenPos, /* ParallaxRejectionMask = */ 1.0))
	{
		ParallaxRejectionMask = taa_half(0.0);
	}

	
	#if CONFIG_OUTPUT_HALF_RES
	{
		SharedInputColor[GroupThreadIndex] = InputSceneColor;
		SharedHistoryColorAndMask[GroupThreadIndex] = taa_half4(DecimatedColor, ParallaxRejectionMask);

		GroupMemoryBarrierWithGroupSync();

		bool bCheckerboard = (((InputPixelPos.x ^ InputPixelPos.y) >> 1) & 0x1) != 0;

		half3 HalfResInputSceneColor = InputSceneColor;
		half3 HalfResDecimatedColor = DecimatedColor;
		half HalfResParallaxRejectionMask = ParallaxRejectionMask;

		UNROLL
		for (uint i = 1; i < 4; i++)
		{
			uint ButterflySwap = i;
			
			if (bCheckerboard)
			{
				HalfResInputSceneColor = min(HalfResInputSceneColor, SharedInputColor[GroupThreadIndex ^ ButterflySwap]);
			}
			else
			{
				HalfResInputSceneColor = max(HalfResInputSceneColor, SharedInputColor[GroupThreadIndex ^ ButterflySwap]);
			}
			HalfResDecimatedColor += SharedHistoryColorAndMask[GroupThreadIndex ^ ButterflySwap].rgb;

			HalfResParallaxRejectionMask += SharedHistoryColorAndMask[GroupThreadIndex ^ ButterflySwap].a;
		}

		HalfResDecimatedColor *= 0.25;
		HalfResParallaxRejectionMask *= 0.25;

		#if CONFIG_ENABLE_STOCASTIC_QUANTIZATION
		{
			uint2 Random = Rand3DPCG16(int3((InputPixelPos - InputInfo_ViewportMin) / 2, View.StateFrameIndexMod8)).xy;
			float2 E = Hammersley16(0, 1, Random);

			HalfResInputSceneColor = QuantizeForFloatRenderTarget(HalfResInputSceneColor, E.x, OutputQuantizationError);
			HalfResDecimatedColor = QuantizeForFloatRenderTarget(HalfResDecimatedColor, E.x, OutputQuantizationError);
		}
		#endif

		if (all(InputPixelPos < InputInfo_ViewportMax) && all(((InputPixelPos - InputInfo_ViewportMin) % 2) == 0))
		{
			HalfResSceneColorOutput[InputPixelPos / 2] = HalfResInputSceneColor;
			HalfResPredictionSceneColorOutput[InputPixelPos / 2] = HalfResDecimatedColor;
			HalfResParallaxRejectionMaskOutput[InputPixelPos / 2] = HalfResParallaxRejectionMask;
		}
	}
	#endif

	#if CONFIG_ENABLE_STOCASTIC_QUANTIZATION
	{
		uint2 Random = Rand3DPCG16(int3(InputPixelPos - InputInfo_ViewportMin, View.StateFrameIndexMod8)).xy;
		float2 E = Hammersley16(0, 1, Random);

		DecimatedColor = QuantizeForFloatRenderTarget(DecimatedColor, E.x, OutputQuantizationError);
	}
	#endif

	if (all(InputPixelPos < InputInfo_ViewportMax))
	{
		#if !CONFIG_OUTPUT_HALF_RES
		{
			PredictionSceneColorOutput[InputPixelPos] = DecimatedColor;
		}
		#endif
		
		ParallaxRejectionMaskOutput[InputPixelPos] = ParallaxRejectionMask;
		InterferenceSeedOutput[InputPixelPos] = taa_half4(ClosestInterferenceSeed, IntegratedInterferenceSeed, MinInterferenceSeed, MaxInterferenceSeed);

		#if DEBUG_OUTPUT
		{
			DebugOutput[InputPixelPos] = Debug;
		}
		#endif
	}
}
