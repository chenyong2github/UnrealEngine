// Copyright Epic Games, Inc. All Rights Reserved.

#include "TAACommon.ush"


//------------------------------------------------------- ENUMS

/** Kernel enum */
	#define KERNEL_1X1 0
	#define KERNEL_3X3 1
	#define KERNEL_3X3_PLUS 2


//------------------------------------------------------- CONFIG

#define TILE_SIZE 16

#define CONFIG_ACCUMULATE_KARIS_WEIGHTING 1

#define CONFIG_KERNEL (KERNEL_3X3)

// Use a spread factor the size of the clamping box in the history comparison to avoid one flickering input pixel
// to flicker the entire comparison neighborhood
#define CONFIG_KERNEL_SPREAD_FACTOR 3

// Uses a spread factor that varies slightly between 2x2 pixel neighborhood to reduce chances of inteference
// against structured input.
#define CONFIG_USE_DYNAMIC_SPREAD_FACTOR 1


//------------------------------------------------------- PARAMETERS

float3 OutputQuantizationError;

Texture2D<taa_half3> InputTexture;
Texture2D<taa_half3> PredictionSceneColorTexture;
Texture2D<taa_half> ParallaxRejectionMaskTexture;
Texture2D<taa_half> InterferenceWeightTexture;

RWTexture2D<taa_half3> FilteredInputOutput;
RWTexture2D<taa_half3> FilteredPredictionSceneColorOutput;


//------------------------------------------------------- FUNCTIONS

taa_half ComputeColorWeight(taa_half3 Color)
#if CONFIG_ACCUMULATE_KARIS_WEIGHTING
{
	return HdrWeight4(Color);
}
#else
{
	return taa_half(1);
}
#endif

taa_half ParallaxRejectionMaskToHistoryValidity(taa_half ParallaxRejectionMask)
{
	return (ParallaxRejectionMask < taa_half(PARALLAX_REJECTION_MASK_THRESHOLD)) ? taa_half(0.0) : taa_half(1.0);
}

//------------------------------------------------------- ENTRY POINT

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	uint GroupWaveIndex = GetGroupWaveIndex(GroupThreadIndex, /* GroupSize = */ TILE_SIZE * TILE_SIZE);

	float4 Debug = 0.0;
	
	taa_short2 InputPixelPos = (
		taa_short2(InputPixelPosMin) +
		taa_short2(GroupId) * taa_short2(TILE_SIZE, TILE_SIZE) +
		Map16x16Tile2x2Lane(GroupThreadIndex));

	// Fetch center of the kernel
	taa_half3 CenterInput;
	taa_half3 FilteredInput;
	taa_half FilteredInputWeight;
	taa_half3 FilteredHistory;
	taa_half FilteredHistoryWeight;

	{
		taa_half SampleSpatialWeight = 1.0;

		taa_half3 InputSample = InputTexture[InputPixelPos];
		taa_half3 HistorySample = PredictionSceneColorTexture[InputPixelPos];
		taa_half HistorySampleValidity = ParallaxRejectionMaskToHistoryValidity(
			ParallaxRejectionMaskTexture[InputPixelPos]);
		
		taa_half InputWeight = ComputeColorWeight(InputSample);
		taa_half HistoryWeight = HistorySampleValidity * ComputeColorWeight(HistorySample);

		CenterInput = InputSample;

		FilteredInput       = (SampleSpatialWeight * InputWeight) * InputSample;
		FilteredInputWeight = (SampleSpatialWeight * InputWeight);
		
		FilteredHistory       = (SampleSpatialWeight * HistoryWeight) * HistorySample;
		FilteredHistoryWeight = (SampleSpatialWeight * HistoryWeight);
	}
	
	uint StartSampleId;
	uint SampleCount;
	uint SampleTrackId;
	
	#if CONFIG_KERNEL == KERNEL_1X1
	{
		StartSampleId = 0;
		SampleCount = 0;
	}
	#elif CONFIG_KERNEL == KERNEL_3X3 || CONFIG_KERNEL == KERNEL_3X3_PLUS
	{
		StartSampleId = 0;
		SampleCount = 9;
	}
	#else
		#error Unknown kernel
	#endif

	#if CONFIG_USE_DYNAMIC_SPREAD_FACTOR
		taa_short2 DynamicSpreadFactor = (
			taa_short(CONFIG_KERNEL_SPREAD_FACTOR) +
			taa_short2((InputPixelPos % taa_short(2)) ^ (InputPixelPos.yx % taa_short(2))));
	#else
		taa_short2 DynamicSpreadFactor = taa_short(CONFIG_KERNEL_SPREAD_FACTOR);
	#endif

	// Fetch neighborhood of the kernel
	UNROLL
	for (uint SampleId = StartSampleId; SampleId < SampleCount; SampleId++)
	{
		taa_short2 Offset;
		taa_half SampleSpatialWeight;
		
		#if CONFIG_KERNEL == KERNEL_1X1
		{
			Offset = 0;
			SampleSpatialWeight = taa_half(1.0);
			continue;
		}
		#elif CONFIG_KERNEL == KERNEL_3X3 || CONFIG_KERNEL == KERNEL_3X3_PLUS
		{
			if (SampleId == 4)
			{
				continue;
			}
			Offset = taa_short2(kOffsets3x3[SampleId]);
			
			#if CONFIG_KERNEL == KERNEL_3X3_PLUS
				if (abs(Offset.x) + abs(Offset.y) > 1)
				{
					continue;
				}
			#endif
			
			#if 0
				SampleSpatialWeight = taa_half(1.0);
			#elif 1
				SampleSpatialWeight = taa_half(rcp(abs(Offset.x) + 1.0) * rcp(abs(Offset.y) + 1.0));
			#else
				SampleSpatialWeight = taa_half(rcp(abs(Offset.x) + abs(Offset.y)));
			#endif
		}
		#else
			#error Unknown kernel
		#endif
		
		taa_short2 SampleInputPixelPos = InputPixelPos + ClampPixelOffset(
			InputPixelPos,
			DynamicSpreadFactor * Offset, Offset,
			InputPixelPosMin, InputPixelPosMax);

		taa_half3 InputSample = InputTexture[SampleInputPixelPos];
		taa_half3 HistorySample = PredictionSceneColorTexture[SampleInputPixelPos];
		taa_half HistorySampleValidity = ParallaxRejectionMaskToHistoryValidity(
			ParallaxRejectionMaskTexture[SampleInputPixelPos]);
		
		taa_half SampleInterferenceWeight = InterferenceWeightTexture[SampleInputPixelPos];
		
		FLATTEN
		if (!bEnableInterferenceHeuristic)
		{
			SampleInterferenceWeight = 1.0;
		}

		taa_half InputWeight = (HistorySampleValidity * SampleInterferenceWeight) * ComputeColorWeight(InputSample);
		taa_half HistoryWeight = (HistorySampleValidity * SampleInterferenceWeight) * ComputeColorWeight(HistorySample);

		FilteredInput       += (SampleSpatialWeight * InputWeight) * InputSample;
		FilteredInputWeight += (SampleSpatialWeight * InputWeight);
		
		FilteredHistory       += (SampleSpatialWeight * HistoryWeight) * HistorySample;
		FilteredHistoryWeight += (SampleSpatialWeight * HistoryWeight);
	}

	{
		FilteredInput *= SafeRcp(FilteredInputWeight);
		FilteredHistory *= SafeRcp(FilteredHistoryWeight);
	}
	
	taa_short2 OutputPixelPos;
	#if 1
		ISOLATE
		{
			OutputPixelPos = (
				taa_short2(InputPixelPosMin) +
				taa_short2(GroupId) * taa_short2(TILE_SIZE, TILE_SIZE) +
				Map16x16Tile2x2Lane(GetGroupThreadIndex(GroupThreadIndex, GroupWaveIndex)));
		}
	#else
		OutputPixelPos = InputPixelPos;
	#endif

	#if CONFIG_ENABLE_STOCASTIC_QUANTIZATION
	{
		uint2 Random = Rand3DPCG16(int3(OutputPixelPos, View.StateFrameIndexMod8)).xy;
		float2 E = Hammersley16(0, 1, Random);
		
		FilteredInput = QuantizeForFloatRenderTarget(FilteredInput, E.x, OutputQuantizationError);
		FilteredHistory = QuantizeForFloatRenderTarget(FilteredHistory, E.x, OutputQuantizationError);
	}
	#endif

	OutputPixelPos.x = all(OutputPixelPos < LowFrequencyInfo_ViewportMax) ? OutputPixelPos.x : ~taa_short(0);

	FilteredInputOutput[OutputPixelPos] = FilteredInput;
	FilteredPredictionSceneColorOutput[OutputPixelPos] = FilteredHistory;
		
	#if DEBUG_OUTPUT
	{
		DebugOutput[OutputPixelPos - LowFrequencyInfo_ViewportMin] = Debug;
	}
	#endif
}
