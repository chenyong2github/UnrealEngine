// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../Nanite/NaniteDataDecode.ush"
#include "../Nanite/HZBCull.ush"

//StructuredBuffer<FPackedNaniteView> Views;
RWStructuredBuffer<uint> InstanceVisibilityFlagsOut;
uint NumInstances;
uint NumInstanceFlagWords;
uint NumViews;
uint InstanceDataSOAStride;

/**
 */
[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CullInstancesCs(uint InstanceId : SV_DispatchThreadID)
{
	if (InstanceId >= NumInstances)
	{
		return;
	}

	const bool bNearClip = true;

	FInstanceSceneData InstanceData = GetInstanceData(InstanceId, InstanceDataSOAStride);
	uint WordMask = 1U << (InstanceId % 32U);
	uint InstanceWordOffset = InstanceId / 32U;

	bool bIsValid = InstanceData.PrimitiveId != 0xFFFFFFFFu;

	for (uint ViewId = 0; ViewId < NumViews; ++ViewId)
	{
		// NOTE: Default to flagging as visible, which means that invalid instances are marked as visible. This is a workaround that prevents instances that 
		// are uploaded after this kernel runs from being culled. When the culling tests are moved into the later kernel we should switch this back to discarding.
		uint Flag = WordMask;
		if (bIsValid)
		{
			FNaniteView NaniteView = GetNaniteView(ViewId);

			float4x4 LocalToTranslatedWorld = InstanceData.LocalToWorld;
			LocalToTranslatedWorld[3].xyz += NaniteView.PreViewTranslation.xyz;
			float4x4 LocalToClip = mul(LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip);

			FFrustumCullData Cull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, false);

			if (!Cull.bIsVisible)
			{
				Flag = 0U;
			}
		}

		// TODO: we can use ballot etc to do this without atomics (and without clearing) - but it would need to be portable and not sure if 
		// we'll keep this code anyway.
		if (Flag != 0U)
		{
			uint WordOffset = NumInstanceFlagWords * ViewId + InstanceWordOffset;
			InterlockedOr(InstanceVisibilityFlagsOut[WordOffset], Flag);
		}
	}
}
