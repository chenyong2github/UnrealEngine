// Copyright Epic Games, Inc. All Rights Reserved.

#include "TSRCommon.ush"


//------------------------------------------------------- CONFIG

#define TILE_SIZE 8

#define CONFIG_MIN_LUMA_ALIASING 0.05

#define CONFIG_COMPUTE_NOISE_FILTERING 1

#if DIM_QUALITY_PRESET == 1
	#define CONFIG_ITERATIONS 3

#elif DIM_QUALITY_PRESET == 2
	#define CONFIG_ITERATIONS 8

#else
	#error unknown DIM_QUALITY_PRESET
#endif

#if CONFIG_COMPILE_FP16
	// Take advantage of RDNA's v_pk_*_{uif}16 instructions
	#define CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION 1
#else
	#define CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION 0
#endif


//------------------------------------------------------- INCLUDE FXAA


//------------------------------------------------------- PARAMETERS

Texture2D<taa_half> InputSceneColorLdrLumaTexture;

RWTexture2D<uint> AntiAliasingOutput;
RWTexture2D<taa_half> NoiseFilteringOutput;


//------------------------------------------------------- FUNCTIONS

taa_ushort2x2 Map8x8Tile2x2LaneDPV(uint GroupThreadIndex)
#if CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION
{
	taa_ushort T = taa_ushort(GroupThreadIndex);

	taa_ushort2 GroupId;
	GroupId.x =                                             ((T >> taa_ushort(1 - 1)) & taa_ushort(0x03 << 1));
	GroupId.y = ((T >> taa_ushort(0)) & taa_ushort(0x01)) | ((T >> taa_ushort(3 - 1)) & taa_ushort(0x03 << 1));
	
	return dpv_interleave_registers(GroupId, GroupId + taa_ushort2(1, 0));
}
#else
{
	taa_ushort2 GroupId = Map8x8Tile2x2Lane(GroupThreadIndex);
	return dpv_interleave_mono_registers(GroupId);
}
#endif

taa_half2 InputToLDRLuma(taa_half3x2 Color)
{
	taa_half2 Luma = Luma4(Color);
	return Luma * HdrWeightY(Luma);
}

taa_half SampleInputLDRLuma(taa_short2 KernelCenter, taa_short2 Offset)
{
	taa_short2 SampleInputPixelPos = KernelCenter + ClampPixelOffset(
		KernelCenter,
		Offset, Offset,
		InputPixelPosMin, InputPixelPosMax);
	
	return InputSceneColorLdrLumaTexture[SampleInputPixelPos];
}

taa_half2 SampleInputLDRLuma(taa_short2x2 KernelCenter, taa_short2 Offset)
{
	taa_short2x2 SampleInputPixelPos = KernelCenter + ClampPixelOffset(
		KernelCenter,
		dpv_interleave_mono_registers(Offset), Offset,
		InputPixelPosMin, InputPixelPosMax);
	
	taa_half2 InputLuma = dpv_interleave_registers(
		InputSceneColorLdrLumaTexture[dpv_lo(SampleInputPixelPos)],
		InputSceneColorLdrLumaTexture[dpv_hi(SampleInputPixelPos)]);

	return InputLuma;
}

taa_half2 SampleInputLDRLuma(taa_short2x2 KernelCenter, taa_short2x2 Offset)
{
	taa_short2x2 SampleInputPixelPos = ClampPixelOffset(
		KernelCenter + Offset,
		InputPixelPosMin, InputPixelPosMax);
	
	taa_half2 InputLuma = dpv_interleave_registers(
		InputSceneColorLdrLumaTexture[dpv_lo(SampleInputPixelPos)],
		InputSceneColorLdrLumaTexture[dpv_hi(SampleInputPixelPos)]);

	return InputLuma;
}

taa_half2 BilinearSampleInputLDRLuma(float2x2 KernelCenterUV, float2x2 UVOffset, const bool bIsNegativeDirection)
{
	float2x2 SampleUV = KernelCenterUV + UVOffset;

	if (bIsNegativeDirection)
		SampleUV = max(SampleUV, dpv_interleave_mono_registers(InputInfo_UVViewportBilinearMin));
	else
		SampleUV = min(SampleUV, dpv_interleave_mono_registers(InputInfo_UVViewportBilinearMax));

	taa_half2 InputLuma = dpv_interleave_registers(
		InputSceneColorLdrLumaTexture.SampleLevel(GlobalBilinearClampedSampler, dpv_lo(SampleUV), 0),
		InputSceneColorLdrLumaTexture.SampleLevel(GlobalBilinearClampedSampler, dpv_hi(SampleUV), 0));

	return InputLuma;
}

void AccumulateEdgeLength(
	taa_half2 StartLuma, taa_half2 StartEdgeLuma,
	taa_half2 SampleLuma, taa_half2 SampleEdgeLuma,
	taa_half2 LumaDelta,
	inout bool2 bEdgeStopedByIncrement,
	inout bool2 bEdgeStopedByDecrement,
	inout taa_ushort2 EdgeLength)
{
	bool2 bStopNowIncrement = abs(StartLuma - SampleLuma) > LumaDelta;
	bool2 bStopNowDecrement = abs(StartEdgeLuma - SampleEdgeLuma) > LumaDelta;

	bEdgeStopedByIncrement = bEdgeStopedByIncrement || bStopNowIncrement;
	bEdgeStopedByDecrement = bEdgeStopedByDecrement || bStopNowDecrement;

	EdgeLength += (bEdgeStopedByIncrement || bEdgeStopedByDecrement) ? taa_ushort(0) : taa_ushort(1);
}

taa_half ComputeDistanceToEdge(
	bool bEdgeStopedByIncrementN,
	bool bEdgeStopedByIncrementP,
	bool bEdgeStopedByDecrementN,
	bool bEdgeStopedByDecrementP,
	taa_ushort EdgeLengthN,
	taa_ushort EdgeLengthP)
{	
	taa_half fEdgeLengthN = taa_half(EdgeLengthN);
	taa_half fEdgeLengthP = taa_half(EdgeLengthP);
	taa_half fEdgeLength = taa_half(1.0) + fEdgeLengthN + fEdgeLengthP;
	taa_half fEdgeInvLength = rcp(fEdgeLength);

	
	taa_half TexelCenterOffsetToEdge = 0.0;

	const float Min = -0.5;

	FLATTEN
	if (!bEdgeStopedByIncrementN && !bEdgeStopedByIncrementP && !bEdgeStopedByDecrementP && !bEdgeStopedByDecrementN)
	{
		// No aliasing in the neighborhood.
		TexelCenterOffsetToEdge = taa_half(0.0);
	}
	else if (bEdgeStopedByIncrementN && bEdgeStopedByIncrementP)
	{
		// Looks like InputC is concave detail
		TexelCenterOffsetToEdge = taa_half(0.5);
	}
	else if (bEdgeStopedByDecrementN && bEdgeStopedByDecrementP)
	{
		// Looks like InputC is convex detail
		//TexelCenterOffsetToEdge = 0.5;
	}
	else if (bEdgeStopedByIncrementN) // && bEdgeStopedByDecrementP)
	{
		// Looks like staircasing from - to +
		TexelCenterOffsetToEdge = taa_half(0.5) - (EdgeLengthN + taa_half(0.5)) * fEdgeInvLength;
	}
	else if (bEdgeStopedByIncrementP) // && bEdgeStopedByDecrementN)
	{
		// Looks like staircasing from + to -
		TexelCenterOffsetToEdge = taa_half(0.5) - (EdgeLengthP + taa_half(0.5)) * fEdgeInvLength;
	}

	return TexelCenterOffsetToEdge;
}


//------------------------------------------------------- ENTRY POINT

#if CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION
	[numthreads(TILE_SIZE, TILE_SIZE / 2, 1)]
#else
	[numthreads(TILE_SIZE, TILE_SIZE, 1)]
#endif
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	uint GroupWaveIndex = GetGroupWaveIndex(GroupThreadIndex, /* GroupSize = */ TILE_SIZE * TILE_SIZE);

	float4x2 Debug = 0.0;
	
	taa_short2x2 InputPixelPos = dpv_add(
		taa_short2(InputPixelPosMin) + taa_short2(GroupId) * taa_short2(TILE_SIZE, TILE_SIZE),
		taa_short2x2(Map8x8Tile2x2LaneDPV(GroupThreadIndex)));
	
	//Debug[0] = 1.0;

	taa_half2x2 TexelOffset = 0.0;
	taa_half2 NoiseFiltering = 0.0;
	{
		#if CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION && 1
			taa_half InputCache[3 * 4];
			UNROLL_N(3)
			for (int cy = 0; cy < 3; cy++)
			{
				UNROLL_N(4)
				for (int cx = 0; cx < 4; cx++)
				{
					const uint ci = cx + 4 * cy;
					InputCache[ci] = SampleInputLDRLuma(dpv_lo(InputPixelPos), taa_short2(cx - 1, cy - 1));
				}
			}

			#define ReadCache(x, y) taa_half2(InputCache[(x + 1) + 4 * (y + 1)], InputCache[(x + 2) + 4 * (y + 1)])

			taa_half2 InputC = ReadCache( 0,  0);

			taa_half2 InputN = ReadCache( 0, -1);
			taa_half2 InputS = ReadCache( 0, +1);
			taa_half2 InputE = ReadCache(+1,  0);
			taa_half2 InputW = ReadCache(-1,  0);
	
			taa_half2 InputNE = ReadCache(+1, -1);
			taa_half2 InputNW = ReadCache(-1, -1);
			taa_half2 InputSE = ReadCache(+1, +1);
			taa_half2 InputSW = ReadCache(-1, +1);
		#else
			taa_half2 InputC = SampleInputLDRLuma(InputPixelPos, taa_short2( 0,  0));

			taa_half2 InputN = SampleInputLDRLuma(InputPixelPos, taa_short2( 0, -1));
			taa_half2 InputS = SampleInputLDRLuma(InputPixelPos, taa_short2( 0, +1));
			taa_half2 InputE = SampleInputLDRLuma(InputPixelPos, taa_short2(+1,  0));
			taa_half2 InputW = SampleInputLDRLuma(InputPixelPos, taa_short2(-1,  0));
	
			taa_half2 InputNE = SampleInputLDRLuma(InputPixelPos, taa_short2(+1, -1));
			taa_half2 InputNW = SampleInputLDRLuma(InputPixelPos, taa_short2(-1, -1));
			taa_half2 InputSE = SampleInputLDRLuma(InputPixelPos, taa_short2(+1, +1));
			taa_half2 InputSW = SampleInputLDRLuma(InputPixelPos, taa_short2(-1, +1));
		#endif

		bool2 bBrowseVerticaly;
		taa_short2x2 BrowseDirection;
		taa_short2x2 EdgeSide = 0;
		taa_half2 EdgeLuma = 0;

		taa_half2 TotalVarHN = abs(0.5 * (InputNE + InputNW) - InputN);
		taa_half2 TotalVarH  = abs(0.5 * (InputE  + InputW ) - InputC);
		taa_half2 TotalVarHS = abs(0.5 * (InputSE + InputSW) - InputS);
			
		taa_half2 TotalVarVE = abs(0.5 * (InputNE + InputSE) - InputE);
		taa_half2 TotalVarV  = abs(0.5 * (InputN  + InputS ) - InputC);
		taa_half2 TotalVarVW = abs(0.5 * (InputNW + InputSW) - InputW);
		
		taa_half2 DiffN = abs(InputN - InputC);
		taa_half2 DiffS = abs(InputS - InputC);
		taa_half2 DiffE = abs(InputE - InputC);
		taa_half2 DiffW = abs(InputW - InputC);

		#if CONFIG_COMPUTE_NOISE_FILTERING
		{
			NoiseFiltering = max(NoiseFiltering, taa_half(2.0) * TotalVarH - max(DiffE, DiffW));
			NoiseFiltering = max(NoiseFiltering, taa_half(2.0) * TotalVarV - max(DiffN, DiffS));
		}
		#endif

		bBrowseVerticaly = (TotalVarHN + TotalVarH + TotalVarHS) > (TotalVarVE + TotalVarV + TotalVarVW);
		BrowseDirection[0] = bBrowseVerticaly ? taa_short(0) : taa_short(1);
		BrowseDirection[1] = bBrowseVerticaly ? taa_short(1) : taa_short(0);

		FLATTEN
		if (bBrowseVerticaly[0])
		{
			EdgeSide[0][0] = DiffW[0] > DiffE[0] ? -1 : 1;
			EdgeLuma[0] = DiffW[0] > DiffE[0] ? InputW[0] : InputE[0];
		}
		else
		{
			EdgeSide[1][0] = DiffN[0] > DiffS[0] ? -1 : 1;
			EdgeLuma[0] = DiffN[0] > DiffS[0] ? InputN[0] : InputS[0];
		}
		
		FLATTEN
		if (bBrowseVerticaly[1])
		{
			EdgeSide[0][1] = DiffW[1] > DiffE[1] ? -1 : 1;
			EdgeLuma[1] = DiffW[1] > DiffE[1] ? InputW[1] : InputE[1];
		}
		else
		{
			EdgeSide[1][1] = DiffN[1] > DiffS[1] ? -1 : 1;
			EdgeLuma[1] = DiffN[1] > DiffS[1] ? InputN[1] : InputS[1];
		}

		taa_half2 LumaDelta = abs(EdgeLuma - InputC) * 0.5;
		
		bool2 WorthBrowsing = LumaDelta > CONFIG_MIN_LUMA_ALIASING;

		taa_half2 BrowseDelta = saturate(LumaDelta * rcp(taa_half(CONFIG_MIN_LUMA_ALIASING)));
		
		taa_ushort2 EdgeLengthP = 0;
		taa_ushort2 EdgeLengthN = 0;
		
		/**
		 * Increment:
		 *     1 1 1 1 1
		 *     0 0 X 0 1
		 * 
		 * Decrement:
		 *     1 1 1 1 0
		 *     0 0 X 0 0
		 */
		bool2 bEdgeStopedByIncrementP = false;
		bool2 bEdgeStopedByIncrementN = false;
		
		bool2 bEdgeStopedByDecrementP = false;
		bool2 bEdgeStopedByDecrementN = false;
		
#if 1 // Optimized for RDNA 2
		const taa_half BilinearInterp = 0.5;

		float2x2 fBrowseDirection = float2x2(BrowseDirection) * dpv_interleave_mono_registers(InputInfo_ExtentInverse);
		float2x2 KernelUV = (float2x2(InputPixelPos) + 0.5 + float2x2(EdgeSide) * BilinearInterp) * dpv_interleave_mono_registers(InputInfo_ExtentInverse);

		taa_half2 MergedEdgeLuma = BilinearInterp * (EdgeLuma + InputC);
		
		taa_half2 MinLuma = MergedEdgeLuma - taa_half(BilinearInterp * 0.5) * abs(EdgeLuma - InputC);
		taa_half2 MaxLuma = MergedEdgeLuma + taa_half(BilinearInterp * 0.5) * abs(EdgeLuma - InputC);

		bool2 bEdgeMoreLuminous = EdgeLuma > InputC;
		
		taa_ushort2 EdgeStopedByMinLumaP = 0;
		taa_ushort2 EdgeStopedByMinLumaN = 0;
		
		taa_ushort2 EdgeStopedByMaxLumaP = 0;
		taa_ushort2 EdgeStopedByMaxLumaN = 0;
		
		bool bStop = false;
		
		#if CONFIG_COMPILE_FP16
			#define asuint(x) asuint16(x)
			const taa_ushort SignShift = 15;
			const taa_ushort SignMask = 0x8000;
		#else
			const taa_ushort SignShift = 31;
			const taa_ushort SignMask = 0x80000000;
		#endif
			
		EdgeLengthP = CONFIG_ITERATIONS;
		EdgeLengthN = CONFIG_ITERATIONS;
		
		UNROLL_N(CONFIG_ITERATIONS)
		for (uint i = 0; i < CONFIG_ITERATIONS; i++)
		{
			float2x2 NeighborOffset = fBrowseDirection * float(i + 1);

			taa_half2 SampleLumaP = BilinearSampleInputLDRLuma(KernelUV,  NeighborOffset, /* bIsNegativeDirection = */ false);
			taa_half2 SampleLumaN = BilinearSampleInputLDRLuma(KernelUV, -NeighborOffset, /* bIsNegativeDirection = */ true);
				
			//bEdgeStopedByMinLuma = bEdgeStopedByMinLuma || bool2(SampleLuma < MinLuma) && !bEdgeStopedByMaxLuma;
			//bEdgeStopedByMaxLuma = bEdgeStopedByMaxLuma || bool2(SampleLuma > MaxLuma) && !bEdgeStopedByMinLuma;
			taa_ushort2 StopByMinLumaP = asuint(SampleLumaP - MinLuma) & ~EdgeStopedByMaxLumaP;
			taa_ushort2 StopByMaxLumaP = asuint(MaxLuma - SampleLumaP) & ~EdgeStopedByMinLumaP;
			taa_ushort2 StopByMinLumaN = asuint(SampleLumaN - MinLuma) & ~EdgeStopedByMaxLumaN;
			taa_ushort2 StopByMaxLumaN = asuint(MaxLuma - SampleLumaN) & ~EdgeStopedByMinLumaN;

			EdgeStopedByMinLumaP |= StopByMinLumaP;
			EdgeStopedByMaxLumaP |= StopByMaxLumaP;
			EdgeStopedByMinLumaN |= StopByMinLumaN;
			EdgeStopedByMaxLumaN |= StopByMaxLumaN;
				
			//EdgeLength += (bEdgeStopedByMaxLuma || bEdgeStopedByMinLuma) ? 0 : 1;
			EdgeLengthP -= (EdgeStopedByMaxLumaP | EdgeStopedByMinLumaP) >> SignShift;
			EdgeLengthN -= (EdgeStopedByMaxLumaN | EdgeStopedByMinLumaN) >> SignShift;
		}
		
		bool2 bEdgeStopedByMinLumaP = (EdgeStopedByMinLumaP & SignMask) != 0;
		bool2 bEdgeStopedByMinLumaN = (EdgeStopedByMinLumaN & SignMask) != 0;
		
		bool2 bEdgeStopedByMaxLumaP = (EdgeStopedByMaxLumaP & SignMask) != 0;
		bool2 bEdgeStopedByMaxLumaN = (EdgeStopedByMaxLumaN & SignMask) != 0;
		
		bEdgeStopedByIncrementP = (bEdgeMoreLuminous && bEdgeStopedByMaxLumaP) || ((!bEdgeMoreLuminous) && bEdgeStopedByMinLumaP);
		bEdgeStopedByIncrementN = (bEdgeMoreLuminous && bEdgeStopedByMaxLumaN) || ((!bEdgeMoreLuminous) && bEdgeStopedByMinLumaN);
		
		bEdgeStopedByDecrementP = (bEdgeMoreLuminous && bEdgeStopedByMinLumaP) || ((!bEdgeMoreLuminous) && bEdgeStopedByMaxLumaP);
		bEdgeStopedByDecrementN = (bEdgeMoreLuminous && bEdgeStopedByMinLumaN) || ((!bEdgeMoreLuminous) && bEdgeStopedByMaxLumaN);

#else // Reference implementation
		UNROLL_N(CONFIG_ITERATIONS)
		for (uint i = 0; i < CONFIG_ITERATIONS; i++)
		{
			bool2 bIsStoped = (bEdgeStopedByIncrementP || bEdgeStopedByDecrementP) && (bEdgeStopedByIncrementN || bEdgeStopedByDecrementP);

			BRANCH
			if (!bIsStoped.x)
			{
				taa_short2x2 NeighborOffset = BrowseDirection * taa_short(i + 1);

				taa_half2 NeighborP = SampleInputLDRLuma(InputPixelPos, NeighborOffset);
				taa_half2 EdgeP     = SampleInputLDRLuma(InputPixelPos, NeighborOffset + EdgeSide);
			
				taa_half2 NeighborN = SampleInputLDRLuma(InputPixelPos, -NeighborOffset);
				taa_half2 EdgeN     = SampleInputLDRLuma(InputPixelPos, -NeighborOffset + EdgeSide);

				AccumulateEdgeLength(
					InputC, EdgeLuma,
					NeighborP, EdgeP,
					LumaDelta,
					/* inout */ bEdgeStopedByIncrementP,
					/* inout */ bEdgeStopedByDecrementP,
					/* inout */ EdgeLengthP);
			
				AccumulateEdgeLength(
					InputC, EdgeLuma,
					NeighborN, EdgeN,
					LumaDelta,
					/* inout */ bEdgeStopedByIncrementN,
					/* inout */ bEdgeStopedByDecrementN,
					/* inout */ EdgeLengthN);
			}
		}
#endif

		taa_half TexelOffsetLo = ComputeDistanceToEdge(
			bEdgeStopedByIncrementN[0],
			bEdgeStopedByIncrementP[0],
			bEdgeStopedByDecrementN[0],
			bEdgeStopedByDecrementP[0],
			dpv_lo(EdgeLengthN),
			dpv_lo(EdgeLengthP));
		
		taa_half TexelOffsetHi = ComputeDistanceToEdge(
			bEdgeStopedByIncrementN[1],
			bEdgeStopedByIncrementP[1],
			bEdgeStopedByDecrementN[1],
			bEdgeStopedByDecrementP[1],
			dpv_hi(EdgeLengthN),
			dpv_hi(EdgeLengthP));
		
		FLATTEN
		if (!WorthBrowsing[0])
			TexelOffsetLo = 0.0;
		
		FLATTEN
		if (!WorthBrowsing[1])
			TexelOffsetHi = 0.0;

		TexelOffset = dpv_scale(taa_half2x2(EdgeSide), BrowseDelta * dpv_interleave_registers(TexelOffsetLo, TexelOffsetHi));
		
		#if 0
			if (WorthBrowsing.x)
			{
				Debug[0] = abs(TexelOffset[0]);
				Debug[1] = abs(TexelOffset[1]);
				//Debug[2] = abs(DecodeSpatialAntiAliasingOffset(EncodeSpatialAntiAliasingOffset(TexelOffset))[0]);
				//Debug[3] = abs(DecodeSpatialAntiAliasingOffset(EncodeSpatialAntiAliasingOffset(TexelOffset))[1]);
				//Debug[3] = bBrowseVerticaly ? 1 : 0;

				//Debug[0] = EdgeLengthP * taa_ushort2(WorthBrowsing && bBrowseVerticaly);
				//Debug[1] = EdgeLengthN * taa_ushort2(WorthBrowsing && bBrowseVerticaly);
				//Debug[0] = (1 + EdgeLengthP + EdgeLengthN);
				//Debug[0] = EdgeLengthN;
		
				//Debug[0] = WorthBrowsing ? 1 : 0;
				//Debug[0] = EdgeLuma;
				//Debug[0] = (EdgeSide[0] + 2) * 0.25;
				//Debug[1] = (EdgeSide[1] + 2) * 0.25;
			}

			if (1)
			{
				Debug[2][0] = InputSceneColorLdrLumaTexture.SampleLevel(
					GlobalBilinearClampedSampler,
					(float2(dpv_lo(InputPixelPos)) + 0.5 + float2(dpv_lo(TexelOffset))) * InputInfo_ExtentInverse,
					0);
				
				Debug[2][1] = InputSceneColorLdrLumaTexture.SampleLevel(
					GlobalBilinearClampedSampler,
					(float2(dpv_hi(InputPixelPos)) + 0.5 + float2(dpv_hi(TexelOffset))) * InputInfo_ExtentInverse,
					0);
			}
		#endif
	}

	uint2 EncodedTexelOffset = EncodeSpatialAntiAliasingOffset(TexelOffset);

	{
		taa_short2x2 OutputPixelPos = InputPixelPos;
		
		OutputPixelPos = InvalidateOutputPixelPos(OutputPixelPos, InputInfo_ViewportMax);
		
		AntiAliasingOutput[dpv_lo(OutputPixelPos)] = dpv_lo(EncodedTexelOffset);
		NoiseFilteringOutput[dpv_lo(OutputPixelPos)] = dpv_lo(NoiseFiltering);
		
		#if CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION
			AntiAliasingOutput[dpv_hi(OutputPixelPos)] = dpv_hi(EncodedTexelOffset);
			NoiseFilteringOutput[dpv_hi(OutputPixelPos)] = dpv_hi(NoiseFiltering);
		#endif

		#if DEBUG_OUTPUT
		{
			DebugOutput[dpv_lo(OutputPixelPos)] = dpv_lo(Debug);

			#if CONFIG_ENABLE_DUAL_PIXEL_VECTORIZATION
				DebugOutput[dpv_hi(OutputPixelPos)] = dpv_hi(Debug);
			#endif
		}
		#endif
	}
}
