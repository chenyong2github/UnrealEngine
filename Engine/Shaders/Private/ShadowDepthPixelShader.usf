// Copyright Epic Games, Inc. All Rights Reserved. 

/*=============================================================================
	ShadowDepthPixelShader.usf: Pixel shader for writing shadow depth.
=============================================================================*/

// needs to before Common.usf
#define SHADOW_DEPTH_SHADER 1
#define USE_STENCIL_LOD_DITHER	0

#include "Common.ush"

// Reroute SceneTexturesStruct uniform buffer references to the shadow depth pass uniform buffer
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
#define PassStruct ShadowDepthPass
#define SceneTexturesStruct ShadowDepthPass.SceneTextures 
#else
#define PassStruct MobileShadowDepthPass
#define MobileSceneTextures MobileShadowDepthPass.SceneTextures 
#endif

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "ShadowDepthCommon.ush"

#define SECONDARY_OCCLUSION			1

void Main( 
	FShadowDepthVSToPS Inputs,
	in float4 SvPosition : SV_Position		// after all interpolators
#if PERSPECTIVE_CORRECT_DEPTH || COMPILER_METAL
	,out float OutDepth : SV_DEPTH
#endif
	)
{
	ResolvedView = ResolveView();

#if INTERPOLATE_VF_ATTRIBUTES
	
	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Inputs.FactoryInterpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;
	#if INTERPOLATE_POSITION
	    {
			float4 ScreenPosition  = SvPositionToResolvedScreenPosition(SvPosition);  
			
			float3 TranslatedWorld = Inputs.PixelPosition.xyz;

			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, 1, TranslatedWorld, TranslatedWorld);

		}
	#else
		CalcMaterialParameters(MaterialParameters, PixelMaterialInputs, SvPosition, 1);
	#endif

	// Evaluate the mask for masked materials
	GetMaterialClippingShadowDepth(MaterialParameters, PixelMaterialInputs);
#else
	ClipLODTransition(SvPosition.xy);
#endif

#if PERSPECTIVE_CORRECT_DEPTH
	const float InvMaxSubjectDepth = PassStruct.ShadowParams.w;
	Inputs.ShadowDepth = 1 - Inputs.ShadowDepth * InvMaxSubjectDepth;
	Inputs.ShadowDepth += Inputs.DepthBias;

	OutDepth = saturate(Inputs.ShadowDepth);
#elif COMPILER_METAL
	// Metal fragment shader must not be empty,
	// so output depth value explicitly if this shader permuation was not discarded
	OutDepth = SvPosition.z;
#endif
}
