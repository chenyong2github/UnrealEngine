// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	VirtualShadowMapProjection.usf: 
=============================================================================*/

#include "../Common.ush"
#include "../SceneTexturesCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../ScreenSpaceDenoise/SSDPublic.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"
#include "../ScreenSpaceDenoise/SSDPublicHarmonics.ush"
#include "../LightShaderParameters.ush"
#include "PageAccessCommon.ush"
#include "ProjectionCommon.ush"

// See VirtualShadowMapProjection.cpp
// 0 = Output to denoiser
// 1 = Output to screen shadow mask
// 2 = Output debug LOD
#ifndef OUTPUT_TYPE
#define OUTPUT_TYPE 0
#endif

#define MIN_OCCLUDER_DISTANCE 1e-6f

// One per cascade for directional lights
StructuredBuffer< FVirtualShadowMapProjectionShaderData > ShadowMapProjectionData;
Texture2D< uint > PhysicalPagePool;

uint LightType;		// Matches ELightComponentType via defines in SSDDefinitions.ush
uint ProjectionCount;
int DebugOutputType;
float ContactShadowLength;

// Could be per-directional-light parameters, but global is fine for now
int Clipmap;


// TODO: Share LOD visualization color logic between Debug.usf and here (and possibly Nanite debug)
float3 IntToColor(uint Index)
{
	const float3 ColorTable[8] = {
		float3(1.0f, 0.0f, 0.0f),
		float3(0.0f, 1.0f, 0.0f),
		float3(0.0f, 0.0f, 1.0f),

		float3(1.0f, 1.0f, 0.0f),
		float3(0.0f, 1.0f, 1.0f),
		float3(1.0f, 0.0f, 1.0f),

		float3(0.5f, 0.7f, 0.1f),
		float3(1.0f, 1.0f, 1.0f)
	};
	return ColorTable[Index % 8];
}

struct FVirtualSmSample
{
	float Depth;
	uint2 VirtualTexelAddress;
	float2 VirtualTexelAddressFloat;
	uint2 PhysicalTexelAddress;
	uint MipLevel;
	bool bValid;
};

FVirtualSmSample SampleVirtualSmLevel(uint VirtualShadowMapId, float2 ShadowMapUV, uint VSMLevel)
{
	uint VSMLevelDim = CalcLevelDimsTexels(VSMLevel);
	float2 VirtualTexelAddressFloat = ShadowMapUV * float(VSMLevelDim);
	uint2 VirtualTexelAddress = uint2(VirtualTexelAddressFloat);

	// Page map to physical address
	uint2 PhysicalTexelAddress = uint2(0, 0);
	bool PagePresent = VirtualToPhysicalTexel(VirtualShadowMapId, VSMLevel, VirtualTexelAddress, PhysicalTexelAddress);
	if (PagePresent)
	{
		// TODO: maybe store metadata about Max depth (and/or use sparse HZB) for each tile, and early out if completely in shadow (must test using kernel size).
		FVirtualSmSample Result;
		Result.Depth = asfloat(PhysicalPagePool.Load(int3(PhysicalTexelAddress, 0)));
		Result.VirtualTexelAddress = VirtualTexelAddress;
		Result.PhysicalTexelAddress = PhysicalTexelAddress;
		Result.VirtualTexelAddressFloat = VirtualTexelAddressFloat;
		Result.MipLevel = VSMLevel;
		Result.bValid = true;
		return Result;
	}
	else
	{
		FVirtualSmSample Result;
		Result.Depth = 0.0f;
		Result.VirtualTexelAddress = uint2(0, 0);
		Result.PhysicalTexelAddress = uint2(0, 0);
		Result.MipLevel = 0;
		Result.bValid = false;
		return Result;
	}
}

FVirtualSmSample SampleVirtualSm(uint VirtualShadowMapId, float2 ShadowMapUV)
{
	// Compute virtual address, map to physical & sample
	for (uint VSMLevel = 0; VSMLevel < VSM_MAX_MIP_LEVELS; ++VSMLevel)
	{
		FVirtualSmSample Result = SampleVirtualSmLevel(VirtualShadowMapId, ShadowMapUV, VSMLevel);
		if (Result.bValid)
		{
			return Result;
		}
	}

	FVirtualSmSample Result;
	Result.Depth = 0.0f;
	Result.VirtualTexelAddress = uint2(0, 0);
	Result.PhysicalTexelAddress = uint2(0, 0);
	Result.MipLevel = 0;
	Result.bValid = false;
	return Result;
}

float ShadowRayCast(
	float3 RayOriginTranslatedWorld, float3 RayDirection, float RayLength,
	int NumSteps, float StepOffset
)
{
	float4 RayStartClip	= mul( float4( RayOriginTranslatedWorld, 1 ), View.TranslatedWorldToClip );
	float4 RayDirClip	= mul( float4( RayDirection * RayLength, 0 ), View.TranslatedWorldToClip );
	float4 RayEndClip	= RayStartClip + RayDirClip;

	float3 RayStartScreen = RayStartClip.xyz / RayStartClip.w;
	float3 RayEndScreen = RayEndClip.xyz / RayEndClip.w;
	
	float3 RayStepScreen = RayEndScreen - RayStartScreen;

	float3 RayStartUVz = float3( RayStartScreen.xy * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz, RayStartScreen.z );
	float3 RayStepUVz = float3( RayStepScreen.xy * View.ScreenPositionScaleBias.xy, RayStepScreen.z );

	float4 RayDepthClip	= RayStartClip + mul( float4( 0, 0, RayLength, 0 ), View.ViewToClip );
	float3 RayDepthScreen = RayDepthClip.xyz / RayDepthClip.w;

	const float Step = 1.0 / NumSteps;

	// *2 to get less moire pattern in extreme cases, larger values make object appear not grounded in reflections
	const float CompareTolerance = abs( RayDepthScreen.z - RayStartScreen.z ) * Step * 2;

	float SampleTime = StepOffset * Step + Step;

	float FirstHitTime = -1.0;

	for( int i = 0; i < NumSteps; i++ )
	{
		float3 SampleUVz = RayStartUVz + RayStepUVz * SampleTime;
		float SampleDepth = SceneTexturesStruct.SceneDepthTexture.SampleLevel( SceneTexturesStruct.SceneDepthTextureSampler, SampleUVz.xy, 0 ).r;

		float DepthDiff = SampleUVz.z - SampleDepth;
		bool Hit = abs( DepthDiff + CompareTolerance ) < CompareTolerance;

		FirstHitTime = (Hit && FirstHitTime < 0.0) ? SampleTime : FirstHitTime;

		SampleTime += Step;
	}

	float Shadow = FirstHitTime > 0.0 ? 1.0 : 0.0;

	// Off screen masking
	float2 Vignette = max(6.0 * abs(RayStartScreen.xy + RayStepScreen.xy * FirstHitTime) - 5.0, 0.0);
	Shadow *= saturate( 1.0 - dot( Vignette, Vignette ) );

	return 1 - Shadow;
}

float4 EncodeLightAttenuationFromMask(float ShadowMask)
{
	const float ShadowFadeFraction = 1;
	float SSSTransmission = ShadowMask;

	// 0 is shadowed, 1 is unshadowed
	// RETURN_COLOR not needed unless writing to SceneColor;
	float FadedShadow = lerp(1.0f, Square(ShadowMask), ShadowFadeFraction);
	float FadedSSSShadow = lerp(1.0f, Square(SSSTransmission), ShadowFadeFraction);

	// the channel assignment is documented in ShadowRendering.cpp (look for Light Attenuation channel assignment)
	return EncodeLightAttenuation(half4(FadedShadow, FadedSSSShadow, FadedShadow, FadedSSSShadow));
}

// Receiver depth is post-projection-divide.
float ComputeOccluderDistance(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth, float3 ReceiverShadowViewPosition)
{
	float Result = 0.0f;
	if (ShadowViewToClip._44 < 1.0f)
	{
		// Perspective projection
		float OccluderViewZ = ShadowViewToClip._43 / (OccluderDepth - ShadowViewToClip._33);
		float ReceiverViewZ = ShadowViewToClip._43 / (ReceiverDepth - ShadowViewToClip._33);

		// Similar triangles to compute euclidean distance in view/world space
		float ReceiverDistance = length(ReceiverShadowViewPosition);
		float OccluderDistance = (ReceiverDistance / ReceiverViewZ) * OccluderViewZ;
		Result = ReceiverDistance - OccluderDistance;
	}
	else
	{
		// Ortho
		float OccluderViewZ = (OccluderDepth - ShadowViewToClip._43) / ShadowViewToClip._33;
		float ReceiverViewZ = (ReceiverDepth - ShadowViewToClip._43) / ShadowViewToClip._33;

		// No perspective projection, so simple difference gets us the distance
		Result = ReceiverViewZ - OccluderViewZ;
	}
	return max(MIN_OCCLUDER_DISTANCE, Result);
}

// Returns negative number if pixel is not in *any* of the cascades
int GetCascadeIndexForPixel(float Depth)
{
	// Determine which cascade we fall into
	// NOTE: Since we are currently not using derivatives/filtered texture lookups there is no need to force this to remain
	// consisent across the pixel quad.

	// NOTE: Cascades are sorted in reverse order, so we'll greedily pick from the end of the list in case there is any overlap
	int CascadeIndex;
	for (CascadeIndex = ProjectionCount - 1; CascadeIndex >= 0; --CascadeIndex)
	{
		if (Depth >= ShadowMapProjectionData[CascadeIndex].MinSceneDepth &&
			Depth < ShadowMapProjectionData[CascadeIndex].MaxSceneDepth)
		{
			break;
		}
	}
	return CascadeIndex;
}

void VirtualShadowMapProjectionPS(
	in float4 SvPosition : SV_Position,
	out float4 OutputTarget : SV_Target
	)
{
	// TODO: Unify this with the logic in PageManagement.usf - we need to get the same values in both passes
	const float2 ScreenUV = SvPositionToBufferUV(SvPosition);
	const float DeviceZ = LookupDeviceZ(ScreenUV);
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(float4(SvPosition.xy, DeviceZ, 1.0f));
		
	// TODO: Early out on sky, etc.
	bool bClipmap = Clipmap > 0;
	bool bInLightRegion = true;
	int ProjectionDataIndex = 0;

	FLightShaderParameters Light = GetRootLightShaderParameters();
	float3 ToLight = Light.Direction;
	if (LightType == LIGHT_TYPE_SPOT)
	{
		// Early out if we're outside the spot light cone		
		ToLight = Light.Position - (TranslatedWorldPosition - View.PreViewTranslation);
		bool bInLightRadius = length(ToLight) <= rcp(Light_InvRadius);
		ToLight = normalize(ToLight);
		bool bInLightCone = dot(ToLight, Light.Direction) >= Light.SpotAngles.x;
		bInLightRegion = bInLightRegion && bInLightRadius && bInLightCone;
	}
	else if (LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		if (bClipmap)
		{
			float3 ViewPosition = mul(float4(TranslatedWorldPosition, 1.0f), View.TranslatedWorldToView).xyz;

			const int FirstClipmapLevel = ShadowMapProjectionData[0].ClipmapLevel;
			const int ClipmapLevelCount = ShadowMapProjectionData[0].ClipmapLevelCount;
			const float ClipmapResolutionLodBias = ShadowMapProjectionData[0].ClipmapResolutionLodBias;
			int ClipmapLevel = CalcClipmapLevel(ViewPosition, ClipmapResolutionLodBias);
			ProjectionDataIndex = max(0, ClipmapLevel - FirstClipmapLevel);
			bInLightRegion = (ProjectionDataIndex < ClipmapLevelCount);
		}
		else
		{
			ProjectionDataIndex = GetCascadeIndexForPixel(SceneDepth);
			bInLightRegion = (ProjectionDataIndex >= 0);
		}
	}
	if (!bInLightRegion)
	{
		discard;
	}
	
	float ContactShadow = 1.0f;
	float ContactShadowLengthWorld = 0.0f;
	if (ContactShadowLength > 0.0f)
	{
		ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;
		float StepOffset = InterleavedGradientNoise( SvPosition.xy, View.StateFrameIndexMod8 );
		ContactShadow = ShadowRayCast( TranslatedWorldPosition, ToLight, ContactShadowLengthWorld, 12, StepOffset );
	
		// Move shadow map lookup to end of screen space ray.
		TranslatedWorldPosition += ToLight * ContactShadowLengthWorld;
	}

	// NOTE: Could skip most of the rest of the shader if contact shadows say we're shadowed, but likely to be small, incoherent branching

	FVirtualShadowMapProjectionShaderData ProjectionData = ShadowMapProjectionData[ProjectionDataIndex];

	FShadowPosition ShadowPosition = WorldToShadow(ProjectionData, TranslatedWorldPosition - View.PreViewTranslation);
	
	// TODO: SampleVirtualSmLevel for clipmap
	FVirtualSmSample SmSample;
	if (bClipmap)
	{
		SmSample = SampleVirtualSmLevel(ProjectionData.VirtualShadowMapId, ShadowPosition.UV, 0);
	}
	else
	{
		SmSample = SampleVirtualSm(ProjectionData.VirtualShadowMapId, ShadowPosition.UV);
	}

	if (!SmSample.bValid)
	{
		// Generally shouldn't occur if PT allocation is conservative
		discard;
	}

	// 3.1, figure out slope, we do world space since that is the space where we might override using the shading normal...
	float3 TranslatedWorldPositionDDX = DDX(TranslatedWorldPosition);
	float3 TranslatedWorldPositionDDY = DDY(TranslatedWorldPosition);
	float3 EstimatedGeoWorldNormal = normalize(cross(TranslatedWorldPositionDDX, TranslatedWorldPositionDDY));

#if 1
	FGBufferData GBufferData = GetGBufferData(ScreenUV);
	// If the estimated geo normal is too far out we assume it's broken (derivative includes other surfaces or background) and fall back to the shading normal
	if (dot(GBufferData.WorldNormal, EstimatedGeoWorldNormal) < 0.25f)
	{
		EstimatedGeoWorldNormal = GBufferData.WorldNormal;
	}
#endif

	// Transform geometry world-space plane eq to shadow 'UV' texture space [0-1] ranges
	float4 NormalPlaneWorld = float4(EstimatedGeoWorldNormal, -dot(EstimatedGeoWorldNormal, TranslatedWorldPosition));
	float4 NormalPlaneUv = mul(NormalPlaneWorld, ProjectionData.TranslatedWorldToShadowUvNormalMatrix);
		
	float2 DepthSlopeUv = -NormalPlaneUv.xy / NormalPlaneUv.z;
	float MipLevelDim = float(CalcLevelDimsTexels(SmSample.MipLevel));
	float2 TexelCenter = float2(SmSample.VirtualTexelAddress) + 0.5;
	float2 TexelCenterOffset = TexelCenter - SmSample.VirtualTexelAddressFloat;
	float2 TexelCenterOffsetUv = TexelCenterOffset / MipLevelDim;
	// 2x factor due to lack of precision (probably)
	float OptimalSlopeBias = 2.0f * max(0.0f, dot(DepthSlopeUv, TexelCenterOffsetUv));
	// Clamp to avoid excessive degenerate slope biases causing flickering lit pixels
	OptimalSlopeBias = min(OptimalSlopeBias, 0.01f);

	//SmSample.Depth = asfloat( max( asint( SmSample.Depth ) - 1, 0 ) );

	float SmSampleBiasedDepth = SmSample.Depth - OptimalSlopeBias;

	if (ContactShadowLength == 0.0f)
	{
		// When not doing contact shadow trace, at least add a constant bias to avoid obvious artifacts
		// TODO: Could pull this bias itself from the contact shadow length... say if negative or something.
		// This is mostly a debug path though so fine for the moment.
		SmSampleBiasedDepth -= 0.0006f * SmSample.Depth;
	}

	// See signal encoding for SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION in SSDSignalBufferEncoding.ush
	float4 OutputSignal = float4(0, 0, 0, 0);
	if (SmSampleBiasedDepth > ShadowPosition.Depth)
	{
		// Hit
		float OccluderDistance = ComputeOccluderDistance(ProjectionData.ShadowViewToClipMatrix, SmSampleBiasedDepth, ShadowPosition.Depth, ShadowPosition.View);
		float WorldBluringRadius = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LightType, Light, OccluderDistance);
		OutputSignal = float4(0, 1, WorldBluringRadius, 0);
	}
	else
	{
		// Miss
		OutputSignal = float4(1, 1, -1, 0);
	}

	if( ContactShadow < 1 )
	{
		OutputSignal.x *= ContactShadow;
		OutputSignal.z = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LightType, Light, ContactShadowLengthWorld);
	}

#if OUTPUT_TYPE == 0
	// Output feeds into denoiser
	OutputTarget = OutputSignal;
#elif OUTPUT_TYPE == 1
	// Output to screen shadow mask
	OutputTarget = EncodeLightAttenuationFromMask(OutputSignal.r);
#elif OUTPUT_TYPE == 2
	// Output debug for "vis".
	float3 Color = float3(0, 0, 0);

	if (DebugOutputType == 1)		// Cascade/clipmap
	{
		int Index = bClipmap ? (ProjectionDataIndex) : (ProjectionCount - ProjectionDataIndex - 1);
		Color = lerp(IntToColor(Index), OutputSignal.rrr, 0.4f);
	}
	else if (DebugOutputType == 2)			// Mip level/LOD
	{
		Color = lerp(IntToColor(SmSample.MipLevel + 1), OutputSignal.rrr, 0.0f);
	}
	else if (DebugOutputType == 3)		// Invalid page
	{
		Color = SmSample.bValid ? (0.25f * OutputSignal.rrr) : float3(1, 0, 1);
	}

	//Color = OptimalSlopeBias.xxx * 1.0f;

	OutputTarget = float4(Color, 1.0f);
	
#endif // OUTPUT_TYPE
}

Texture2D<float4> InputSignal;

void VirtualShadowMapCompositePS(
	in float4 SvPosition : SV_Position,
	out float4 OutShadowMask : SV_Target
	)
{
	// NOTE: The signal is encoded as per SSDSignalBufferEncoding.ush, SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION
	float4 Input = InputSignal.Load(int3(SvPosition.xy, 0));
	float SampleCount = Input.g;
	float MissCount = Input.r;
	float Shadow = (SampleCount > 0 ? MissCount : 1.0f);
	
	OutShadowMask = EncodeLightAttenuationFromMask(Shadow);
}
