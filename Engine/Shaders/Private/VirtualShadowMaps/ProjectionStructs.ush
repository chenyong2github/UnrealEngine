// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

// Must match C++ structure in VirtualShadowMapArray.h
// While we currently load/unpack it manually in GetVirtualShadowMapProjectionData,
// the intention is to turn this back into a simple structure load once the compiler
// infrastructure is broadly available.
struct FVirtualShadowMapProjectionShaderData
{
	float4x4 TranslatedWorldToShadowViewMatrix;
	float4x4 ShadowViewToClipMatrix;
	float4x4 TranslatedWorldToShadowUVMatrix;
	float4x4 TranslatedWorldToShadowUVNormalMatrix;

	float3 ShadowPreViewTranslation;
	uint LightType;		// Matches ELightComponentType via defines in SSDDefinitions.ush

	float3 ClipmapWorldOrigin;
	int VirtualShadowMapId;

	int2 ClipmapCornerOffset;
	int ClipmapIndex;		// 0..ClipmapLevelCount-1
	int ClipmapLevel;

	int ClipmapLevelCount;	
	float ClipmapResolutionLodBias;
};

FVirtualShadowMapProjectionShaderData GetVirtualShadowMapProjectionData(int VirtualShadowMapId)
{
	FVirtualShadowMapProjectionShaderData Result;

	// Seems the FMatrix forces 16-byte alignment, so ensure padding matches the C++ structure size
	const uint Stride = 16 * 20;
	const uint Base = VirtualShadowMapId * Stride;

	Result.TranslatedWorldToShadowViewMatrix[0]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*0));
	Result.TranslatedWorldToShadowViewMatrix[1]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*1));
	Result.TranslatedWorldToShadowViewMatrix[2]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*2));
	Result.TranslatedWorldToShadowViewMatrix[3]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*3));
	Result.ShadowViewToClipMatrix[0]				= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*4));
	Result.ShadowViewToClipMatrix[1]				= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*5));
	Result.ShadowViewToClipMatrix[2]				= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*6));
	Result.ShadowViewToClipMatrix[3]				= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*7));
	Result.TranslatedWorldToShadowUVMatrix[0]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*8));
	Result.TranslatedWorldToShadowUVMatrix[1]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*9));
	Result.TranslatedWorldToShadowUVMatrix[2]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*10));
	Result.TranslatedWorldToShadowUVMatrix[3]		= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*11));
	Result.TranslatedWorldToShadowUVNormalMatrix[0]	= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*12));
	Result.TranslatedWorldToShadowUVNormalMatrix[1]	= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*13));
	Result.TranslatedWorldToShadowUVNormalMatrix[2]	= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*14));
	Result.TranslatedWorldToShadowUVNormalMatrix[3]	= asfloat(VirtualShadowMap.ProjectionData.Load4(Base + 16*15));

	// NOTE: Stick with struct-element-sized loads for the moment since we may only be using subsets
	// of the data in the calling code and we want to ensure the compiler has simple DCE options.
	Result.ShadowPreViewTranslation			= asfloat(VirtualShadowMap.ProjectionData.Load3(Base + (16*16 + 4*0)));
	Result.LightType						=		 (VirtualShadowMap.ProjectionData.Load (Base + (16*16 + 4*3)));

	Result.ClipmapWorldOrigin				= asfloat(VirtualShadowMap.ProjectionData.Load3(Base + (16*17 + 4*0)));
	Result.VirtualShadowMapId				= asint	 (VirtualShadowMap.ProjectionData.Load (Base + (16*17 + 4*3)));

	Result.ClipmapCornerOffset				= asint  (VirtualShadowMap.ProjectionData.Load2(Base + (16*18 + 4*0)));
	Result.ClipmapIndex						= asint  (VirtualShadowMap.ProjectionData.Load (Base + (16*18 + 4*2)));
	Result.ClipmapLevel						= asint  (VirtualShadowMap.ProjectionData.Load (Base + (16*18 + 4*3)));

	Result.ClipmapLevelCount 				= asint  (VirtualShadowMap.ProjectionData.Load (Base + (16*19 + 4*0)));
	Result.ClipmapResolutionLodBias			= asfloat(VirtualShadowMap.ProjectionData.Load (Base + (16*19 + 4*1)));

	return Result;
}
